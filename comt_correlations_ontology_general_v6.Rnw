% NEW based on MB-COMT data

\documentclass[11pt]{article}
\usepackage{graphicx, subfig}
\usepackage{float}
\pagenumbering{arabic}
\usepackage{enumerate}
\usepackage{Sweave}
\usepackage{booktabs}
\usepackage[table]{xcolor}
\usepackage{framed}
\usepackage{longtable}
\usepackage{tablefootnote}
\usepackage{amsmath}
\usepackage{hyperref}


\begin{document}
\SweaveOpts{concordance=TRUE}
\SweaveOpts{keep.source=TRUE} 

\hspace{-1.5em}Gene Network\\
COMT expression correlations in Four Bartin Areas\\
Fall, 2017\\


<<echo=FALSE>>=
biocLite('enrichR')
library('enrichR')
dbs.Enrichr <- listEnrichrDbs()


installed.pkgs <- c("ggExtra",
"psych",
"knitr",
"Hmisc",
"openxlsx",
"xtable",
"magrittr",
"tables",
"plyr",
"rlist",
"qqman",
"manhattanly",
"Cairo",
"RColorBrewer",
"HGNChelper",
"tools",
"scales",
"devtools",
"utils",
"ggman",
"dplyr",
"biomaRt",
"combinat",
"Rmpfr",
"stats",
"stringr",
"mvtnorm",
"miscFuncs",
"reporttools",
"glm2",
"reshape2",
"plotly",
"gmp",
"R.utils",
"curl",
"igraph",
"data.tree",
"gmodels",
"digest",
"seqinr",
"tidyverse",
"HDMD",
"seqLogo",
"ggthemes",
"reporttools",
"PropCIs",
"data.table")


library(ggplot2,ggthemes)
library(ggExtra)
library(psych)
library(knitr)
library(Hmisc)
library(openxlsx)
library(xtable)
library(magrittr)
library(tables)
#library(plyr)
library(rlist)
# library(qqman)
# library(manhattanly)
library(Cairo)
library(RColorBrewer)
library(HGNChelper)
library(tools)
library(scales)
library(devtools)
library(utils)
# library(ggman)
library(dplyr)
library(biomaRt)
library(combinat)
library(Rmpfr)
library(stats)
library(stringr)
library(mvtnorm)
library(miscFuncs)
library(reporttools)
library(glm2)
library(reshape2)
library(plotly)
library(gmp)
library(R.utils)
library(curl)
library(igraph)
library(data.tree)
library(gmodels)
library(digest)
library(seqinr)
library(tidyverse)
library(HDMD)
library(seqLogo)
library(ggthemes)
library(reporttools)
library(PropCIs)
library(data.table)



### to prepend filename strings to plots
#pre.Name <- c('comt_expression-') #pre-ppended to eps output files

setwd('/Volumes/Macintosh_HD_3/genetics/genenetwork2/')

# new plots directory

new_plots <- '/Volumes/Macintosh_HD_3/genetics/genenetwork2/new_plots/'

# RColorBrewer palette
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
################ READ THIS LIST OF TO-BE SOURCED FUNCTIONS AND PROGRAMS IN #################

fileConn<-file('sourced_functions_programs.txt')
     sourced.Funcs <- 
          data.frame(rfunc=readLines(con=fileConn),stringsAsFactors = FALSE)

     temp.Funcs <- str_replace(sourced.Funcs$rfunc,',','.R')
          sourced.Funcs <- data.frame(rfunc=as.character(temp.Funcs),stringsAsFactors = FALSE)
     temp2.Funcs <- paste(work.path,sourced.Funcs$rfunc,sep='') 
          sourced.Funcs <- data.frame(rfunc=as.character(temp2.Funcs),stringsAsFactors = FALSE)
close(fileConn)

source(sourced.Funcs$rfunc[1:length(sourced.Funcs)])
#############################################################################################

# Read in the mapping between Chromosome names ordered by text (e.g., 1, 10, 11, 12...2, 20...) and ordered by number (e.g., 1, 2, 3, 4 ..., 22, X, Y)

wbchr <- loadWorkbook('order_Chr_by_num.xlsx')   

# now tell R to read that workbook and which sheet
  order.Chr.by.num <- data.frame(read.xlsx(wbchr,sheet = "chr_map"))


stand.Col.names <- c('Prefrontal',
                     'Cerebellum',
                     'Temporal',
                     'Pons')
gold.R <- c(1.61803398875)
@

<<include=FALSE, echo=FALSE, results=hide>>=
# Generate a unique ID for this program by path and filename. This unique ID is attached to this file using a tag in the filesystem.
fname <- csf()   # function to get current path including file name

          prog.Name <- unique.ID(fname)

          prog.Name   # unique ID based on hash of file name

# Write out the file_name, unique ID and date/time to '.Rscriptnames'

          rec.script(eval(fname),eval(prog.Name))
@

This program has the unique ID: \Sexpr{prog.Name}.

<<include=FALSE,echo=FALSE,results=hide>>=

# install_github("wjawaid/enrichR")
# library('enrichR')


# install_github("kassambara/easyGgplot2")
# library(easyGgplot2)

# myBioCLite() # This function updates only the packages that need to be updated

biocLite('topGO')
library('topGO')

source("https://bioconductor.org/biocLite.R")
# if (reread.Data) {
  biocLite(c("GenomicFeatures"))
  biocLite(c("AnnotationDbi"))
  biocLite(c("org.Hs.eg.db"))
# }

library("AnnotationHub")
library("GenomicFeatures")
library("org.Hs.eg.db")

#biocLite('TCGAbiolinks')
#library('TCGAbiolinks')


# if (reread.Data) {
     biocLite(c('hgu95av2.db'))
# }

library('hgu95av2.db')

# if (reread.Data) {
#      biocLite("illuminaHumanv4.db",suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }

# library("illuminaHumanv4.db")

source("https://bioconductor.org/workflows.R")

# if (reread.Data) {
 workflowInstall("annotation")
# }

# if (reread.Data) {
 biocLite("TxDb.Hsapiens.UCSC.hg19.knownGene")
# }

library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene #shorthand (for convenience) 

library(TxDb.Hsapiens.UCSC.hg19.knownGene)
  library(BSgenome.Hsapiens.UCSC.hg19)

# if (reread.Data) {
biocLite("GO.db")
# }
# 
# if (reread.Data) {
biocLite("topGO")
# }     
# 
# if (reread.Data) {
biocLite("GOstats")
# } 
     
library("GO.db")
 library("topGO")
library("GOstats")

# if (reread.Data) {
#      biocLite('EDASeq',suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }

# library('EDASeq')

# if (reread.Data) {
#      biocLite('lumi',suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }

# library(lumi)

# if (reread.Data) {
#      biocLite('lumiHumanIDMapping',suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }

# library(lumiHumanIDMapping)
# 
# # if(reread.Data) {
# #      biocLite('lumiHumanAll.db',suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# # }
# 
# library('lumiHumanAll.db')

# if(reread.Data) {
#      biocLite('rBLAST',suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }

# library(rBLAST)


#      biocLite (c( "beadarray" , "limma" , "GEOquery" , "illuminaHumanv2.db"),
#                suppressUpdates=sUs, suppressAutoUpdate=sAUs)
#library(limma)
# 
# if (reread.Data) {
     biocLite('annotate')
# }

#  if (reread.Data) {
# #      biocLite("GEOquery",suppressUpdates=sUs, suppressAutoUpdate=sAUs)
#  }

library('annotate')

# library("illuminaHumanv2.db")
# library("beadarray","limma")

options(scipen = 999, digits = 5, width = 60, knitr.table.format = "latex")
opts_chunk$set(include=FALSE,
               echo=FALSE,
               message=FALSE,
               warning=FALSE)

biocLite('motifRG','MotifDb')
library('motifRG')
library('MotifDb')

biocLite('PWMEnrich')
library('PWMEnrich')
biocLite('PWMEnrich.Hsapiens.background')
library('PWMEnrich.Hsapiens.background')

biocLite('RcisTarget')
library('RcisTarget')

@



{\textit {COMT}} catalyzes degradation of catecholamines including dopamine, norepinephrine and epinephrine.\\ 
<<echo=FALSE, include=FALSE, results=tex>>=
coexpress.URL <- data.frame(site=NA,addr=NA)
coexpress.URL[1,1:2] <- c('COXPRESdb','http://coxpresdb.jp/')
coexpress.URL[2,1:2] <- c('OMICtools','https://omictools.com/')
coexpress.URL[3,1:2] <- c('Coexpedia','http://www.coexpedia.org/search.php')
coexpress.URL[4,1:2] <- c('GeneFriends','http://www.genefriends.org/RNAseq/')
coexpress.URL[5,1:2] <- c('Illumina Probes','http://www.genomequebec.mcgill.ca/compgen/integratedvervetgenomics/transcriptome/Illumina/allprobes.html')
coexpress.URL[6,1:2] <- c('Gibbs Expression Data','https://www.ncbi.nlm.nih.gov/geo/query')
coexpress.URL[7,1:2] <- c('Train Online','https://www.ebi.ac.uk/training/online/course/arrayexpressdiscoverfunctionalgenomicsdataqui/references')
coexpress.URL[8,1:2] <- c('Enrichr','http://amp.pharm.mssm.edu/Enrichr/enrich')

url.Tab <- xtable(coexpress.URL)
url.Table <- latex(url.Tab,file='',
                   caption = c("Gene Coexpression Databases"),
                   caption.loc = c('top'),
                     colname = c('Name','URL'),
                     rowlabel = c(''),
                     colnamesTexCmd="bfseries",
                     booktabs=TRUE,
                     label=c('tabcoexpressurls'),
                     na.blank = TRUE,
                     vbar = FALSE,
                     longtable=TRUE,
                     table.env=TRUE,
                     center=c('center'),
                     continued=c('Gene Coexpression Databases Continued'),
                     first.hline.double = TRUE,
                     append=FALSE
                     )

@


\Sexpr{url.Table}

<<echo=FALSE, results=tex>>=
entrez_object <- org.Hs.egGO    



ensembl <- useMart("ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl")
#ensembl = useEnsembl(biomart="ensembl",dataset = "hsapiens_gene_ensembl")



normal.chroms <- c(1:22, "X", "Y", "M")

 ah <- AnnotationHub()



 orgs <- AnnotationHub::query(ah, "org.Hs.eg.db")



 gene.DB <- orgs[["AH57973"]]


# columns(gene.DB)
# keytypes(gene.DB)


############################################################################
## Bimap interface:
x <- org.Hs.egCHR
# Get the entrez gene identifiers that are mapped to a chromosome
mapped_genes <- mappedkeys(x)
# Convert to a list
xx <- as.list(x[mapped_genes])

@



<<echo=FALSE,include=FALSE,results=hide>>=
### read the data file 


wball <- loadWorkbook('comt_correlations_20000_all_areas_augmentedNew.xlsx')   

# now tell R to read that workbook and which sheet
  prefront.Data <- data.frame(read.xlsx(wball,sheet = "prefrontal"))
  
  cbell.Data <- data.frame(read.xlsx(wball,sheet = "cerebellum"))

  tempor.Data <- data.frame(read.xlsx(wball,sheet = "temporal"))

  pons.Data <- data.frame(read.xlsx(wball,sheet = "pons"))
  
   Store(prefront.Data,
        cbell.Data,
        tempor.Data,
        pons.Data)


# create a list with these data frames to be used when the same operation is applied to all area
  
major.Area <- list(pf=prefront.Data,
                   cb=cbell.Data,
                   tm=tempor.Data,
                   po=pons.Data)

################# Top 500 by area strongly COMT correlated genes (pval ranked) #################
### read the data file 

wbtop <- loadWorkbook('top_500_pval_ranked.xlsx')   

# now tell R to read that workbook and which sheet
  top500.prefront.Data <- data.frame(read.xlsx(wbtop,sheet = "prefrontal"))
  
  top500.cbell.Data <- data.frame(read.xlsx(wbtop,sheet = "cerebellum"))

  top500.tempor.Data <- data.frame(read.xlsx(wbtop,sheet = "temporal"))

  top500.pons.Data <- data.frame(read.xlsx(wbtop,sheet = "pons"))
  
   Store(top500.prefront.Data,
        top500.cbell.Data,
        top500.tempor.Data,
        top500.pons.Data)


# create a list with these data frames to be used when the same operation is applied to all area
  
hold.Lowest.pvals <- list(pf=top500.prefront.Data,
                         cb=top500.cbell.Data,
                         tm=top500.tempor.Data,
                         po=top500.pons.Data)

     

################################################################################################

################# Unique by area strongly COMT correlated genes ######################


wbuniq <- loadWorkbook('unique_genes_full_data.xlsx')   

# now tell R to read that workbook and which sheet
  unique.prefront.Data <- data.frame(read.xlsx(wbuniq,sheet = "prefrontal"))
  
  unique.cbell.Data <- data.frame(read.xlsx(wbuniq,sheet = "cerebellum"))

  unique.tempor.Data <- data.frame(read.xlsx(wbuniq,sheet = "temporal"))

  unique.pons.Data <- data.frame(read.xlsx(wbuniq,sheet = "pons"))
  
  Store(unique.prefront.Data,
        unique.cbell.Data,
        unique.tempor.Data,
        unique.pons.Data)


# create a list with these data frames to be used when the same operation is applied to all area
  
unique.full.data.all <- list(pf=unique.prefront.Data,
                   cb=unique.cbell.Data,
                   tm=unique.tempor.Data,
                   po=unique.pons.Data)


# read in data that has only one probe per gene
wbgene <- loadWorkbook('gene_as_unit_data.xlsx')   

# now tell R to read that workbook and which sheet
  gene.prefront.Data <- data.frame(read.xlsx(wbgene,sheet = "prefrontal"))
  
  gene.cbell.Data <- data.frame(read.xlsx(wbgene,sheet = "cerebellum"))

  gene.tempor.Data <- data.frame(read.xlsx(wbgene,sheet = "temporal"))

  gene.pons.Data <- data.frame(read.xlsx(wbgene,sheet = "pons"))
  
  # reorder data in each area by pval
  
  gene.prefront.Data <- gene.prefront.Data[order(gene.prefront.Data$Sample.p.r.,decreasing=FALSE), ]
  gene.cbell.Data <- gene.cbell.Data[order(gene.cbell.Data$Sample.p.r.,decreasing=FALSE), ]
  gene.tempor.Data <- gene.tempor.Data[order(gene.tempor.Data$Sample.p.r.,decreasing=FALSE), ]
  gene.pons.Data <- gene.pons.Data[order(gene.pons.Data$Sample.p.r.,decreasing=FALSE), ]
  
  Store(gene.prefront.Data,
        gene.cbell.Data,
        gene.tempor.Data,
        gene.pons.Data)


# create a list with these data frames to be used when the same operation is applied to all area
  
gene.Major <- list(pf=gene.prefront.Data,
                   cb=gene.cbell.Data,
                   tm=gene.tempor.Data,
                   po=gene.pons.Data)


################# END Already processed data ####################### 

### Read in putative transcription factors based on motifRG analysis of positively vs. negatively correlated genes in Prefrontal Cortex



wbtf <- loadWorkbook('tfs_pf_motifRG.xlsx')   

# now tell R to read that workbook and which sheet
  tfs.PvN.pf <- data.frame(read.xlsx(wbtf,sheet = "hs_only"))


@  

<<table.top.500>>=
# for completeness, write out a pdf document with tables showing the top 500 genes in each area

hold.lowest.w.Symbcorsign <- hold.Lowest.pvals

for (im in ib)   {
for (ik in 1:length(hold.Lowest.pvals[[1]]$Symbol))  {
     
     if (hold.lowest.w.Symbcorsign[[im]]$corsign[ik] == '-1')  {
          
          hold.lowest.w.Symbcorsign[[im]]$Symbol[ik] <- paste('{\bfseries {',hold.lowest.w.Symbcorsign[[im]]$Symbol[ik],'}}',sep='')
     } else {
          
     }
     
}     
}



prefrontal.top500.tab <- xtable(vect2mat(hold.lowest.w.Symbcorsign[[1]]$Symbol,10),
                                caption=c('The 500 most strongly COMT-correlated genes (ranking on correlation p-value) in Prefrontal Cortex.'))

prefrontal.top500.ltx <- latex(prefrontal.top500.tab,file='top500temp_genes_tabled_by_area_pval_rank_final.tex',
                         caption = c('The 500 most strongly COMT-correlated genes (ranking on correlation p-value) in Prefrontal Cortex.'),
                         caption.loc = c('top'),
                         colheads = c(''),
                         rowlabel = c(''),
                         colnamesTexCmd="bfseries",
                         booktabs=TRUE,
                         label=c('tab:top500.pf'),
                         na.blank = TRUE,
                         vbar = FALSE,
                         longtable=TRUE,
                         table.env=TRUE,
                         center=c('center'),
                         continued=c('Top 500 Positively Correlated Genes in PF Crtx Continued'),
                         first.hline.double = FALSE,
                         append=FALSE
                     )

cerebellum.top500.tab <- xtable(vect2mat(hold.lowest.w.Symbcorsign[[2]]$Symbol,10),
                                caption=c('The 500 most strongly COMT-correlated genes (ranking on correlation p-value) in Cerebellum.'))

cerebellum.top500.ltx <- latex(cerebellum.top500.tab,file='top500temp_genes_tabled_by_area_pval_rank_final.tex',
                         caption = c('The 500 most strongly COMT-correlated genes (ranking on correlation p-value) in Cerebellum.'),
                         caption.loc = c('top'),
                         colheads = c(''),
                         rowlabel = c(''),
                         colnamesTexCmd="bfseries",
                         booktabs=TRUE,
                         label=c('tab:top500.pf'),
                         na.blank = TRUE,
                         vbar = FALSE,
                         longtable=TRUE,
                         table.env=TRUE,
                         center=c('center'),
                         continued=c('Top 500 Positively Correlated Genes in Crblm Continued'),
                         first.hline.double = FALSE,
                         append=TRUE
                     )

temporal.top500.tab <- xtable(vect2mat(hold.lowest.w.Symbcorsign[[3]]$Symbol,10),
                                caption=c('The 500 most strongly COMT-correlated genes (ranking on correlation p-value) in Temporal Cortex.'))

temporal.top500.ltx <- latex(temporal.top500.tab,file='top500temp_genes_tabled_by_area_pval_rank_final.tex',
                         caption = c('The 500 most strongly COMT-correlated genes (ranking on correlation p-value) in Temporal Cortex.'),
                         caption.loc = c('top'),
                         colheads = c(''),
                         rowlabel = c(''),
                         colnamesTexCmd="bfseries",
                         booktabs=TRUE,
                         label=c('tab:top500.pf'),
                         na.blank = TRUE,
                         vbar = FALSE,
                         longtable=TRUE,
                         table.env=TRUE,
                         center=c('center'),
                         continued=c('Top 500 Positively Correlated Genes in Temp Crtx Continued'),
                         first.hline.double = FALSE,
                         append=TRUE
                     )

pons.top500.tab <- xtable(vect2mat(hold.lowest.w.Symbcorsign[[4]]$Symbol,10),
                                caption=c('The 500 most strongly COMT-correlated genes (ranking on correlation p-value) in Pons.'))

pons.top500.ltx <- latex(pons.top500.tab,file='top500temp_genes_tabled_by_area_pval_rank_final.tex',
                         caption = c('The 500 most strongly COMT-correlated genes (ranking on correlation p-value) in Pons.'),
                         caption.loc = c('top'),
                         colheads = c(''),
                         rowlabel = c(''),
                         colnamesTexCmd="bfseries",
                         booktabs=TRUE,
                         label=c('tab:top500.pf'),
                         na.blank = TRUE,
                         vbar = FALSE,
                         longtable=TRUE,
                         table.env=TRUE,
                         center=c('center'),
                         continued=c('Top 500 Positively Correlated Genes in Pons Continued'),
                         first.hline.double = FALSE,
                         append=TRUE
                     )



@



  
<<gene.databases>>=
yy <- hgu95av2CHRLENGTHS
chrom.Data <- data.frame(chrom=chrom.Names,
                         chrom.Length=yy[chrom.Names]
)


### Note to convert r correlations into p values use these transformations
### store the results in a column in the original data frame - without the print statements
# example: r = 0.809, n = 138
# r.test(n = , r12 = )
# out.t <- r.test(n = 138, r12 = 0.809)
# print(out.t$t,digits=10)
# [1] 16.05025766
# pval <- 2*pt(-abs(t),df=n-2)
# pval <- 2*pt(-abs(print(out.t$t,digits=20)),df=136)
# print(pval,digits=10)

@


<<>>=
# Plot mean expression level per gene by brain area

stacked.area.Data <- rbind(major.Area[[1]],
                           major.Area[[2]],
                           major.Area[[3]],
                           major.Area[[4]])

labels.area.pf <- c(rep('prefrontal',dim(major.Area[[1]])[1]))
labels.area.cb <- c(rep('cerebellum',dim(major.Area[[2]])[1]))
labels.area.tm <- c(rep('temporal',dim(major.Area[[3]])[1]))
labels.area.po <- c(rep('pons',dim(major.Area[[4]])[1]))

labels.area <- cbind(t(labels.area.pf),
                     t(labels.area.cb),
                     t(labels.area.tm),
                     t(labels.area.po))

stacked.area.Data$brainArea <- t(labels.area)


rain.plot <- get.raincloud.Plot(stacked.area.Data)

rain.plot

ggsave('expression_distributions_by_area.pdf', plot = rain.plot, width = 8, height = 5.5)

@

<<pos_neg_corrs_unique_numbers>>=
# How many (what percentage) of the correlations in the full data (only one probe per gene) in each area are positive/negative?
# How many (what percentage) of the correlations among the top 500 in each area are positive/negative?
# How many (what percentage) of the correlations unique genes in each area are positive/negative?

pos.neg.corrs.nums <- data.frame(fullpos=rep(NA,4),
                                 full=rep(NA,4),
                                 top500pos=rep(NA,4),
                                 top500=rep(NA,4),
                                 uniquepos=rep(NA,4),
                                 unique=rep(NA,4))
# full data

pos.neg.corrs.nums[,1] <- sapply(area.List.byGene[ib], function(x,ib) sum(x$corsign == '1'), ib)
pos.neg.corrs.nums[,2] <- sapply(area.List.byGene[ib], function(x,ib) dim(x)[1], ib)
pos.neg.corrs.nums[,3] <- sapply(hold.Lowest.pvals[ib], function(x,ib) sum(x$corsign == '1'), ib)
pos.neg.corrs.nums[,4] <- sapply(hold.Lowest.pvals[ib], function(x,ib) dim(x)[1], ib)
pos.neg.corrs.nums[,5] <- sapply(unique.full.data.all[ib], function(x,ib) sum(x$corsign == '1'), ib)
pos.neg.corrs.nums[,6] <- sapply(unique.full.data.all[ib], function(x,ib) dim(x)[1], ib)

### Write out this table and use the hypergeomatric distribution to test for deviations from expected

row.names(pos.neg.corrs.nums) <- stand.Col.names

pos.neg.corrs.nums.tab <- xtable(pos.neg.corrs.nums,
                                 caption=c('Number of positively COMT-correlated genes in the full sample (gene as unit of analysis) (Column 1), in the 500 most strongly correlated (ranked by p-values) (Column 3), and in the genes among the top 500 only found in the corresponding brain area but not among the top 500 genes in any of the other three areas (Column 5).'))

pos.neg.corrs.nums.ltx <- latex(pos.neg.corrs.nums.tab,file='',
                         caption = c('Number of positively COMT-correlated genes in the full sample (gene as unit of analysis) (Column 1), in the 500 most strongly correlated (ranked by p-values) (Column 3), and in the genes among the top 500 only found in the corresponding brain area but not among the top 500 genes in any of the other three areas (Column 5).'),
                         caption.loc = c('top'),
                         colheads = c('Pos. r full sample',
                                     'Full Sample',
                                     'Pos. r top 500 genes',
                                     'Top 500 genes',
                                     'Pos. r unique',
                                     'Unique genes'),
                         rowlabel = c(''),
                         colnamesTexCmd="bfseries",
                         booktabs=TRUE,
                         label=c('tab:num.pos.genes'),
                         na.blank = TRUE,
                         vbar = FALSE,
                         longtable=TRUE,
                         table.env=TRUE,
                         center=c('center'),
                         continued=c('Numbers of Positively Correlated Genes Continued'),
                         first.hline.double = FALSE,
                         append=FALSE
                     )


@

<<hypergeom.tests >>=

pos.neg.percent <- data.frame(fullpos=rep(NA,4),
                              top500pos=rep(NA,4),
                              uniquepos=rep(NA,4)
                              )

pos.neg.percent[,1] <- pos.neg.corrs.nums[,1]/pos.neg.corrs.nums[,2]
pos.neg.percent[,2] <- pos.neg.corrs.nums[,3]/pos.neg.corrs.nums[,4]
pos.neg.percent[,3] <- pos.neg.corrs.nums[,5]/pos.neg.corrs.nums[,6]

#   fullpos top500pos uniquepos
# 1 0.37966   0.65868   0.37688
# 2 0.36907   0.76248   0.61017
# 3 0.34630   0.81238   0.71292
# 4 0.39721   0.86427   0.80851



#  pos.neg.corrs.nums
#            fullpos  full top500pos top500 uniquepos unique
# Prefrontal    6329 16670       330    501        75    199
# Cerebellum    6158 16685       382    501       144    236
# Temporal      5761 16636       407    501       149    209
# Pons          6600 16616       433    501       190    235

# top 500 pos against full sample

hypergeom.Tests <- data.frame(top500=rep(NA,4),
                              unique=rep(NA,4))
for (im in ib)   {

hypergeom.Tests[im,1] <- formatC(phyper(pos.neg.corrs.nums$top500pos[im],
                              pos.neg.corrs.nums$fullpos[im],
                              (pos.neg.corrs.nums$full[im] - pos.neg.corrs.nums$fullpos[im]),
                              pos.neg.corrs.nums$top500[im],
                              lower.tail=FALSE,
                              log.p=FALSE
                              ),format = "e", digits = 2)

hypergeom.Tests[im,2] <- formatC(phyper(pos.neg.corrs.nums$uniquepos[im],
                              pos.neg.corrs.nums$fullpos[im],
                              (pos.neg.corrs.nums$full[im] - pos.neg.corrs.nums$fullpos[im]),
                              pos.neg.corrs.nums$unique[im],
                              lower.tail=FALSE,
                              log.p=FALSE
                              ),format = "e", digits = 2)

}

row.names(hypergeom.Tests) <- stand.Col.names

hypergeom.Tests.tab <- xtable(hypergeom.Tests,
                              caption=c('Hypergeomtric test probabilities - Column 1: Number of positive correlations in the 500 most strongly correlated genes compared to the number expected given the proportion of positive correlations in the full sample of genes. Column 2: Number of positive correlations in the genes unique to each brain area (within the top 500 most strongly COMT-correlated genes) compared to the number of positive correlations expected given the proportion of positive correlations in the full sample of genes.'))

hypergeom.Tests.ltx <- latex(hypergeom.Tests.tab,file='',
                         caption = c('Hypergeomtric test probabilities - Column 1: Number of positive correlations in the 500 most strongly correlated genes compared to the number expected given the proportion of positive correlations in the full sample of genes. Column 2: Number of positive correlations in the genes unique to each brain area (within the top 500 most strongly COMT-correlated genes) compared to the number of positive correlations expected given the proportion of positive correlations in the full sample of genes.'),
                         caption.loc = c('top'),
                         colheads = c('Pos. r in top 500 genes',
                                     'Pos. r in genes unique to each area'
                                     ),
                         rowlabel = c(''),
                         colnamesTexCmd="bfseries",
                         booktabs=TRUE,
                         label=c('tab:hypergeometric'),
                         na.blank = TRUE,
                         vbar = FALSE,
                         longtable=TRUE,
                         table.env=TRUE,
                         center=c('center'),
                         continued=c('Hypergeometric Tests Continued'),
                         first.hline.double = FALSE,
                         append=FALSE
                     ) 


@



The data show that\\
\begin{enumerate}
     \item In the full sample with gene as the unit of analysis, there are approximately twice as many genes whose expression is negatively correlated with {\textit {COMT}} expression as positively correlated genes. This holds independently of brain area. The same is true if probe is used as the unit of analysis instead of gene.
     \item In contrast, among the 500 most strongly {\textit {COMT}}-correlated genes in each brain area, there are approximately twice as many positively correlated as negatively correlated genes: a complete reversal of the proportions in the full sample.
     \item Consider the genes among the top 500 in each brain area that are unique to a given brain area in that list; that is, they are among the 500 most strongly correlated genes in a particular area, but they are only found among the top 500 in that brain area and not among the top 500 in any of the other three brain areas.
     \begin{itemize}
          \item In Cerebellum, Temporal Cortex and Pons, the proportion of positively correlated genes among these unique sets is similar to what it was in the full set of the 500 top genes in that area. Thast is, there are about twice as many positively corrleated as negatively correlated genes.
          \item In Prefrontal Cortex, however, this proportion flips so that there are approximately twice as many negatively correlated genes as positively correlated genes. This is the same proportion that existed in the full set of data rather than in the top 500. 
     \end{itemize}
\end{enumerate}

So the two remarkable aspects of this analysis are 1) that there are twice as many negatively {\textit {COMT}}-correlated genes as positively correlated genes, but this proportion flips in the 500 most strongly (ranked by p-value) correlated genes in each area, and 2) this 2:1 positive:negative ratio also holds among the uniquely expressed genes in a given area in all areas except Prefrontal Cortex where the proportion reverses to 1:2 as it was in the full sample of data.









<<include=FALSE, echo=FALSE, results=tex >>=

####################### Get promoter sequences; write out in FASTA format

# get -1000 (upstream) to +600 (downstream) promoter sequences of top 500 correlated genes
# The returned sequence is in the 5' to 3' direction. The start position in measuring
# upstream and downstream is the transcription start site of the gene (TSS).

 entrez.list <- list(pf=rep(NA,(length(hold.Lowest.pvals[[1]]$ENTREZID)+1)),
                     cb=rep(NA,(length(hold.Lowest.pvals[[2]]$ENTREZID)+1)),
                     tm=rep(NA,(length(hold.Lowest.pvals[[3]]$ENTREZID)+1)),
                     po=rep(NA,(length(hold.Lowest.pvals[[4]]$ENTREZID)+1)))
 
     entrez.list <- lapply(hold.Lowest.pvals[ib], function(x,ib) c(x$ENTREZID,NA), ib)
# add COMT-MB to list as first entry
     entrez.list <- lapply(entrez.list[ib], function(x,ib) c(1312,x[c(1:(length(x) - 1))]),ib)

fasta_files <- c('fasta_500_promoter_seq_pf_final.txt',
                 'fasta_500_promoter_seq_cb_final.txt',
                 'fasta_500_promoter_seq_tm_final.txt',
                 'fasta_500_promoter_seq_po_final.txt')

area.abbrv <- c('pf',
     'cb',
     'tm',
     'po'
)

# 

# promoterUp <- list()
# promoterDown <- list()

promoter.Seq <- list(up=rep(NA,4),
                     down=rep(NA,4))

promoter.Seq <- list()


for (im in ib)    {

promoter.Seq$up[[im]] <-  biomaRt::getSequence(id = entrez.list[[im]],
                                        type="entrezgene",
                                        seqType="coding_gene_flank",
                                        upstream=1000,
                                        mart=ensembl)

promoter.Seq$down[[im]] <-  biomaRt::getSequence(id = entrez.list[[im]],
                                        type="entrezgene",
                                        seqType="coding_gene_flank",
                                        downstream=600,
                                        mart=ensembl)

}

# promoter.847.1000 <-  biomaRt::getSequence(id = '847',
#                                         type="entrezgene",
#                                         seqType="coding_gene_flank",
#                                         upstream=1000,
#                                         mart=ensembl)







# ### Positive
# promoterUp <- getSequence(id = entrez,
#             type="entrezgene",
#             seqType="coding_gene_flank",
#             upstream=1000,
#             mart=ensembl)
# 
# promoterDown <- getSequence(id = entrez,
#             type="entrezgene",
#             seqType="coding_gene_flank",
#             downstream=600,
#             mart=ensembl)

match.E <- list()
match.corsign.indx <- list()

for (im in ib)  {

     match.E$up[[im]] <- match(entrez.list[[im]],promoter.Seq$up[[im]]$entrezgene)
     match.E$down[[im]] <- match(entrez.list[[im]],promoter.Seq$down[[im]]$entrezgene)
     temp.ENTREZ <- 
     match.corsign.indx[[im]] <- match(entrez.list[[im]],hold.Lowest.pvals[[im]]$ENTREZID)

}



# missing.Prom.entrez <- list(up=rep(NA,4),
#                             down=rep(NA,4))
# 
# missing.Prom.entrez$up <- lapply(match.E$up[ib], function(x,ib) which(is.na(x)), ib)
# missing.Prom.entrez$down <- lapply(match.E$down[ib], function(x,ib) which(is.na(x)), ib)




promoter.Full <- list()
promoter.entrez.lst <- list()


for (im in ib)   {

     promoter.Full$prom.Seq[[im]] <- noquote(as.character(paste(promoter.Seq$up[[im]]$coding_gene_flank[na.omit(c(match.E$up[[im]]))],promoter.Seq$down[[im]]$coding_gene_flank[na.omit(c(match.E$down[[im]]))],sep='')))
     promoter.Full$entrezgene[[im]] <- as.character(promoter.Seq$up[[im]]$entrezgene[na.omit(c(match.E$up[[im]]))])
    
     promoter.entrez.lst[[im]] <- as.character(promoter.Seq$up[[im]]$entrezgene[na.omit(c(match.E$up[[im]]))])

}

############## Begin one-off ########################
## the upstream 1000 bp sequence for entrezgene 3105 for the first transcript returned is blank resulting in 1000 Ns for the first 1000 bases. Instead, the 3rd transcript both up and down can be used because it has both parts of the sequence. It is held in promoter.Seq$up[[1]]$coding_gene_flank[153] and promoter.Seq$down[[1]]$coding_gene_flank[153]

## This shows up in promoter.Full$prom.Seq[[1]][225]

promoter.Full$prom.Seq[[1]][225] <- noquote(as.character(paste(promoter.Seq$up[[1]]$coding_gene_flank[153],promoter.Seq$down[[1]]$coding_gene_flank[153],sep='')))

# This is also true in the temporal data set for this same gene at index: 476

promoter.Full$prom.Seq[[3]][476] <- promoter.Full$prom.Seq[[1]][224]

# The same is true for entrezgene 780 in the temporal data set but it is the down stream part that is missing. this is for seq.pos.fasta[[3]][[117]] and the third transcript for 780 has complete sequence information:

promoter.Full$prom.Seq[[3]][120] <- noquote(as.character(paste(promoter.Seq$up[[3]]$coding_gene_flank[36],promoter.Seq$down[[3]]$coding_gene_flank[36],sep='')))

############## End one-off ########################


# match the entrezgene ids of the surviving fasta sxequences against the ENTREZIDs of the top 500 genes in order to extract the corsign to add to the fasta id for each sequence.

# The purpose of this is to be able to test for differences in motif composition between positively and negatively COMT-correlated genes.

match.entrez500.indx <- list()
for (im in ib)   {
     
     match.entrez500.indx[[im]] <- match(promoter.entrez.lst[[im]],hold.Lowest.pvals[[im]]$ENTREZID)

}

# compose fasta id line to be added before each fasta sequence

promoter.Full$corsign <- list()
promoter.Full$Symbol <- list()
promoter.Full$header <- list()
promoter.Full$Sample.r <- list()

promoter.Full$corsign[[1]] <- hold.Lowest.pvals[[1]]$corsign[na.omit(c(match.entrez500.indx[[1]]))]
promoter.Full$Symbol[[1]] <- hold.Lowest.pvals[[1]]$Symbol[na.omit(c(match.entrez500.indx[[1]]))]
promoter.Full$header[[1]] <- hold.Lowest.pvals[[1]]$ENTREZID[na.omit(c(match.entrez500.indx[[1]]))]
promoter.Full$Sample.r[[1]] <- hold.Lowest.pvals[[1]]$Sample.r[na.omit(c(match.entrez500.indx[[1]]))]


promoter.Full$corsign[[2]] <- hold.Lowest.pvals[[2]]$corsign[na.omit(c(match.entrez500.indx[[2]]))]
promoter.Full$Symbol[[2]] <- hold.Lowest.pvals[[2]]$Symbol[na.omit(c(match.entrez500.indx[[2]]))]
promoter.Full$header[[2]] <- hold.Lowest.pvals[[2]]$ENTREZID[na.omit(c(match.entrez500.indx[[2]]))]
promoter.Full$Sample.r[[2]] <- hold.Lowest.pvals[[2]]$Sample.r[na.omit(c(match.entrez500.indx[[2]]))]

promoter.Full$corsign[[3]] <- hold.Lowest.pvals[[3]]$corsign[na.omit(c(match.entrez500.indx[[3]]))]
promoter.Full$Symbol[[3]] <- hold.Lowest.pvals[[3]]$Symbol[na.omit(c(match.entrez500.indx[[3]]))]
promoter.Full$header[[3]] <- hold.Lowest.pvals[[3]]$ENTREZID[na.omit(c(match.entrez500.indx[[3]]))]
promoter.Full$Sample.r[[3]] <- hold.Lowest.pvals[[3]]$Sample.r[na.omit(c(match.entrez500.indx[[3]]))]


promoter.Full$corsign[[4]] <- hold.Lowest.pvals[[4]]$corsign[na.omit(c(match.entrez500.indx[[4]]))]
promoter.Full$Symbol[[4]] <- hold.Lowest.pvals[[4]]$Symbol[na.omit(c(match.entrez500.indx[[4]]))]
promoter.Full$header[[4]] <- hold.Lowest.pvals[[4]]$ENTREZID[na.omit(c(match.entrez500.indx[[4]]))]
promoter.Full$Sample.r[[4]] <- hold.Lowest.pvals[[4]]$Sample.r[na.omit(c(match.entrez500.indx[[4]]))]




for (im in ib)   {
     
     
     for (kl in 1:(length(promoter.entrez.lst[[im]]))) {
          
          
#          if (hold.Lowest.pvals[[1]]$corsign[na.omit(c(match.entrez500.indx[[1]]))] == 1)  {
if (promoter.Full$corsign[[im]][kl] == 1)  {
               write.sign <- c('_+1')
          } else {
               write.sign <- c('_-1')
          }
          
          promoter.Full$header[[im]][kl] <- paste(write.sign,'_id_',
                                                      promoter.Full$header[[im]][kl],
                                                      '_',area.abbrv[im],sep='')
          
          
     }

}

# which index holds the duplicated COMT fasta sequence?
dup.COMT.entrez <- c(as.integer(lapply(promoter.Full$header[ib], function(x,ib) which(duplicated(x)), ib)))

# remove the fasta entry for the soluable form of COMT because the promoter sequence is identical to the sequence for the membrane-bound form.

# skip over the duplicated fasta sequence
# need to do this both for the id part and the actual sequence part
# DO NOT RUN THIS MORE THAN ONCE - or it will eliminate additional entries
# remove.fasta.dup checks to see if it has already been run

if (length(which(!is.na(dup.COMT.entrez))) > 0) {
     remove.fasta.dup = FALSE    # if there are nonNA entries then they have not been removed
} else {
     remove.fasta.dup = TRUE # if there are NO nonNA entries then they have been removed
}
     
if (!remove.fasta.dup) {
     
     for (im in ib)   {
           promoter.Full$entrezgene[[im]] <- promoter.Full$entrezgene[[im]][c(1:(dup.COMT.entrez[im] - 1),(dup.COMT.entrez[im] + 1):length(promoter.Full$entrezgene[[im]]))]
           promoter.Full$prom.Seq[[im]] <- promoter.Full$prom.Seq[[im]][c(1:(dup.COMT.entrez[im] - 1),(dup.COMT.entrez[im] + 1):length(promoter.Full$prom.Seq[[im]]))]
          # 
           promoter.entrez.lst[[im]] <- promoter.entrez.lst[[im]][c(1:(dup.COMT.entrez[im] - 1),(dup.COMT.entrez[im] + 1):length(promoter.entrez.lst[[im]]))]
          
            promoter.Full$corsign[[im]] <- promoter.Full$corsign[[im]][c(1:(dup.COMT.entrez[im] - 1),(dup.COMT.entrez[im] + 1):length(promoter.Full$corsign[[im]]))]
          # # 
            promoter.Full$Symbol[[im]] <- promoter.Full$Symbol[[im]][c(1:(dup.COMT.entrez[im] - 1),(dup.COMT.entrez[im] + 1):length(promoter.Full$Symbol[[im]]))]
          # # 
            promoter.Full$header[[im]] <- promoter.Full$header[[im]][c(1:(dup.COMT.entrez[im] - 1),(dup.COMT.entrez[im] + 1):length(promoter.Full$header[[im]]))]
            promoter.Full$Sample.r[[im]] <- promoter.Full$Sample.r[[im]][c(1:(dup.COMT.entrez[im] - 1),(dup.COMT.entrez[im] + 1):length(promoter.Full$Sample.r[[im]]))]
          

     }
     remove.fasta.dup <- TRUE
     dup.COMT.entrez <- c(rep(NA,4))
} else {
     
}



# write out promoter sequences in fasta format
write.fasta(sequences=str_split(promoter.Full$prom.Seq[[1]],''),names=promoter.Full$header[[1]],file.out='fasta_500_promoter_seq_pf_final.txt',nbchar=1600)

write.fasta(sequences=str_split(promoter.Full$prom.Seq[[2]],''),names=promoter.Full$header[[2]],file.out='fasta_500_promoter_seq_cb_final.txt',nbchar=1600)

write.fasta(sequences=str_split(promoter.Full$prom.Seq[[3]],''),names=promoter.Full$header[[3]],file.out='fasta_500_promoter_seq_tm_final.txt',nbchar=1600)

write.fasta(sequences=str_split(promoter.Full$prom.Seq[[4]],''),names=promoter.Full$header[[4]],file.out='fasta_500_promoter_seq_po_final.txt',nbchar=1600)


# write out positively and negatively correlated separately

fasta.500.pos <- list()
fasta.500.neg <- list()

for (im in ib) {
     fasta.500.pos$indx[[im]] <- which(promoter.Full$corsign[[im]] == 1)
     fasta.500.neg$indx[[im]] <- which(promoter.Full$corsign[[im]] == -1)
     
     fasta.500.pos$seq[[im]] <- promoter.Full$prom.Seq[[im]][unlist(fasta.500.pos$indx[[im]])]
     fasta.500.neg$seq[[im]] <- promoter.Full$prom.Seq[[im]][unlist(fasta.500.neg$indx[[im]])]

     fasta.500.pos$header[[im]] <- promoter.Full$header[[im]][unlist(fasta.500.pos$indx[[im]])]
     fasta.500.neg$header[[im]] <- promoter.Full$header[[im]][unlist(fasta.500.neg$indx[[im]])]
     
     fasta.500.pos$header[[im]] <- paste('>',fasta.500.pos$header[[im]],sep='')
     fasta.500.neg$header[[im]] <- paste('>',fasta.500.neg$header[[im]],sep='')

     }               
# write out pos/neg fasta separately
write.fasta(sequences=str_split(fasta.500.pos$seq[[1]],''),names=fasta.500.pos$header[[1]],file.out='fasta_500_promoter_seq_pf_pos.fa',nbchar=1600)
write.fasta(sequences=str_split(fasta.500.neg$seq[[1]],''),names=fasta.500.neg$header[[1]],file.out='fasta_500_promoter_seq_pf_neg.fa',nbchar=1600)

write.fasta(sequences=str_split(fasta.500.pos$seq[[2]],''),names=fasta.500.pos$header[[2]],file.out='fasta_500_promoter_seq_cb_pos.fa',nbchar=1600)
write.fasta(sequences=str_split(fasta.500.neg$seq[[2]],''),names=fasta.500.neg$header[[2]],file.out='fasta_500_promoter_seq_cb_neg.fa',nbchar=1600)

write.fasta(sequences=str_split(fasta.500.pos$seq[[3]],''),names=fasta.500.pos$header[[3]],file.out='fasta_500_promoter_seq_tm_pos.fa',nbchar=1600)
write.fasta(sequences=str_split(fasta.500.neg$seq[[3]],''),names=fasta.500.neg$header[[3]],file.out='fasta_500_promoter_seq_tm_neg.fa',nbchar=1600)

write.fasta(sequences=str_split(fasta.500.pos$seq[[4]],''),names=fasta.500.pos$header[[4]],file.out='fasta_500_promoter_seq_po_pos.fa',nbchar=1600)
write.fasta(sequences=str_split(fasta.500.neg$seq[[4]],''),names=fasta.500.neg$header[[4]],file.out='fasta_500_promoter_seq_po_neg.fa',nbchar=1600)


############## END get promoter sequences and writing out FASTA formatted files

# test read.fasta
seq.fasta <- list()
seq.fasta.entrez <- list()

seq.pos.fasta <- list()
seq.pos.fasta.entrez <- list()

seq.neg.fasta <- list()
seq.neg.fasta.entrez <- list()


for (im in ib)   {

seq.fasta[[im]] <- read.fasta(file=paste('fasta_500_promoter_seq_',area.abbrv[im],
                                         '_final.txt',sep=''),seqtype='DNA',
                            forceDNAtolower=FALSE,seqonly=TRUE,strip.desc=FALSE,
                            as.string=TRUE)

seq.fasta.entrez[[im]] <- read.fasta(file=paste('fasta_500_promoter_seq_',area.abbrv[im],
                                         '_final.txt',sep=''),seqtype='DNA',
                            forceDNAtolower=FALSE,seqonly=FALSE,strip.desc=FALSE,
                            as.string=TRUE)


seq.pos.fasta[[im]] <- read.fasta(file=paste('fasta_500_promoter_seq_',area.abbrv[im],
                                         '_pos.fa',sep=''),seqtype='DNA',
                            forceDNAtolower=FALSE,seqonly=TRUE,strip.desc=FALSE,
                            as.string=TRUE)

seq.pos.fasta.entrez[[im]] <- read.fasta(file=paste('fasta_500_promoter_seq_',area.abbrv[im],
                                         '_pos.fa',sep=''),seqtype='DNA',
                            forceDNAtolower=FALSE,seqonly=FALSE,strip.desc=FALSE,
                            as.string=TRUE)


seq.neg.fasta[[im]] <- read.fasta(file=paste('fasta_500_promoter_seq_',area.abbrv[im],
                                         '_neg.fa',sep=''),seqtype='DNA',
                            forceDNAtolower=FALSE,seqonly=TRUE,strip.desc=FALSE,
                            as.string=TRUE)

seq.neg.fasta.entrez[[im]] <- read.fasta(file=paste('fasta_500_promoter_seq_',area.abbrv[im],
                                         '_neg.fa',sep=''),seqtype='DNA',
                            forceDNAtolower=FALSE,seqonly=FALSE,strip.desc=FALSE,
                            as.string=TRUE)
}

@

<<mutual.info>>=

fasta.by.lett <- list(pf=matrix(rep(NA,nchar(seq.fasta[[1]][1])*length(seq.fasta[[1]])),ncol=nchar(seq.fasta[[1]][1])),
                      cb=matrix(rep(NA,nchar(seq.fasta[[2]][1])*length(seq.fasta[[2]])),ncol=nchar(seq.fasta[[2]][1])),
                      tm=matrix(rep(NA,nchar(seq.fasta[[3]][1])*length(seq.fasta[[3]])),ncol=nchar(seq.fasta[[3]][1])),
                      po=matrix(rep(NA,nchar(seq.fasta[[4]][1])*length(seq.fasta[[4]])),ncol=nchar(seq.fasta[[4]][1]))
)

for (im in ib)    {
     
#     hold.fasta[[]] <- strsplit(unlist(seq.fasta[[1]]),NULL)

     for (jh in 1:length(seq.fasta[[im]]))   {
     
          fasta.by.lett[[im]][jh] <- strsplit(unlist(seq.fasta[[im]])[jh],NULL)

     }

}

fasta.by.lett.pos <- list(pf=matrix(rep(NA,nchar(seq.pos.fasta[[1]][1])*length(seq.pos.fasta[[1]])),ncol=nchar(seq.pos.fasta[[1]][1])),
                      cb=matrix(rep(NA,nchar(seq.pos.fasta[[2]][1])*length(seq.pos.fasta[[2]])),ncol=nchar(seq.pos.fasta[[2]][1])),
                      tm=matrix(rep(NA,nchar(seq.pos.fasta[[3]][1])*length(seq.pos.fasta[[3]])),ncol=nchar(seq.pos.fasta[[3]][1])),
                      po=matrix(rep(NA,nchar(seq.pos.fasta[[4]][1])*length(seq.pos.fasta[[4]])),ncol=nchar(seq.pos.fasta[[4]][1]))
)

pos.lett.freq <- list(pf=matrix(rep(0,length(seq.pos.fasta[[1]])*4),ncol=4),
                      cb=matrix(rep(0,length(seq.pos.fasta[[2]])*4),ncol=4),
                      tm=matrix(rep(0,length(seq.pos.fasta[[3]])*4),ncol=4),
                      po=matrix(rep(0,length(seq.pos.fasta[[4]])*4),ncol=4)
                      
)

for (im in ib)    {
     
#     hold.fasta[[]] <- strsplit(unlist(seq.fasta[[1]]),NULL)
     lett.tab <- matrix(rep(0,length(seq.pos.fasta[[im]])*4),ncol=4)

     for (jh in 1:length(seq.pos.fasta[[im]]))   {
     
          fasta.by.lett.pos[[im]][jh] <- strsplit(unlist(seq.pos.fasta[[im]])[jh],NULL)

          lett.tab[jh,1:4] <- table(fasta.by.lett.pos[[im]][jh])
          
     }
          pos.lett.freq[[im]] <- lett.tab
}


#### negatively correlated genes
fasta.by.lett.neg <- list(pf=matrix(rep(NA,nchar(seq.neg.fasta[[1]][1])*length(seq.neg.fasta[[1]])),ncol=nchar(seq.neg.fasta[[1]][1])),
                      cb=matrix(rep(NA,nchar(seq.neg.fasta[[2]][1])*length(seq.neg.fasta[[2]])),ncol=nchar(seq.neg.fasta[[2]][1])),
                      tm=matrix(rep(NA,nchar(seq.neg.fasta[[3]][1])*length(seq.neg.fasta[[3]])),ncol=nchar(seq.neg.fasta[[3]][1])),
                      po=matrix(rep(NA,nchar(seq.neg.fasta[[4]][1])*length(seq.neg.fasta[[4]])),ncol=nchar(seq.neg.fasta[[4]][1]))
)

neg.lett.freq <- list(pf=matrix(rep(0,length(seq.neg.fasta[[1]])*4),ncol=4),
                      cb=matrix(rep(0,length(seq.neg.fasta[[2]])*4),ncol=4),
                      tm=matrix(rep(0,length(seq.neg.fasta[[3]])*4),ncol=4),
                      po=matrix(rep(0,length(seq.neg.fasta[[4]])*4),ncol=4)
                      
)

for (im in ib)    {
     
#     hold.fasta[[]] <- strsplit(unlist(seq.fasta[[1]]),NULL)
     lett.tab <- matrix(rep(0,length(seq.neg.fasta[[im]])*4),ncol=4)

     for (jh in 1:length(seq.neg.fasta[[im]]))   {
     
          fasta.by.lett.neg[[im]][jh] <- strsplit(unlist(seq.neg.fasta[[im]])[jh],NULL)

          lett.tab[jh,1:4] <- table(fasta.by.lett.neg[[im]][jh])
          
     }
          neg.lett.freq[[im]] <- lett.tab
}


# mutual information
#fasta.MI <- MolecularMI(fasta.by.lett,'DNA')

@

<<chisq.signs.500>>=

top500.signs <- lapply(promoter.Full$corsign[ib], function(x,ib) table(unlist(x)), ib)

long.top500.signs <- c(promoter.Full$corsign[[1]],
                       promoter.Full$corsign[[2]],
                       promoter.Full$corsign[[3]],
                       promoter.Full$corsign[[4]])

long.top500.signs.df <- data.frame(signs=long.top500.signs,
                                   areas=c(rep('pf',length(promoter.Full$corsign[[1]])),
                                           rep('cb',length(promoter.Full$corsign[[2]])),
                                           rep('tm',length(promoter.Full$corsign[[3]])),
                                           rep('po',length(promoter.Full$corsign[[4]]))
                                           ))
# This produces a contingency table of brain area x sign for the ~ top 500 COMT-correlated genes
top500.signs.tab <- table(long.top500.signs.df)

top500.signs.Percent.tab <- matrix(rep(0,length(area.abbrv)*2),ncol=4)
                                       

for (im in ib)  {
     for (sg in 1:2)  {
          top500.signs.Percent.tab[sg,im] <- round(top500.signs.tab[sg,im]/sum(top500.signs.tab[,im]),3)
     
     }  
}
colnames(top500.signs.Percent.tab) <- stand.Col.names
row.names(top500.signs.Percent.tab) <- c('-1','+1')

top500.signs.Percent.tab

chisq.area.by.sign <- chisq.test(top500.signs.tab) 

@

The results of the chi-square test of independence says that brain area and COMT-correlation signs are {\bfseries {not independent}}. The proportion of negatively COMT-correlated genes differs by brain areas with prefrontal and cereballum having the most negatively correlated genes and temporal and pons having the fewest.\\

<<chisq.signs.by.chrom>>=

map.Chrname.Chrnum <- data.frame(chrname = as.character(c(1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,                                             2, 20, 21, 22,  3,  4,  5,  6,  7, 8,  9,  'X', 'Y' )),
                                 chrnum = as.character(c(seq(1:22),'X','Y')))

chrname2num <- match(map.Chrname.Chrnum$chrnum,map.Chrname.Chrnum$chrname)

lowest.pvals.corsignXchrom <- as.data.table(table(hold.Lowest.pvals[[1]]$corsign,hold.Lowest.pvals[[1]]$loc))

lowest.pvals.corsignXchrom$V2 <- as.integer(rep(chrname2num[1:23],each=2))

lowest.pvals.corsignXchrom <- lowest.pvals.corsignXchrom[order(lowest.pvals.corsignXchrom$V2),]

lowest.pvals.corsignXchrom$V2 <- rep(as.character(c(1:22,'X')),each=2)

lowest.pvals.corsignXchrom <- data.frame(matrix(as.matrix(lowest.pvals.corsignXchrom$N,nrow=2,ncol=23,byrow=TRUE),nrow=2))
     
colnames(lowest.pvals.corsignXchrom) <- map.Chrname.Chrnum$chrnum[1:23]

     
lowest.pvals.corsignXchrom$Total <- round(rowSums(lowest.pvals.corsignXchrom),0)

lowest.pvals.corsignXchrom[3,] <- lowest.pvals.corsignXchrom[1,]/colSums(lowest.pvals.corsignXchrom[1:2,])

row.names(lowest.pvals.corsignXchrom) <- c('negative','positive','prop. neg.')

top500.corsignXchr.tab <- xtable(lowest.pvals.corsignXchrom[1:3,],
                                 caption='Distribution of five hundred most strongly COMT-correlated genes (ranked by p-value) by sign of correlation and chromosome',
                                 digits=2)

chisq.test(lowest.pvals.corsignXchrom[1:2,1:23])


# test the binomial proportion of negative correlated genes on each chromosome against 171/500


prop.neg.Xchr <- list()
prop.neg <- rowSums(lowest.pvals.corsignXchrom[1,1:23])/sum(rowSums(lowest.pvals.corsignXchrom[1:2,1:23]))

for (hj in 1:23) {

     prop.neg.Xchr[[hj]] <- binom.test(lowest.pvals.corsignXchrom[1,hj],
                                       sum(lowest.pvals.corsignXchrom[1:2,hj]),
                                       p=prop.neg)
}

@

\vspace{1em}
Pearson's Chi-squared test\\

Chi-squared = 44.6$, df = 23, p-value = 0.0044\\

The most strongly positively and negatively COMT-correlated genes are distributed proportionately unequally across the 22 autosomes and the X chromosome. There are significantly (p = 0.00034) fewer negatively correlated than positively correlated genes on Chromosome 1 than would be expected from the overall proportion of negatively COMT-correlated genes across the 500 most strongly correlated genes. The COMT gene is located on Chromosome 22.\\

Testing the binomial proportion of negatively correlated genes on each chromosome against 171/500, the overall proportion of negatively correlated genes out of the top 500, with a Bonferroni-corrected p-value of 0.05/23 = .002. By this test, the proportions on Chromosomes 



<<motif.analysis>>=
# Record all of the motifs (sequences) of length, n, in the COMT promoter.
motifs.with.entrez <- list()
ml <- c(6)  # number of bases in a motif
txStart <- c(1000)
after.txStart <- c(600)

ic <- seq(-txStart,(after.txStart - ml),1)

 for (im in ib)  {
      
     temp.motif <- matrix(rep(NA,((nchar(seq.fasta[[im]][1])-(ml-1))*length(seq.fasta[[im]]))),
                              ncol=length(seq.fasta[[im]]))
     
 for (nf in 1:length(seq.fasta[[im]]))   {

                    temp.motif[,nf] <- get.motif(seq.fasta[[im]][nf],ml,ic,txStart)

          } #end nf loop

motifs.with.entrez[[im]] <- temp.motif

} # end brain area loop

# motifs.with.entrez[[1]][,1] are the motifs for COMT;  motifs.with.entrez[[1]][,2] are the motifs for the second most highly COMT-correlated gene in prefrontal cortex

# The percentages of the four bases in the human genome are:
# 
# %A      %G 	     %C 	     %T 
# 30.0	20.0	     20.0	     30.0


# The distance of each motif from the transcription start site is 1000 - (row number -1)

@

<<match.motifs>>=

# only written for prefrontal now


no.hits <- c()
comt.motif.starts <- seq(984,986-30*ml,-ml)


for (cs in 1:length(comt.motif.starts))  {

motif.match.COMT <- list()

motif.match <- list()
num.hits <- matrix(rep(0,(dim(motifs.with.entrez[[1]])[2] - 1)))

# loc.comt.motif <- c(comt.motif.starts[cs])
loc.comt.motif <- c(1082)

for (gh in 2:dim(motifs.with.entrez[[1]])[2])  {
     
     

#     for (jk in 1:dim(motifs.with.entrez[[1]])[1])  {
     for (jk in loc.comt.motif:loc.comt.motif)  {

          if (length(which(grepl(motifs.with.entrez[[1]][jk,1],motifs.with.entrez[[1]][,gh]))) > 0)  {
               
               motif.match[[(gh-1)]] <- which(grepl(motifs.with.entrez[[1]][jk,1],motifs.with.entrez[[1]][,gh]))
               
          } else {
               
               motif.match[[(gh-1)]] <- c(0)
               
          }
          
#          motif.match.COMT$symbol[[gh]] <- 
          
#          num.hits[(gh-1)] <- length(motif.match[[(gh-1)]])

}
          
}

for (hj in 1:length(motif.match))  {
     
     if (motif.match[[hj]] == 0)  {
          
          num.hits[(hj-1)] <- c(0)
          
     } else {
          
          num.hits[(hj-1)] <- length(motif.match[[hj]])
     }
}



#no.hits[cs] <- length(which(unlist(num.hits) == 0))
no.hits <- length(which(unlist(num.hits) == 0))

}

motif.match.COMT$loc <- motif.match
motif.match.COMT$Symbol <- promoter.Full$Symbol[[1]][2:length(promoter.Full$Symbol[[1]])]
motif.match.COMT$corsign <- promoter.Full$corsign[[1]][2:length(promoter.Full$corsign[[1]])]


for (ui in 1:length(motif.match.COMT$Symbol))  {
     
     cat(c(motif.match.COMT$corsign[[ui]],
           motif.match.COMT$Symbol[[ui]],
           motif.match.COMT$loc[[ui]]),
         file=c(paste('comt_motif_',motifs.with.entrez[[1]][loc.comt.motif,1],'_',
               (loc.comt.motif - txStart),'_bp_pf.txt',sep='')),
         sep=',',
         append=TRUE,
         fill=TRUE)
}


 
@

<<comt.promoter>>=

e2f3 <- "1312"

transcriptCoordsByGene.GRangesList <-
     transcriptsBy (TxDb.Hsapiens.UCSC.hg19.knownGene, by = "gene") [e2f3]

promoter.seqs <- getPromoterSeq (transcriptCoordsByGene.GRangesList[[1]][1],
                                   Hsapiens, upstream=1000, downstream=600)


@



<<dotplots>>=
 # Plot the locations of matching motifs to the chosen COMT motif

 
 comt.motif <- motifs.with.entrez[[1]][loc.comt.motif,1]
 comt.motif.loc <- data.frame(COMT.motif.loc = c(loc.comt.motif - txStart))
 
 match.locs <- data.frame(dist.from.txStart=(unlist(motif.match.COMT$loc) - 1000))
 
 nonzero.matches <- 
      
      match.locs %>%
      
          filter(dist.from.txStart > -1000)
      
          
motif.5 <-  ggplot(nonzero.matches, aes(x = dist.from.txStart)) +    # match.locs
      geom_dotplot(binwidth = 8,
                   method="dotdensity",
                   dotsize = 1.5,
                   color='gray40',
                   fill='gray40') + 
      geom_point(data=comt.motif.loc, aes(x=COMT.motif.loc, y=-0.075),
                 shape=c(24),
                 colour="blue",
                 fill=c('blue'),
                 size=c(2)
                 )                  +
     theme_minimal() +
      theme(axis.line.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.title.y=element_blank(),
          axis.title.x = element_text(margin = margin(t = 15, r = 0, b = 0, l = 0)),
          axis.text.x = element_text(margin = margin(t = 6, r = 0, b = 0, l = 0))
#          axis.ticks.length=unit(0.25, "cm")
          )    +
      labs(x = 'Distance (bp) from transcription start location')  +
      annotate("text", x = -5, y = 0.65, label = motifs.with.entrez[[1]][loc.comt.motif,1],
               size = 3)  +
      annotate("text", x = -800, y = 0.65, 
               label = "binwidth: 8 bp",
               size = 3,
               parse=FALSE)  + 
     annotate("text", x = -750, y = 0.9, 
               label = paste("italic(COMT)~motif~position==~",
                             comt.motif.loc$COMT.motif.loc,"~bp",sep=""),
               size = 3,
               parse=TRUE)  +
     annotate("text", x = 300, y = 0.9, 
               label = paste(as.character((length(motif.match) - no.hits)),' genes',sep=""),
               size = 3,
               parse=FALSE)  +
      coord_fixed(200)

motif.5

ggsave(paste("/Volumes/Macintosh_HD_3/genetics/genenetwork2/new_plots/comt_motif_CCCCTCCC_-16bp.pdf",sep=''),plot=motif.5,device="pdf",
       scale=2,
       dpi=300,
       width=6.0,
       height=3.0,
       units=c('in')
)
      
@

<<find.motifs>>=

### Prefrontal cortex ###

PF.motifs <- findMotifFasta("fasta_500_promoter_seq_pf_pos.fa","fasta_500_promoter_seq_pf_neg.fa",max.motif=3,
                    start.width=6,min.cutoff=5, min.ratio=1.3,
                    min.frac=0.01, both.strand=TRUE, flank=2,
                    mask=TRUE,other.data=NULL, start.nmer=NULL,
                    enriched.only=TRUE,n.bootstrap = 5, bootstrap.pvalue=0.1,is.parallel =
                    TRUE,mc.cores = 4,min.info=10,max.width=11,discretize=TRUE)

summaryMotif(PF.motifs$motifs,PF.motifs$category)

motifLatexTable(main="FG: positive COMT correlations, BG: negative COMT correlations, Prefrontal motifs", PF.motifs, prefix="posnegPF",plot.pwm= TRUE,summary.cols=c(1,7,8,9))

plotMotif(PF.motifs$motifs[[1]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE,
          main = 'Dinucleotide differential motif 1 \n for positively COMT-correlated versus \n negatively COMT-correlated genes in Prefrontal Cortex')
plotMotif(PF.motifs$motifs[[2]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE,
          main = 'Dinucleotide differential motif 2 \n for positively COMT-correlated versus \n negatively COMT-correlated genes in Prefrontal Cortex')
plotMotif(PF.motifs$motifs[[3]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE,
          main = 'Dinucleotide differential motif 3 \n for positively COMT-correlated versus \n negatively COMT-correlated genes in Prefrontal Cortex')

# Hypothesis: the mean number of hits for a given motif will be greater for the positively correlated genes than for the negatively correlated genes.
# Compare the mean number of motif hits in the positive vs. negative groups. Do this separately by motif, then combine all 3 motifs and do this with the sum.

motif.POSvNEG.t <- list()

# motif 1
motif.POSvNEG.t[[1]] <- t.test(slot(PF.motifs$motifs[[1]], "count")[1:323],slot(PF.motifs$motifs[[1]], "count")[324:491],alternative="two.sided")

# motif 2
motif.POSvNEG.t[[2]] <- t.test(slot(PF.motifs$motifs[[2]], "count")[1:323],slot(PF.motifs$motifs[[2]], "count")[324:491],alternative="two.sided")

# motif 3
motif.POSvNEG.t[[3]] <- t.test(slot(PF.motifs$motifs[[3]], "count")[1:323],slot(PF.motifs$motifs[[3]], "count")[324:491],alternative="two.sided")

# all motifs
sum.motif.hits.pos <- slot(PF.motifs$motifs[[1]], "count")[1:323] + slot(PF.motifs$motifs[[2]], "count")[1:323] + slot(PF.motifs$motifs[[3]], "count")[1:323]

sum.motif.hits.neg <- slot(PF.motifs$motifs[[1]], "count")[324:491] + slot(PF.motifs$motifs[[2]], "count")[324:491] + slot(PF.motifs$motifs[[3]], "count")[324:491]

motif.POSvNEG.t[[4]] <- t.test(sum.motif.hits.pos,sum.motif.hits.neg,alternative="two.sided")

# get descriptive on number of hits by corsign
motif.hits.pf <- data.frame()
motif.hits.pf <- data.frame(group = c(rep('pos',323),rep('neg',(491-323))),
                            motif1=slot(PF.motifs$motifs[[1]], "count"),
                            motif2=slot(PF.motifs$motifs[[2]], "count"),
                            motif3=slot(PF.motifs$motifs[[3]], "count")
                            )

motif.hits.pf$hitsAll <- motif.hits.pf$motif1 + motif.hits.pf$motif2 + motif.hits.pf$motif3

motif.hits.summary.pf <- describeBy(motif.hits.pf[,2:5],group=motif.hits.pf$group)

motif.hits.pf.tab <- tableContinuous(motif.hits.pf[,2:5], 
                                     weights = NA, 
                                     subset = NA, 
                                     group = motif.hits.pf$group, 
                                     stats = c("n", "min", "q1", "median", "mean", "s", "q3", "max", "iqr"), 
                                     prec = 1, col.tit = NA,
                                     col.tit.font = c("bf"),
                                     print.pval = c("anova"), 
                                     pval.bound = 10^-16,
                                     cap = "Descriptive statistics: Number of hits by motif in Prefrontal Cortex",
                                     lab = "", 
                                     font.size = "footnotesize", 
                                     longtable = TRUE, 
                                     disp.cols = NA, nams = NA)


position.by.motif.POSvNEG <- 
     
     as.integer(slot(PF.motifs$motifs[[1]], "match")[,3]) %>%
     
          filter(. <= 323)

               




### end Prefrontal ###


############## start pf vs. cb ###################

match.entrez.unique.pf <- match(unique.full.data.all$pf$ENTREZID,promoter.Full$entrezgene[[1]])
unique.promoter.seq.pf <- promoter.Full$prom.Seq[[1]][na.omit(match.entrez.unique.pf)]

match.entrez.unique.cb <- match(unique.full.data.all$cb$ENTREZID,promoter.Full$entrezgene[[2]])
unique.promoter.seq.cb <- promoter.Full$prom.Seq[[2]][na.omit(match.entrez.unique.cb)]

unique.promoter.seq.PFvCB <- c(unique.promoter.seq.pf,unique.promoter.seq.cb)
category <- c(rep(1,194),rep(0,233))

write.fasta(sequences=str_split(unique.promoter.seq.pf,''),
            names=promoter.Full$entrezgene[[1]][na.omit(match.entrez.unique.pf)],
            file.out='fasta_500_promoter_seq_pf_unique.fa',nbchar=1600)
write.fasta(sequences=str_split(unique.promoter.seq.cb,''),
            names=promoter.Full$entrezgene[[2]][na.omit(match.entrez.unique.cb)],
            file.out='fasta_500_promoter_seq_cb_unique.fa',nbchar=1600)


PFvCB.motifs <- findMotifFasta('fasta_500_promoter_seq_pf_unique.fa',
                               'fasta_500_promoter_seq_cb_unique.fa',
                               max.motif=3,enriched=T)

PFvCB.motifs

motifLatexTable(main="FG: positive pf COMT correlations, BG: positive cb COMT correlations, Prefrontal vs. Cerebellum motifs", PF.motifs, prefix="posPFvsCB")

plotMotif(PFvCB.motifs$motifs[[1]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)
plotMotif(PFvCB.motifs$motifs[[2]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)
plotMotif(PFvCB.motifs$motifs[[3]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)

############## end pf vs. cb ###################

############## start pf vs. tm #################
# try all pos but compare pf to tm

match.entrez.unique.pf <- match(unique.full.data.all$pf$ENTREZID,promoter.Full$entrezgene[[1]])
unique.promoter.seq.pf <- promoter.Full$prom.Seq[[1]][na.omit(match.entrez.unique.pf)]

match.entrez.unique.tm <- match(unique.full.data.all$tm$ENTREZID,promoter.Full$entrezgene[[3]])
unique.promoter.seq.tm <- promoter.Full$prom.Seq[[3]][na.omit(match.entrez.unique.tm)]

# write.fasta(sequences=str_split(unique.promoter.seq.pf,''),
#             names=promoter.Full$entrezgene[[1]][na.omit(match.entrez.unique.pf)],
#             file.out='fasta_500_promoter_seq_pf_unique.fa',nbchar=1600)
write.fasta(sequences=str_split(unique.promoter.seq.tm,''),
            names=promoter.Full$entrezgene[[3]][na.omit(match.entrez.unique.tm)],
            file.out='fasta_500_promoter_seq_tm_unique.fa',nbchar=1600)


PFvTM.motifs <- findMotifFasta('fasta_500_promoter_seq_pf_unique.fa',
                               'fasta_500_promoter_seq_tm_unique.fa',
                               max.motif=3,enriched=T)

PFvTM.motifs

motifLatexTable(main="FG: positive pf COMT correlations, BG: positive cb COMT correlations, Prefrontal vs. Cerebellum motifs", PF.motifs, prefix="posPFvsCB")

plotMotif(PFvCB.motifs$motifs[[1]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)
plotMotif(PFvCB.motifs$motifs[[2]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)
plotMotif(PFvCB.motifs$motifs[[3]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)

############## end pf vs. tm ###################

############## start pf vs. po #################
# try all pos but compare pf to tm

match.entrez.unique.pf <- match(unique.full.data.all$pf$ENTREZID,promoter.Full$entrezgene[[1]])
unique.promoter.seq.pf <- promoter.Full$prom.Seq[[1]][na.omit(match.entrez.unique.pf)]

match.entrez.unique.po <- match(unique.full.data.all$po$ENTREZID,promoter.Full$entrezgene[[4]])
unique.promoter.seq.po <- promoter.Full$prom.Seq[[4]][na.omit(match.entrez.unique.po)]

# write.fasta(sequences=str_split(unique.promoter.seq.pf,''),
#             names=promoter.Full$entrezgene[[1]][na.omit(match.entrez.unique.pf)],
#             file.out='fasta_500_promoter_seq_pf_unique.fa',nbchar=1600)
write.fasta(sequences=str_split(unique.promoter.seq.po,''),
            names=promoter.Full$entrezgene[[4]][na.omit(match.entrez.unique.po)],
            file.out='fasta_500_promoter_seq_po_unique.fa',nbchar=1600)


PFvPO.motifs <- findMotifFasta('fasta_500_promoter_seq_pf_unique.fa',
                               'fasta_500_promoter_seq_po_unique.fa',
                               max.motif=3,enriched=T)

PFvTM.motifs

motifLatexTable(main="FG: positive pf COMT correlations, BG: positive cb COMT correlations, Prefrontal vs. Cerebellum motifs", PF.motifs, prefix="posPFvsCB")

plotMotif(PFvCB.motifs$motifs[[1]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)
plotMotif(PFvCB.motifs$motifs[[2]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)
plotMotif(PFvCB.motifs$motifs[[3]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)

############## end pf vs. po ###################


###### start Cerebellum ###########
CB.motifs <- findMotifFasta("fasta_500_promoter_seq_cb_pos.fa","fasta_500_promoter_seq_cb_neg.fa",max.motif=3,enriched=T)

motifLatexTable(main="FG: positive COMT correlations, BG: negative COMT correlations, Cerebellum motifs", CB.motifs, prefix="posnegCB")

plotMotif(CB.motifs$motifs[[1]]@match$pattern, logodds=TRUE, entropy=TRUE)

###### end Cerebellum ###########


###### start Temporal ###########
TM.motifs <- findMotifFasta("fasta_500_promoter_seq_tm_pos.fa","fasta_500_promoter_seq_tm_neg.fa",max.motif=3,enriched=T)

motifLatexTable(main="FG: positive COMT correlations, BG: negative COMT correlations, Temporal Cortex motifs", TM.motifs, prefix="posnegTM")

plotMotif(TM.motifs$motifs[[1]]@match$pattern, logodds=TRUE, entropy=TRUE)
###### end Temporal ###########

###### start Pons ###########
PO.motifs <- findMotifFasta("fasta_500_promoter_seq_po_pos.fa","fasta_500_promoter_seq_po_neg.fa",max.motif=3,enriched=T)

motifLatexTable(main="FG: positive COMT correlations, BG: negative COMT correlations, Pons motifs", TM.motifs, prefix="posnegPONS")

plotMotif(PO.motifs$motifs[[1]]@match$pattern, logodds=TRUE, entropy=TRUE)
###### end Pons ###########


@

<<background.foreground.DNAletters>>=
# The first function gets the percentages of DNA across ALL promoters in the human genome

all.promoters.DNAletts <- getBackgroundFrequencies(organism = "hg19",
                                                   pseudo.count = 1, 
                                                   quick = TRUE)
pos.lett.freq <- list()

posi <- seq(1,as.integer(length(fasta.by.lett.pos$pf)/1600),1)
pos.lett.freq[[1]] <- lapply(fasta.by.lett.pos$pf[posi], function(x,posi)  table(x), posi)

posi <- seq(1,as.integer(length(fasta.by.lett.pos$cb)/1600),1)
pos.lett.freq[[2]] <- lapply(fasta.by.lett.pos$cb[posi], function(x,posi)  table(x), posi)

posi <- seq(1,as.integer(length(fasta.by.lett.pos$tm)/1600),1)
pos.lett.freq[[3]] <- lapply(fasta.by.lett.pos$tm[posi], function(x,posi)  table(x), posi)

posi <- seq(1,as.integer(length(fasta.by.lett.pos$po)/1600),1)
pos.lett.freq[[4]] <- lapply(fasta.by.lett.pos$po[posi], function(x,posi)  table(x), posi)

pos.corr.lett.freq <- matrix(rep(0,16),ncol=4)

pos.corr.lett.freq[1,] <- colSums(matrix(unlist(pos.lett.freq[[1]]),ncol=4))
pos.corr.lett.freq[2,] <- colSums(matrix(unlist(pos.lett.freq[[2]]),ncol=4))
pos.corr.lett.freq[3,] <- colSums(matrix(unlist(pos.lett.freq[[3]]),ncol=4))
pos.corr.lett.freq[4,] <- colSums(matrix(unlist(pos.lett.freq[[4]]),ncol=4))

pos.corr.lett.freq[1,] <- pos.corr.lett.freq[1,]/sum(pos.corr.lett.freq[1,])
pos.corr.lett.freq[2,] <- pos.corr.lett.freq[2,]/sum(pos.corr.lett.freq[2,])
pos.corr.lett.freq[3,] <- pos.corr.lett.freq[3,]/sum(pos.corr.lett.freq[3,])
pos.corr.lett.freq[4,] <- pos.corr.lett.freq[4,]/sum(pos.corr.lett.freq[4,])


######## negatively correlated
neg.lett.freq <- list()

negi <- seq(1,as.integer(length(fasta.by.lett.neg$pf)/1600),1)
neg.lett.freq[[1]] <- lapply(fasta.by.lett.neg$pf[negi], function(x,negi)  table(x), negi)

negi <- seq(1,as.integer(length(fasta.by.lett.neg$cb)/1600),1)
neg.lett.freq[[2]] <- lapply(fasta.by.lett.neg$cb[negi], function(x,negi)  table(x), negi)

negi <- seq(1,as.integer(length(fasta.by.lett.neg$tm)/1600),1)
neg.lett.freq[[3]] <- lapply(fasta.by.lett.neg$tm[negi], function(x,negi)  table(x), negi)

negi <- seq(1,as.integer(length(fasta.by.lett.neg$po)/1600),1)
neg.lett.freq[[4]] <- lapply(fasta.by.lett.neg$po[negi], function(x,negi)  table(x), negi)

neg.corr.lett.freq <- matrix(rep(0,16),ncol=4)

neg.corr.lett.freq[1,] <- colSums(matrix(unlist(neg.lett.freq[[1]]),ncol=4))
neg.corr.lett.freq[2,] <- colSums(matrix(unlist(neg.lett.freq[[2]]),ncol=4))
neg.corr.lett.freq[3,] <- colSums(matrix(unlist(neg.lett.freq[[3]]),ncol=4))
neg.corr.lett.freq[4,] <- colSums(matrix(unlist(neg.lett.freq[[4]]),ncol=4))

neg.corr.lett.freq[1,] <- neg.corr.lett.freq[1,]/sum(neg.corr.lett.freq[1,])
neg.corr.lett.freq[2,] <- neg.corr.lett.freq[2,]/sum(neg.corr.lett.freq[2,])
neg.corr.lett.freq[3,] <- neg.corr.lett.freq[3,]/sum(neg.corr.lett.freq[3,])
neg.corr.lett.freq[4,] <- neg.corr.lett.freq[4,]/sum(neg.corr.lett.freq[4,])

lett.proportion.matrix <- data.frame(rbind(pos.corr.lett.freq,neg.corr.lett.freq))
colnames(lett.proportion.matrix) <- c('A','C','G','T')
row.names(lett.proportion.matrix) <- c('PFpos',
                                       'CBpos',
                                       'TMpos',
                                       'POpos',
                                       'PFneg',
                                       'CBneg',
                                       'TMneg',
                                       'POneg')

@

<<matchTF.to.Symbols>>=

tf.matches.pf <- match(as.character(tfs.PvN.pf$TF_Name),hold.Lowest.pvals[[1]]$Symbol)
tf.matches.pf

@

<<show.Bob>>=
st.A <- c('TCTGTGGCCCTAGGCC')
st.B <- c('ACAGGTGGACCCCGCA')
st.A.sp <- strsplit(st.A,NULL)
st.B.sp <- strsplit(st.B,NULL)

st.A.sp.c <- c(rep(NA,16))
st.B.sp.c <- c(rep(NA,16))

for (iu in 1:16)  {
     
     if (st.A.sp[[1]][iu] == 'A') {
          st.A.sp.c[iu] <- c('T')
     } else if (st.A.sp[[1]][iu] == 'T') {
          st.A.sp.c[iu] <- c('A')
     } else if (st.A.sp[[1]][iu] == 'C') {
          st.A.sp.c[iu] <- c('G')     
     } else if (st.A.sp[[1]][iu] == 'G') {
          st.A.sp.c[iu] <- c('C') 
     } else {
          
     }
}

for (iu in 1:16)  {
     
     if (st.B.sp[[1]][iu] == 'A') {
          st.B.sp.c[iu] <- c('T')
     } else if (st.B.sp[[1]][iu] == 'T') {
          st.B.sp.c[iu] <- c('A')
     } else if (st.B.sp[[1]][iu] == 'C') {
          st.B.sp.c[iu] <- c('G')     
     } else if (st.B.sp[[1]][iu] == 'G') {
          st.B.sp.c[iu] <- c('C') 
     } else {
          
     }
}


@

<<TATA.boxes>>=

# TATA box sequences

tata.boxes <- c('TATAAAA',
                'TATAAAT',
                'TATATAA',
                'TATATAT')

tata.hits.pos <- list()
tata.hits.neg <- list()

tata.hits.pos <- lapply(seq.pos.fasta[ib], function(x,ib) which(grepl('TATA[AT]A[AT]',x)),ib)
tata.hits.neg <- lapply(seq.neg.fasta[ib], function(x,ib) which(grepl('TATA[AT]A[AT]',x)),ib)

tata.hits.pos <- lapply(seq.pos.fasta[ib], function(x,ib) gregexpr('TATA[AT]A[AT]',x),ib)
tata.hits.neg <- lapply(seq.neg.fasta[ib], function(x,ib) gregexpr('TATA[AT]A[AT]',x),ib)

hist(unlist(tata.hits.pos[[1]][which(tata.hits.pos[[1]] != '-1')]),20)
hist(unlist(tata.hits.neg[[1]][which(tata.hits.neg[[1]] != '-1')]),20)





@




<<tf.hits.comp.posvneg>>=

wbtf <- loadWorkbook('/Volumes/Macintosh_HD_3/genetics/genenetwork2/bob analysis/tf_hits_by_location.xlsx')   

# now tell R to read that workbook and which sheet
# sheet: positive = positively correlated genes, length 6 motifs
# sheet: negative = negatively correlated genes, length 6 motifs
# sheet: poslen7 = positively correlated genes, length 7 motifs
# sheet: neglen7 = negatively correlated genes, length 7 motifs

  pos.hits.Data <- data.frame(read.xlsx(wbtf,sheet = "positive"))
  
  neg.hits.Data <- data.frame(read.xlsx(wbtf,sheet = "negative"))
  
  pos.hits.Data$avgloc <- pos.hits.Data$avgloc - 1001
  neg.hits.Data$avgloc <- neg.hits.Data$avgloc - 1001
  
  colnames(pos.hits.Data)

# colnames for positive and negative sheets
#  [1] "N.Com"  "Cnt"    "Aver"   "str6"   "SndCnt" "Lgest" 
#  [7] "Loc"    "Aver.1" "X9"     "X10"    "X11"    "X12"   
# [13] "X13"    "X14"    "X15"    "X16"    "X17"    "X18"   
# [19] "X19"    "X20"    "X21"    "X22"    "X23"    "X24" 
 
#  Note: bucket sizes are larger for the length 7 motifs 
# colnames for poslen7 and neglen7 sheets
#  [1] "N.Com"  "Cnt"    "Aver"   "str7"   "SndCnt" "Lgest" 
#  [7] "Loc"    "avgloc" "X9"     "X10"    "X11"    "X12"   
# [13] "X13"    "X14"    "X15"    "X16"  

# The following code determines the motifs for which the proportion of negatively-correlated genes is significantly different after Bonferroni correction from the proportion of positively-correlated genes.
  
# colnames str6 for length 6 strings; str7 for length 7 strings
  
match.motifs.posVneg <- matrix(rep(NA,length(pos.hits.Data$str6)),
                               ncol=length(pos.hits.Data$str6))

match.motifs.posVneg <- match(pos.hits.Data$str6,neg.hits.Data$str6)

# length(seq.pos.fasta[[1]])
# [1] 323
# length(seq.neg.fasta[[1]])
# [1] 168

div.num <- c(length(seq.pos.fasta[[1]]),
             length(seq.neg.fasta[[1]]))

comp.prop.motif.hits <- data.frame(pos=rep(0,length(which(!is.na(match.motifs.posVneg)))),
                                   posTot=rep(div.num[1],
                                              length(which(!is.na(match.motifs.posVneg)))),
                                   neg=rep(0,length(which(!is.na(match.motifs.posVneg)))),
                                   negTot=rep(div.num[2],
                                              length(which(!is.na(match.motifs.posVneg)))),
                                   tval=rep(0,length(which(!is.na(match.motifs.posVneg)))),
                                   pval=rep(0,length(which(!is.na(match.motifs.posVneg)))),
                                   motif=rep(NA,length(which(!is.na(match.motifs.posVneg)))))


comp.prop.motif.hits$pos <- pos.hits.Data$SndCnt[which(!is.na(match.motifs.posVneg))]
comp.prop.motif.hits$neg <- (neg.hits.Data$SndCnt[match.motifs.posVneg[which(!is.na(match.motifs.posVneg))]])
comp.prop.motif.hits$motif <- neg.hits.Data$str6[match.motifs.posVneg[which(!is.na(match.motifs.posVneg))]]


ci.propor.vals <- data.frame(prop.Pos=rep(NA,length(which(!is.na(match.motifs.posVneg)))),
                         prop.Neg=rep(NA,length(which(!is.na(match.motifs.posVneg)))),
                         motif=rep(NA,length(which(!is.na(match.motifs.posVneg)))),
                         p.value=rep(NA,length(which(!is.na(match.motifs.posVneg)))))

tseq <- seq(1,length(which(!is.na(match.motifs.posVneg))),1)


# ci.propor <- diffscoreci(comp.prop.motif.hits$pos, comp.prop.motif.hits$posTot, 
#                          comp.prop.motif.hits$neg, comp.prop.motif.hits$negTot, 
#             conf.level=0.95)

# for (kl in tseq)   {
# 
#      ci.propor.vals$prop.Pos[kl] <- round(comp.prop.motif.hits$pos[kl]/comp.prop.motif.hits$posTot[kl],4)
#      ci.propor.vals$prop.Neg[kl] <- round(comp.prop.motif.hits$neg[kl]/comp.prop.motif.hits$negTot[kl],4)
# 
# }


for (kl in tseq)   {
     
          ci.propor.vals$prop.Pos[kl] <- round(comp.prop.motif.hits$pos[kl]/comp.prop.motif.hits$posTot[kl],4)
     ci.propor.vals$prop.Neg[kl] <- round(comp.prop.motif.hits$neg[kl]/comp.prop.motif.hits$negTot[kl],4)
     
     if (ci.propor.vals$prop.Pos[kl] > 0.20 & ci.propor.vals$prop.Neg[kl] > 0.2)  {

     # ci.propor[kl] <- prop.test(c(comp.prop.motif.hits$pos[kl],
     #                                comp.prop.motif.hits$neg[kl]),
     #                              c(comp.prop.motif.hits$posTot[kl],
     #                                comp.prop.motif.hits$negTot[kl]),
     #                              alternative=c('two.sided'))
          
          # ci.propor.vals$prop.Pos[kl] <- round(comp.prop.motif.hits$pos[kl]/comp.prop.motif.hits$posTot[kl],4)
          # ci.propor.vals$prop.Neg[kl] <- round(comp.prop.motif.hits$neg[kl]/comp.prop.motif.hits$negTot[kl],4)
          ci.propor.vals$motif[kl] <- comp.prop.motif.hits$motif[kl]
          ci.propor.vals$p.value[kl] <- prop.test(c(comp.prop.motif.hits$pos[kl],
                                    comp.prop.motif.hits$neg[kl]),
                                  c(comp.prop.motif.hits$posTot[kl],
                                    comp.prop.motif.hits$negTot[kl]),
                                  alternative=c('two.sided'))$p.value
     
     } else {
     
          ci.propor.vals$p.value[kl] <- c(NA)
          ci.propor.vals$motif[kl] <- comp.prop.motif.hits$motif[kl]
}

}


p20.indx <- c(which(!is.na(ci.propor.vals$p.value)))   # indices of the motifs possessed by > 20% of promoters

p.Bonfer <- 0.05/length(p20.indx)

np20 <- seq(1,length(p20.indx),1)

sig.motifs.indx <- matrix()
for (yh in np20)  {
     
     if (ci.propor.vals$p.value[p20.indx[yh]] <= p.Bonfer) {
          sig.motifs.indx[yh] <- p20.indx[yh]
     } else {
          sig.motifs.indx[yh] <- NA
     }
}

sig.motifs.indx <- na.omit(sig.motifs.indx)

sig.motifs <- data.frame(motif=ci.propor.vals$motif[c(sig.motifs.indx)],
                         propPos=ci.propor.vals$prop.Pos[c(sig.motifs.indx)],
                         propNeg=ci.propor.vals$prop.Neg[c(sig.motifs.indx)],
                         pval=ci.propor.vals$p.value[c(sig.motifs.indx)])

sig.motifs <- sig.motifs[order(sig.motifs$pval,decreasing=FALSE),]

sig.fancy.motifs.tab <- print.xtable(xtable(sig.motifs,
                         caption='Heptamer motifs in the promoter regions of genes in Prefrontal Cortex for which the proportion of positively COMT-correlated genes containing that motif  differs significantly (after Bonferroni correction) from the proportion of negatively COMT-correlated genes containing that motif ordered by p value.',
                         type='latex',
                         floating=FALSE,
                         caption.placement='top',
                         tabular.environment='longtable',
#                         caption.width ='0.5\\textwidth',
#                         hline.after=c(-1,0,nrow(topgene.By.chr.tab)),
                         include.rownames=FALSE,
                         print.results=TRUE,
                         booktabs=TRUE,
#                         comment=TRUE
                         digits=c(0,0,2,2,11)
                         ))

@

<<atVcg.content.promoters>>=

# The negatively correlated genes that had proportionately more instances of a given motif appeared to be A,T enriched over the positively correlated genes.

# First, get the AT vs. CG content of the full promoters for positvely vs. negatively correlated genes.

# acgt.content.pos <- lapply(pos.lett.freq[ib], function(x,ib) colSums(x)/(1600*dim(x)[1]),ib)
# acgt.content.neg <- lapply(neg.lett.freq[ib], function(x,ib) colSums(x)/(1600*dim(x)[1]),ib)

acgt.content.pos <- lapply(pos.lett.freq[ib], function(x,ib) colSums(x),ib)
acgt.content.neg <- lapply(neg.lett.freq[ib], function(x,ib) colSums(x),ib)

acgt.content.full.promoters <- list(pos=acgt.content.pos,
                                    neg=acgt.content.neg,
                                    pos.Perc=sapply(acgt.content.full.promoters$pos[ib], function(x,ib) x/sum(unlist(x)), ib),
                                    neg.Perc=sapply(acgt.content.full.promoters$neg[ib], function(x,ib) x/sum(unlist(x)), ib))

promoter.content.chsq <- list()
promoter.content <- data.frame(pos=rep(NA,4),
                               neg=rep(NA,4))
row.names(promoter.content) <- c('A','C','G','T')

promoter.content.atVcg.chsq <- list()

promoter500.atVcg <- list()

for (im in ib)   {

     promoter.content <- data.frame(pos=acgt.content.full.promoters$pos[[im]],
                                    neg=acgt.content.full.promoters$neg[[im]])
     
     promoter.content.atVcg <- data.frame(matrix(c(sum(acgt.content.full.promoters$pos[[im]][c(1,4)]),
                                      sum(acgt.content.full.promoters$pos[[im]][c(2,3)]),     
                                      sum(acgt.content.full.promoters$neg[[im]][c(1,4)]),
                                      sum(acgt.content.full.promoters$neg[[im]][c(2,3)])),
                                      ncol=2,byrow=TRUE
                                                    ))
      
     promoter.content.atVcg[,3] <- promoter.content.atVcg[,2]/rowSums(promoter.content.atVcg)
     
     promoter500.atVcg[[im]] <- promoter.content.atVcg
     
     colnames(promoter.content.atVcg) <- c('AT','CG','PercCG')
     row.names(promoter.content.atVcg) <- c('pos','neg')
     
     promoter500.atVcg[[im]] <- promoter.content.atVcg
     
     promoter.content.chsq[[im]] <- chisq.test(promoter.content)
     row.names(promoter.content.chsq[[im]]$observed) <- c('A','C','G','T')
     
     promoter.content.atVcg.chsq[[im]] <- chisq.test(promoter.content.atVcg[,1:2],correct=TRUE)
     row.names(promoter.content.atVcg.chsq[[im]]$observed) <- c('pos','neg')
     
}


sink('dnaLetter_content_chisq_posVneg.txt')
lapply(promoter.content.chsq[ib], function(x,ib) print(x[]), ib)
sink()

sink('dnaLetter_atVcg_content_chisq_posVneg.txt')
lapply(promoter.content.atVcg.chsq[ib], function(x,ib) print(x[]), ib)
sink()


# This computes/checks the chisq.test
promoter.content.pf[,3] <- rowSums(promoter.content.pf)
promoter.content.pf[5,] <- colSums(promoter.content.pf)

promoter.content.pf[1:4,4] <- promoter.content.pf[5,1]*promoter.content.pf[1:4,3]/promoter.content.pf[5,3]
promoter.content.pf[1:4,5] <- promoter.content.pf[5,2]*promoter.content.pf[1:4,3]/promoter.content.pf[5,3]

x.sq <- sum(((promoter.content.pf[1:4,1] - promoter.content.pf[1:4,4])^2)/promoter.content.pf[1:4,4]) + sum(((promoter.content.pf[1:4,2] - promoter.content.pf[1:4,5])^2)/promoter.content.pf[1:4,5])

x.sq
# end check chisq.test



@

<<promoter.content.proportions>>=




@




<<>>=
# Reverse, complement and Reverse-complement the set of significant motifs to check against original set

motifs.DNA <- DNAStringSet(x=sig.motifs$motif)
motifs.DNA.rev <- reverse(motifs.DNA)
motifs.DNA.compl <- complement(motifs.DNA)
motifs.DNA.revCompl <- reverseComplement(motifs.DNA)

comp.motifs.rev.comp <- list(rev=matrix(rep(FALSE,length(motifs.DNA)*length(motifs.DNA)),
                                    ncol=length(motifs.DNA)),
                             compl=matrix(rep(FALSE,length(motifs.DNA)*length(motifs.DNA)),
                                    ncol=length(motifs.DNA)),       
                             revCompl=matrix(rep(FALSE,length(motifs.DNA)*length(motifs.DNA)),
                                    ncol=length(motifs.DNA))       
                                    )
     

for (hj in 1:length(motifs.DNA)) {
     
     for (nk in 1:length(motifs.DNA))  {
     
          if (motifs.DNA[[hj]] == motifs.DNA.rev[[nk]])  {
              comp.motifs.rev.comp$rev[nk,hj] = TRUE 
          }
          
          if (motifs.DNA[[hj]] == motifs.DNA.compl[[nk]])  {
              comp.motifs.rev.comp$compl[nk,hj] = TRUE 
          }
          
          if (motifs.DNA[[hj]] == motifs.DNA.revCompl[[nk]])  {
              comp.motifs.rev.comp$revCompl[nk,hj] = TRUE 
          }
     
     }
     
}


@

<<loc.sign.motifs>>=

#gregexpr(pattern ='2',"the2quickbrownfoxeswere2tired")

sig.motifs.indx <- list(pos=list(),
                        neg=list())

 for (gh in 1:length(motifs.DNA))  {
    
     
     
     sig.motifs.indx$pos[[gh]] <- gregexpr(pattern = motifs.DNA[gh],seq.pos.fasta[[1]],
                                         fixed=TRUE)
     sig.motifs.indx$neg[[gh]] <- gregexpr(pattern = motifs.DNA[gh],seq.neg.fasta[[1]],
                                         fixed=TRUE)
}


# Get a matrix with the positions 
neg.motif.hits <- list()

for (uj in 1:length(motifs.DNA)) {
     
     temp.vec <- matrix()
     
     for (kl in 1:length(sig.motifs.indx$neg))    {
     
     if (unlist(sig.motifs.indx$neg[[uj]][kl])[1] > -1)  {
          temp.vec <- c(temp.vec,
                       c(unlist(sig.motifs.indx$neg[[uj]][kl]) - 1001))
     } else {
          
     }
  } 
     neg.motif.hits[[uj]] <- temp.vec
}

pos.motif.hits <- list()

for (uj in 1:length(motifs.DNA)) {
     
     temp.vec <- matrix()
     
     for (kl in 1:length(sig.motifs.indx$pos))    {
     
     if (unlist(sig.motifs.indx$pos[[uj]][kl])[1] > -1)  {
          temp.vec <- c(temp.vec,
                       c(unlist(sig.motifs.indx$pos[[uj]][kl]) - 1001))
     } else {
          
     }
  } 
     pos.motif.hits[[uj]] <- temp.vec
}


@

<<dinucleotide.probs>>=


dinuc.sum <- (nchar(seq.fasta[[1]][1]) - 1)*length(seq.fasta[[1]])
fasta.strings <- DNAStringSet(x=as.character(seq.fasta[[1]]))

# dinucl.prob contains the probability of observing AA, AC, AG, AT, CA, CC, etc. across all of the fasta sequences
dinucl.prob <- colSums(dinucleotideFrequency(fasta.strings))/dinuc.sum

dinucl.motifs <- dinucleotideFrequency(motifs.DNA)

motifs.freq <- c()

for (kl in 1:dim(dinucl.motifs)[1])   {

          motifs.freq[kl] <- (exp(sum(dinucl.motifs[kl,]*log(dinucl.prob))))*dinuc.sum

}




@



<< >>=

# This is used below in the ontology analysis section.

# Which genes show the largest variance in COMT-correlation coefficients across brain areas?
# Need to find out which genes were measured in all four brain areas - do this using the onegene 
# data

all.Areas.symbols <- na.omit(intersect(intersect(intersect(na.omit(prefront.Data.onegene$Symbol),na.omit(cbell.Data.onegene$Symbol)),na.omit(tempor.Data.onegene$Symbol)),na.omit(pons.Data.onegene$Symbol)))

# This leaves 10636 genes in common across the brain areas
pf.common.Genes.indx <- match(all.Areas.symbols,prefront.Data.onegene$Symbol)
cb.common.Genes.indx <- match(all.Areas.symbols,cbell.Data.onegene$Symbol)
tm.common.Genes.indx <- match(all.Areas.symbols,tempor.Data.onegene$Symbol)
po.common.Genes.indx <- match(all.Areas.symbols,pons.Data.onegene$Symbol)
# 
area.colwise <- data.frame(pf.a = prefront.Data.onegene$Symbol[pf.common.Genes.indx],
           cb.a = cbell.Data.onegene$Symbol[cb.common.Genes.indx],
           tm.a = tempor.Data.onegene$Symbol[tm.common.Genes.indx],
           po.a = pons.Data.onegene$Symbol[po.common.Genes.indx],
           pf.m = prefront.Data.onegene$Mean[pf.common.Genes.indx],
           cb.m = cbell.Data.onegene$Mean[pf.common.Genes.indx],
           tm.m = tempor.Data.onegene$Mean[pf.common.Genes.indx],
           po.m = pons.Data.onegene$Mean[pf.common.Genes.indx],
           pf.r = prefront.Data.onegene$Sample.r[pf.common.Genes.indx],
           cb.r = cbell.Data.onegene$Sample.r[cb.common.Genes.indx],
           tm.r = tempor.Data.onegene$Sample.r[tm.common.Genes.indx],
           po.r = pons.Data.onegene$Sample.r[po.common.Genes.indx])
# 
area.colwise$ENTREZID <- prefront.Data.onegene$ENTREZID[pf.common.Genes.indx]
# 
# 

# Determine for each gene whether the correlation with COMT expression was above or
# below the average correlation WITHIN a brain area

# First use Fisher's Z-transformation to convert the correlations to z scores.

r2Z <- function (r.in) 0.5*(log(1.0 + r.in) - log(1.0 - r.in))    # Fisher's r to Z

fix.dim <- dim(area.colwise)[2]
area.colwise[,(fix.dim + 1:4)] <- r2Z(area.colwise[,(fix.dim - 4:1)])
colnames(area.colwise)[(fix.dim + 1:4)] <- c('pf.Z','cb.Z','tm.Z','po.Z')

area.colwise$pf.z <- scale(area.colwise$pf.Z,center=TRUE,scale=TRUE) 
area.colwise$cb.z <- scale(area.colwise$cb.Z,center=TRUE,scale=TRUE)
area.colwise$tm.z <- scale(area.colwise$tm.Z,center=TRUE,scale=TRUE)
area.colwise$po.z <- scale(area.colwise$po.Z,center=TRUE,scale=TRUE)

fix.dim <- dim(area.colwise)[2]
area.colwise[,(fix.dim + 1:4)] <- sign(area.colwise[,(fix.dim - 3:0)])

fix.dim <- dim(area.colwise)[2]
colnames(area.colwise)[(fix.dim - 3:0)] <- c('pf.zsign','cb.zsign','tm.zsign','po.zsign')

fix.dim <- dim(area.colwise)[2]
sign.tab <- table(area.colwise[,(fix.dim - 3:0)])
 
summary(sign.tab)
sign.tab2 <- data.frame(sign.tab)

sign.tab3 <- structable(area.colwise[,22:25])


@

March 19, 2018\\
Using the following steps:
\begin{enumerate}
     \item All {\textit {COMT}}-correlations are Z transformed using Fisher's formula.
     \item Within a brain region, these Fisher Z scores are z-scored (x - m)/s.
     \item These z-scores are then converted to signs (+ or -).
     \item A plus sign means that gene in that brain area had a correlation that was above the average correlation for all genes in that brain area.
     \item A minus sign means that gene in that brain area had a correlation that was below the average correlation for all genes in that brain area.
\end{enumerate}

Using this order for brain areas: Prefrontal, Cerebellum, Temporal, Pons - the following sign patterns are indicative of:
\begin{enumerate}
     \item Tissue {\textit {non-specific}} expression regulation: +1, +1, +1, +1 or -1, -1, -1, -1
     \item Prefrontal-specific regulation: -1, +1, +1, +1 or +1, -1, -1, -1
     \item Cerebellum-specific regulation: +1, -1, +1, +1 or -1, +1, -1, -1
     \item Temporal-specific regulation: +1, +1, -1, +1 or -1, -1, +1, -1
     \item Pons-specific regulation: +1, +1, +1, -1 or -1, -1, -1, +1
\end{enumerate}

The table in the file zsign_tab.pdf shows that a very large proportion of the genes exhibited the first pattern above indicating tissue {\textit {non-specific}} expression regulation. There were, however, nontrivial numbers of genes who showed one of the other four patterns. By classifying the genes into the other four categories above, it should be possible to do ontology to discover what networks or functions those genes might exhibit.

<< >>=
# Classify genes into one of the four tissue specific regulation patterns, or the tissue nonspecific pattern.

hold.binary <- matrix(rep(0,5*dim(area.colwise)[1]),ncol=5)
hold.binary[,1:4] <- c((area.colwise$pf.zsign + 1)/2,
                       (area.colwise$cb.zsign + 1)/2,
                       (area.colwise$tm.zsign + 1)/2,
                       (area.colwise$po.zsign + 1)/2
                       )
hold.binary[,5] <- (hold.binary[,1])*(2^3) + (hold.binary[,2])*(2^2) + (hold.binary[,3])*(2^1) + (hold.binary[,4])*(2^0)

# hold.binary[,5] holds the numbers 0:15. Pairs of numbers represent different types of expression regulation: 4 pairs represent area-specific regulation, and 1 pair represents area (tissue) nonspecific regulation. For example the numbers 0 and 15 represent area nonspecific regulation because the correlations in all four brain areas are above the average correlation in their respective brain areas or all of them are below.

area.colwise$signClass <- hold.binary[,5]

pf.specific.up <- subset(area.colwise,area.colwise$signClass == 8)
pf.specific.down <- subset(area.colwise,area.colwise$signClass == 7)
pf.specific <- subset(area.colwise,area.colwise$signClass == 7 | area.colwise$signClass == 8)
pf.specific$shuffSymb <- sample(pf.specific$pf.a,dim(pf.specific)[1],replace=FALSE)





@




<< >>=
# 
# # Do the same analysis for mean expression level
# ############************ First z-score the mean expression levels to remove between probeset effects
# 
# area.colwise$zscorepf <- scale(area.colwise$pf.m,center=T,scale=T)
# area.colwise$zscorecb <- scale(area.colwise$cb.m,center=T,scale=T)
# area.colwise$zscoretm <- scale(area.colwise$tm.m,center=T,scale=T)
# area.colwise$zscorepo <- scale(area.colwise$po.m,center=T,scale=T)
# 
# # Now calculate mean and variance
# 
# avg.expr <- rowMeans(area.colwise[,14:17])
# 
# var.expr <- rowVars(as.matrix(area.colwise[,14:17]))
# 
# # Now calculate the coefficient of variation for the correlation coefficient
# 
# coeff.Var.expr <- sqrt(var.expr)/abs(avg.expr)
# 
# # Now add columns to area.colwise
# 
# area.colwise$avg.expr <- avg.expr
# area.colwise$varnc.expr <- var.expr
# area.colwise$coeffVar.expr <- coeff.Var.expr
# 
# # Order by expression CV
# area.colwise <- area.colwise[order(area.colwise$coeffVar.expr,decreasing=TRUE),]
# 
# area.colwise[1:20,1]

@ 


% latex table generated in R 3.4.3 by xtable 1.8-2 package
% Wed Feb 21 08:07:04 2018
\begin{table}[ht]
\centering
%\begin{tabular}{lllllll}
\begin{tabular}{l >{\itshape}l >{\itshape}l >{\itshape}l >{\itshape}l >{\itshape}l >{\itshape}l }
  \hline
&  &  &  &  & \\ 
  \hline
{\bfseries{Cerebellum}} &   &   &   &   \\ 
& GPM6B & PMP22 & CPQ & COMT & MYO6 \\ 
& GPM6B & SEC22C & CAT & ATRAID & PPIB \\
{\bfseries{Temporal Cerebral Wall}} &   &   &   &   \\ 
& GPM6B & NTSR2 & PMP22 & EDNRB & PKM \\ 
& GATM & CDC14B & PTTG1IP & ECH1 & HSCB \\ 
& GPM6B & SEC22C & DTYMK & TSPO & CSTB \\ 
& MGLL & SLC3A2 & COMT & MEGF10 & ACY1 \\ 
& CAT & PLPP3 & CLDN10 & FGFR3 &   \\ 
{\bfseries{Pons}} &   &   &   &   \\ 
& GPM6B & SEC22C & GPM6B & GATM & CLU \\ 
& C2ORF28 & COMT & PMP22 & CAT & MEGF10 \\ 
   \hline
\end{tabular}
\caption{Genes having the strongest positively correlated expression with \textit{COMT} in each area also among the 50 most strongly \textit{COMT}-correlated genes in Prefrontal Cortex} 
\end{table}





<<include=FALSE, echo=False, results=tex >>=
# Generate tables that show which genes were most strongly positively or negatively correlated with COMT expression on a per chromosome basis.

for (b in 1:8)  {
########## DEBUG 

#b <- c(2)

########## END DEBUG

temp.Hold <- area.onegene.List[[b]][pos.neg.Lims[b,1]:pos.neg.Lims[b,2],]

temp.Hold2 <- temp.Hold[order(temp.Hold$loc),]

temp.tab <- table(temp.Hold2$loc)

temp.tab.seq <- matrix(rep(0,46),nrow=23)
temp.tab.seq[1,1:2] <- c(1,temp.tab[1])

for (i in 2:23) {
     temp.tab.seq[i,1] <- temp.tab.seq[i-1,2] + 1
     temp.tab.seq[i,2] <- temp.tab.seq[i,1] + temp.tab[i] -1
                       
}

fname <- paste0('topgenes_by_chr_',sign.Names[b],'_',rep(stand.Col.names,each=2)[b],'.txt',sep='')
fnameinput <- paste0('readable_topgenes_by_chr_',sign.Names[b],'_',rep(stand.Col.names,each=2)[b],'.csv',sep='')
write(paste(rep(stand.Col.names,each=2)[b],' ',sign.Names[b],'\n',sep=''),file=fname,append=FALSE)

for (j in 1:23)     {
     # Human readable
     write(print(paste('Chromosome ',map.Chrname.Chrnum$chrnum[j],sep=''),quote=FALSE),append=TRUE,
           ncolumns=8,file=fname,sep='\t')
     write(print(temp.Hold2[temp.tab.seq[chrname2num[j],1]:temp.tab.seq[chrname2num[j],2],3],rownames=FALSE,quote=FALSE),append=TRUE,ncolumns=8,file=fname,sep='\t')
     write(print(''),file=fname,append=TRUE)
     
     # R readable csv
     hold.Genes <- c(temp.Hold2[temp.tab.seq[chrname2num[j],1]:temp.tab.seq[chrname2num[j],2],3])
     hold.Genes[2:(length(hold.Genes) + 1)] <- hold.Genes
     hold.Genes[1] <- as.character(map.Chrname.Chrnum$chrnum[j])
     # write(print(temp.Hold2[temp.tab.seq[chrname2num[j],1]:temp.tab.seq[chrname2num[j],2],3],rownames=FALSE,quote=FALSE),append=TRUE,ncolumns=8,file=fnameinput,sep=', ')
     
     write(print(hold.Genes,rownames=FALSE,quote=FALSE),ncolumns=30,append=TRUE,file=fnameinput,sep=', ')

}

} # end brain area x sign loop 
@ 

<<include=FALSE, echo=FALSE, results=tex>>=
# Because only prefrontal negative and temporal negative showed significant chi-squares when
# comparing the observed distribution of 200 genes across chromosomes to the expected distribution
# based on the overall sample of genes whose expression levels were measured, and because 
# Chromosome 5 for both brain areas was the area that showed significantly more genes than would have # been expected (binomial tests), determine which genes on chromosome 5 among the 200 most strongly
# negatively coprrelated genes were in common across the two brain areas.

wbgc <- loadWorkbook('readabletopgenes_by_chr.xlsx')   

# now tell R to read that workbook and which sheet
  pf.Neg <- read.xlsx(wbgc,sheet = "pfneg",colNames=FALSE,rowNames=TRUE,na.strings=NA)
  tm.Neg <- read.xlsx(wbgc,sheet = "tmneg",colNames=FALSE,rowNames=TRUE,na.strings=NA)

  num.Genes.neg.Chr5 <- data.frame(area=c('Prefrontal','Temporal'),
                                   number=c(length(pf.Neg[5,]),length(tm.Neg[5,])))
  
genes.Shared.neg.chr5 <- tm.Neg[5,c(na.omit(match(pf.Neg[5,],tm.Neg[5,])))]

common.genes.Chr5.neg <- list()
common.genes.Chr5.neg[[1]] <- num.Genes.neg.Chr5   # Number of genes in top 200 not the shared ones
common.genes.Chr5.neg[[2]] <- sub(' ','',genes.Shared.neg.chr5)

# Get the ENTREZIDs for the genes in common

common.neg.Chr5.entrez <- matrix(rep(NA,length(common.genes.Chr5.neg[[2]])),
                                 ncol=1)

for (w in 1:length(common.genes.Chr5.neg[[2]])) {
    
           
    common.neg.Chr5.entrez[w]  <- area.List.byGene[[1]]$ENTREZID[(which(area.List.byGene[[1]]$Symbol == common.genes.Chr5.neg[[2]][w]))]
    
}
common.genes.Chr5.neg[[3]] <- common.neg.Chr5.entrez
common.neg.Genes.Chr5 <- data.frame(genes=common.genes.Chr5.neg[[2]],
                                    ENTREZID=common.genes.Chr5.neg[[3]])

########### *************** Transcriptiopn factors analysis using PFAM
temp.start.pos <- getBM(attributes = c('hgnc_symbol',"start_position",'entrezgene',"refseq_mrna"), 
                                        filters = "entrezgene",
                                        values = as.character(common.neg.Genes.Chr5$ENTREZID), 
                                        mart = ensembl)
comt.getBM <- getBM(attributes = c('hgnc_symbol',"start_position",'entrezgene',"refseq_mrna"), 
                                        filters = "hgnc_symbol",
                                        values = as.character('COMT'), 
                                        mart = ensembl)

wbts <- loadWorkbook('tsfactors_shared_8_and_comt_pscan.xlsx')
# wbhsa2 <- loadWorkbook('comt_coex_list_500_hsa2.xlsx')
# wbhsa3 <- loadWorkbook('comt_coex_list_500_hsa3.xlsx')

shared8.tfacts <- data.frame(read.xlsx(wbts,         # now tell R to read that workbook and which sheet
                                  sheet = "shared_8"))

comt.tfacts <- data.frame(read.xlsx(wbts,         # now tell R to read that workbook and which sheet
                                  sheet = "comt"))

shared8.comt.tsfactors.indx <- match(comt.tfacts$TF.NAME,shared8.tfacts$TF.NAME)
shared8.tfacts[shared8.comt.tsfactors.indx[1:10],]

one.genelims.pf <- c(rep(NA,2))
one.genelims.pf[1] <- length(prefront.Data.onegene$Symbol)
one.genelims.pf[2] <- length(prefront.Data.onegene$Symbol) - 199

na.omit(match(prefront.Data.onegene$Symbol[one.genelims.pf[1]:one.genelims.pf[2]],comt.tfacts$TF.NAME))

na.omit(match(prefront.Data.onegene$Symbol[1:200],comt.tfacts$TF.NAME))
################## END Transcription factor analysis ##########################


gene.Output.order <- match(common.neg.Genes.Chr5$genes,temp.start.pos$hgnc_symbol)

common.neg.Genes.Chr5$startpos <- temp.start.pos$start_position[c(gene.Output.order)]/1000000.

# order by start position
common.neg.Genes.Chr5 <- common.neg.Genes.Chr5[order(common.neg.Genes.Chr5$startpos,
                                                     decreasing=FALSE),]
common.neg.Genes.Chr5$placehold <- c(0,
                                     0,
                                     0.04,
                                     0,
                                     0.04,
                                     0.08,
                                     0.12,
                                     0)



genes8.chr5.Plt <-   ggplot(data=common.neg.Genes.Chr5, aes(x=round(startpos,2),
                                                            y=placehold),
                                                            label=genes) +
              geom_point(color = "black",size=1.5,shape=25,fill='black') + 
              geom_text(aes(label=genes),hjust=1.2, vjust = 0.5,
                        size=1.8) +

    #            theme(aspect.ratio=1) +
    scale_y_continuous(name='',
                       limits=c(0,0.9)) +
    scale_x_continuous(name='Gene Start Position (Mb)',
                       breaks = pretty_breaks(n = 8),
                       limits=c(40,round(chrom.Data$chrom.Length[5]/1000000.,0))
                       ) +
     
    labs(title="Strongly Negatively Correlated Genes in Common between Prefrontal Cortex and Temporal Cortex") 

#    theme_minimal() + 
    theme_classic() + 
    theme(aspect.ratio=0.4) +
    theme(axis.line.x = element_line(colour = "black",size=0.25)) +
     theme(axis.line.y = element_line(colour = "white",size=0.25),               
           axis.ticks.y = element_blank()) +
#    theme(plot.title = '') + 
    theme(axis.title = element_text(color="black",
                                    size=10,
                                    margin = margin(t = 4, r = 4, b = 0, l = 0)
                                    )) +
    theme(axis.text.x = element_text(size=10,
                                     margin = margin(t = 4, r = 0, b = 0, l = 0)),
          axis.text.y = 'none') + 

annotate("text", x = 160,
             y = 0.5,
             label = "cd949340d2d8b03116818001a9139944", 
             parse=FALSE,
             color="gray30",
             size=1.0,
         angle=0)    +
     
     annotate("text", x = 160,
             y = 0.6,
             label = "Nearly overlapping positions have been \n displaced vertically for clarity.", 
             parse=FALSE,
             color="gray30",
             size=2.0,
         angle=0)    +
     
     annotate("text", x = 110,
             y = 0.42,
             label = c('Start Positions of the Eight Genes on Chromosome 5 in Common in both  Prefrontal Cortex and Temporal Cortex among the 200 Most Strongly Negatively Correlated Genes'), 
             parse=FALSE,
             color="black",
             size=3.5,
             fontface='bold')


genes8.chr5.Plt

# save plots to file
     
     # ggsave(c('start_positions_8_on_chr5.pdf'), 
     #        plot = genes8.chr5.Plt, device = NULL, path = NULL,
     #              scale = 1, width = 8, height = 4, units = c("in"),
     #              dpi = 1200, limitsize = TRUE)

@

There were \Sexpr{common.genes.Chr5.neg[[1]][1,2]} and \Sexpr{common.genes.Chr5.neg[[1]][2,2]} genes on Chromosome 5 in \Sexpr{common.genes.Chr5.neg[[1]][1,1]} cortex and \Sexpr{common.genes.Chr5.neg[[1]][2,1]} cortex, respectively that were among the 200 most strongly negatively {\textit {COMT}}-correlated genes. There were \Sexpr{length(common.genes.Chr5.neg[[2]])} genes in common in these two sets of \Sexpr{common.genes.Chr5.neg[[1]][1,2]} genes.\\


Here is the plot of the starting positions of those 8 genes:\\

\includegraphics{start_positions_8_on_chr5}\vspace{3em}

The file transcription_factors_shared8_chr5-coExpressed-genes.txt was produced by the web site genefriends.org. It shows transcription factors that are co\den expressed with the eight shared genes on Chromosome 5. The first line of the file shows that the transcription factor SLC30A9, is shared by 6 of these 8 genes.

<<>>=
# Dendrogram plots of the relations between the 8 shared genes on Chr 5
# For MR
MR.dat <- read.delim("LocLocMR.tbl")
MR.dat <- MR.dat[,2:9]
MR.dist <- as.dist(log10(MR.dat))
MR.hc <- hclust(MR.dist, method="complete")
plot (MR.hc, hang=-1)
# For COR
COR.dat <- read.delim("LocLocCOR.tbl")
COR.dat <- COR.dat[,2:9]
COR.dist <- as.dist(1 - COR.dat)
COR.hc <- hclust(COR.dist, method="complete")
plot (COR.hc, hang=-1)


@


\vspace{-1em}\hspace{2em}
{\tiny{Note: Chr 23 = X and Chr 24 = Y}}\\


Plot of Number of genes per chromosome by chromosome length\\
\begin{figure}[H]
\begin{center}
<<label=plotChrcountvsLength, fig=TRUE,  echo = FALSE, include=FALSE >>= , pdf=FALSE, eps=TRUE 

area.Plot <- list()


for (k in ib) { 

     raw.Chr.count <- matrix(rep(NA,72),ncol=3)
     raw.Chr.count <- as.data.frame(raw.Chr.count)
     colnames(raw.Chr.count) <- c('ChrLabel','Gene.Count','Chromosome.Length')
     raw.Chr.count$ChrLabel <- c(as.character(c(1:22)),'X','Y')
     raw.Chr.count$Chromosome.Length <- chrom.Data$chrom.Length/1000000.

#     raw.Chr.count$Gene.Count <- c(table(area.onegene.List[[k]]$loc)[c(mapIndx[1:24])])
     raw.Chr.count$Gene.Count <- c(table(major.Area[[k]]$loc)[c(chrname2num)])
     corval <- round(cor(raw.Chr.count$Chromosome.Length,raw.Chr.count$Gene.Count,
                      method=c('pearson')),2)


numgenesvslength.Plt <-   ggplot(raw.Chr.count, aes(x=(Chromosome.Length),y=Gene.Count,
                                                     label=ChrLabel)) +
              geom_point(color = "blue",size=1.0) + 
              geom_text(aes(label=ChrLabel),hjust=.5, vjust=-.75,
                        size=2.5) +
              stat_smooth(method='lm',   # Add linear regression line
                geom='smooth',
                se=FALSE,
                color="red",
                size = 0.5,
                fullrange=TRUE,
                formula=y ~ x)  +  # Don't add shaded confidence region
    #            theme(aspect.ratio=1) +
    scale_y_continuous(name='Number of Genes',
                       limits=c(0,1.1*max(raw.Chr.count$Gene.Count))) +
    scale_x_continuous(name='Length of Chromosome (Mb)',
                       limits=c(25,275),
                       breaks = pretty_breaks(n = 8)) +
    ggtitle('Number of Genes by Chromosome versus Chromosome Length') + 
#    theme_minimal() + 
    theme_classic() + 
    theme(aspect.ratio=1/(gold.R^2)) +
    theme(axis.line = element_line(colour = "black",size=0.25)) +
    theme(plot.title = element_text(color="black",
                                    face="bold",
                                    size=10,
                                    hjust=0.5)) +
    theme(axis.title = element_text(color="black",
                                    size=10,
                                    margin = margin(t = 4, r = 4, b = 0, l = 0)
                                    )) +
    theme(axis.text.x = element_text(size=10,
                                     margin = margin(t = 4, r = 0, b = 0, l = 0)),
          axis.text.y = element_text(size=10,
                                     margin = margin(t = 0, r = 2, b = 0, l = 0))) + 
    annotate("text", x = c(50),
             y = c(1600),
             label = c(paste('r = ',toString(corval),sep='')),
             color="black",
             size=3) +
     
     annotate("text", x = c(52),
             y = c(1720),
             label = stand.Col.names[k],
             color="black",
             size=3)
  
area.Plot[[k]] <- numgenesvslength.Plt

# save plots to file

ggsave(c(paste('plot_Chrcount_vs_Length_',stand.Col.names[k],'.pdf',sep='')), plot =                   area.Plot[[k]], device = NULL, path = NULL,
                  scale = 1, width = 8, height = 5, units = c("in"),
                  dpi = 300, limitsize = TRUE)

     # genesvlength <- paste('plot_Chrcount_vs_Length_',stand.Col.names[k],'.eps',sep='')
     #      setEPS()
     #      postscript(genesvlength,width=8,height=6)
     #      area.Plot[[k]]
     #      dev.off()
} # end area loop

@

\includegraphics[width=\textwidth]{plot_Chrcount_vs_Length_Prefrontal.pdf}\vspace{3em}
\includegraphics[width=\textwidth]{plot_Chrcount_vs_Length_Cerebellum.pdf}\vspace{3em}
\includegraphics[width=\textwidth]{plot_Chrcount_vs_Length_Temporal.pdf}\vspace{3em}
\includegraphics[width=\textwidth]{plot_Chrcount_vs_Length_Pons.pdf}\vspace{3em}

\end{center}
\end{figure}

<<include=FALSE, echo=FALSE, results=hide>>=
# Histogram of top 200 +/- genes starting positions on Chromosome 22: the Chr that holds 
# MB-COMT

# Get the length of the COMT gene
comt.Specs <- c()
comt.Specs <- getBM(attributes = c("illumina_humanref_8_v3", "hgnc_symbol",
                                         "chromosome_name", "start_position","end_position",
                                         "entrezgene"), 
                                         filters = "illumina_humanref_8_v3", 
                          values = as.character('ILMN_1810941'), mart = ensembl)
comt.Length <- round((comt.Specs$end_position - comt.Specs$start_position)/1000000.,3)

i <- c(1)

 chr.22 <- subset(major.Area[[i]],major.Area[[i]]$loc=='22')
#chr.22 <- subset(hold.Lowest.pvals[[i]],hold.Lowest.pvals[[i]]$loc=='22')

medr.Pos <- median(as.numeric(subset(chr.22,chr.22$corsign == '1')$Sample.r))
medr.Neg <- median(as.numeric(subset(chr.22,chr.22$corsign == '-1')$Sample.r))

# sign.bp <-  data.frame(direct=chr.22.pf$corsign,
#                                startLoc=chr.22.pf$bp)

phist <- ggplot(data=chr.22, aes(as.numeric(chr.22$bp))) + geom_histogram() +
     
     geom_vline(data=chr.22,aes(xintercept=as.numeric(prefront.Data$bp[1])),
                color='red') +
     stat_bin(binwidth=c(1))
     
     to_string <- as_labeller(c(`-1` = "negative", `1` = "positive"))
     
phista <- phist +  facet_wrap(~ corsign,nrow=2,labeller = to_string) +
          
     scale_y_continuous(name='Frequency',
                       limits=c(0,30)) +     
          
     theme_bw() +
     theme(strip.background=element_rect(fill="gray90")) +
     theme(strip.text = element_text(colour = 'black')) +
     
     labs(x = c("Gene Starting Position (Mb)"),
          y = c('Frequency'),
          title = c(paste('Distribution of Gene Transcription Start Positions \n',
                          stand.Col.names[i],sep=''))) +
     theme(axis.text=element_text(size=7),
        axis.title=element_text(size=9)) +
     theme(plot.title=element_text(size=10,
                                   hjust=0.5)) +
          
          annotate("text", x = 0.90*as.numeric(prefront.Data$bp[1]),
             y = c(28),
             label = "MB-italic(COMT)", 
             parse=TRUE,
             color="black",
             size=2)

 phista
     # save plots to file
     
     # hist.22 <- paste('histogram_start_positions_Chr22_',stand.Col.names[i],'.eps',sep='')
     #      setEPS()
     #      postscript(hist.22,width=8,height=6)
     #      phista
     #      dev.off()

# Plot correlation vs. starting position for all genes on Chr 22 

for (i in ib)  {

chr.22 <- subset(major.Area[[i]],major.Area[[i]]$loc=='22')
#chr.22 <- subset(hold.Lowest.pvals[[i]],hold.Lowest.pvals[[i]]$loc=='22')

medr.Pos <- median(as.numeric(subset(chr.22,chr.22$corsign == '1')$Sample.r))
medr.Neg <- median(as.numeric(subset(chr.22,chr.22$corsign == '-1')$Sample.r))
 
comt.Extent <- data.frame(xmin=(comt.Specs$start_position/1000000.), 
                          xmax = (comt.Specs$end_position/1000000.),   
                          ymin = -1.0, 
                          ymax = 1.0) 
 

cor.Vs.start <- ggplot(data=chr.22, aes(x=as.numeric(chr.22$bp),y=as.numeric(chr.22$Sample.r),
                                        color=chr.22$Sample.r)) +

          geom_point(size=0.75) +
     
     geom_rug(sides="r",alpha=1/2,size=0.25)   +

     geom_rect(data=comt.Extent,mapping=aes(xmin=xmin,
                                         ymin=ymin,
                                         xmax=xmax,
                                         ymax=ymax),
                    stat='identity',
                    fill='red',
                    alpha=c(0.85),inherit.aes = FALSE) +
     
     scale_color_gradient2(low = cbPalette[2], mid = "gray50",
               high = "blue", midpoint = 0, space = "Lab",
               na.value = "grey50", guide = FALSE,                            # "colorbar",
               limits=c(-1, 1)) +
     
     # geom_vline(data=chr.22,aes(xintercept=as.numeric(prefront.Data$bp[1])),
     #            color=muted('green'),size=0.4,
     #            linetype='dashed') +
     
     
     geom_hline(data=chr.22,aes(yintercept=medr.Pos),
                color='black',size=0.5,
                linetype='dotted') +
     
     geom_hline(data=chr.22,aes(yintercept=medr.Neg),
                color='black',size=0.5,
                linetype='dotted') +
     
          
     scale_y_continuous(name='Correlation Coefficient, r',
                       limits=c(-1,1)) +  
          
     theme_bw() +
     
     labs(color = "Correlation", size=9) +

     labs(x = c("Gene Starting Position (Mb)"),
          y = c('Correlation Coefficient, r'),
          title = c(paste('Correlation Coefficient vs Gene Start Position \n',
                          'on Chromosome 22: ',stand.Col.names[i],sep=''))) +
     theme(axis.text=element_text(size=7),
        axis.title=element_text(size=9)) +
     theme(plot.title=element_text(size=10,
                                   hjust=0.5)) +
     
     # theme(legend.text = element_text(colour="black", size=7))     +
     # 
     # theme(legend.title = element_text(colour="black", size=9))    +
          
          annotate("text", x = 16,#0.92*(as.numeric(comt.Specs$start_position/1000000.)),
             y = c(1.0),
             label = "MB-italic(COMT)",
             parse=TRUE,
             color="black",
             size=2) +

# annotate("text", x = 0.92*(as.numeric(comt.Specs$start_position/1000000.)),
#              y = as.numeric(chr.22$Sample.r[which(chr.22$Symbol == 'COMT')]),
#              label = "S-italic(COMT)", 
#              parse=TRUE,
#              color="black",
#              size=2)  +

annotate("text", x = 51,
             y = -0.7,
             label = "a6f130dfc50751804905a7da48141392", 
             parse=FALSE,
             color="gray30",
             size=1.0,
         angle=-90)    +

annotate("text", x = 45,
             y = 1.0,
             label = "Note: dotted lines are medians.\n Red rect is extent of COMT gene.", 
             parse=FALSE,
             color="gray30",
             size=2.0)

cor.Vs.start


     # save plots to file pdf   - plots already saved
     
          ggsave(c(paste(new_plots,'corr_vs_start_positions_Chr22_',stand.Col.names[i],'.pdf',sep='')), plot =                   cor.Vs.start, device = NULL, path = NULL,
                  scale = 1, width = 8, height = 5, units = c("in"),
                  dpi = 300, limitsize = TRUE)

          } # end area loop i

@

\begin{figure}
\begin{center}



The next plots show for each brain area correlations plotted against starting positions for all measured genes on Chromosome 22. The dotted lines are median positive and negative correlations, and the vertical dashed line is the transcription start position for MB-{\textit {COMT}}. There do not appear to be any gaps either in the positive or the negative correlations near the position of the MB-{\textit {COMT}} gene.

\includegraphics[width=4cm, height=3cm]{corr_vs_start_positions_Chr22_Prefrontal.pdf}\vspace{3em}
\includegraphics[width=4cm, height=3cm]{corr_vs_start_positions_Chr22_Cerebellum.pdf}\vspace{3em}
\includegraphics[width=4cm, height=3cm]{corr_vs_start_positions_Chr22_Temporal.pdf}\vspace{3em}
\includegraphics[width=4cm, height=3cm]{corr_vs_start_positions_Chr22_Pons.pdf}\vspace{3em}

\end{center}
\end{figure}

<<results=tex>>=
# Use the hypergeometric distribution to determine the probability that 8 of 21 genes that were in the top 200 negatively correlated genes in Temporal Cortex on Chr 5, would also show up among the (partially different) 21 genes on Chr 5 in Prefrontal cortex.
          
# Number of genes measured in full sample on Chr 5
          
     num.Genes.neg.Chr5$total[1] <- dim(subset(prefront.Data.onegene,prefront.Data.onegene$loc == '5'))[1] 
     num.Genes.neg.Chr5$total[2] <- dim(subset(tempor.Data.onegene,tempor.Data.onegene$loc == '5'))[1]
     num.Genes.neg.Chr5$common[1] <- length(common.genes.Chr5.neg[[2]])
     num.Genes.neg.Chr5$common[2] <- length(common.genes.Chr5.neg[[2]])
     
     # Of the 20 genes in the top 200 negatively correlated genes in Prefrontal Cortex on Chromosome 5, how many of those were also measured in Temporal Cortex? In other words, if a particular gene were among the set of 20 in PfCtx, it could not possibly also be among the set of 21 in TempCtx unless it was in the set of all genes measured in TempCtx.
     
# poss.Matches shows that all 20 of the genes in the top set in PfCtx on Chr 5 were also measured in TempCtx.
          poss.Matches <- length(match(pf.Neg[5,1:20],tempor.Data.onegene$Symbol))
     
     # Genes measured in Prefrontal on Chr 5
     genes.Chr5.pf <- subset(prefront.Data.onegene,prefront.Data.onegene$loc == '5')  # n = 715
     genes.Chr5.tm <- subset(tempor.Data.onegene,tempor.Data.onegene$loc == '5')    # n = 729

# 567 genes were measured both in PfCtx and TempCtx     
     same.Measured.pftm  <- intersect(genes.Chr5.pf$Symbol,genes.Chr5.tm$Symbol)
     num.genes.Common.pftm <- length(same.Measured.pftm)   # n = 567
     
# Number of ways to choose 21 genes from 715 genes meqasured on Chr 5 in Prefrontal
     A.pf <- 20
     B.pf <- (num.Genes.neg.Chr5$total[1] - A.pf)
     k.pf <- c(8:A.pf) #number of matching genes 8 or more
     
     # num.Choose.pf = 383288337264708946651341363588328903560
     num.Choose.pf <- chooseZ((A.pf + B.pf),A.pf)
     
# Number of ways to choose 21 genes from 729 genes meqasured on Chr 5 in Temporal
     A.tm <- 21
     B.tm <- (num.Genes.neg.Chr5$total[2] - A.tm)
     k.tm <- c(8:A.tm) #number of matching genes  8 or more
     
     # num.Choose.pf = 19170760017547961871654036186294130436130
     num.Choose.tm <- chooseZ((A.tm + B.tm),A.tm)

# What is the probability that both of these samples of genes of sizes 20 and 21, respectively, would contain 8 or more genes in common? Keep in mind that while 715 genes were measured in PfCtx and 729 in TempCtx, only 567 genes were measured in both places. So there are genes that could show up in the sample of 20 from PfCtx that could not show up in the sample of 21 from TempCtx and vice versa.

     # Once the 20 have been specified from PfCtx, how many different combinations of 8 genes are possible in the set of 20 genes that were specified in PfCtx?

     # 125970 different sets of 8 genes any one of which could be the one that is also in the set of 21 from TempCtx. But it should be 8 or more.     
     comb.8ormore.20.pf <- as.bigq(chooseZ(A.pf,k.pf)) 
     
      # Once the 21 have been specified from TempCtx, how many different combinations of 8 genes are possible in the set of 21 genes that were specified in TempCtx?

     # 203490 different sets of 8 genes any one of which could be the one that is also in the set of 20 from PfCtx.     
     comb.8ormore.21.tm <- as.bigq(chooseZ(A.tm,k.tm))  
     
     # If there are 383288337264708946651341363588328903560 ways to choose 20 genes randomly from 715 genes, and if for each of these ways there are 125970 different sets of 8 genes, nnn sets of 9 genes, nnn sets of 10 genes, etc., that increases the possibility that any set of 8 or 9 or 10 etc genes will overlap in both areas because it could be this set of 8 or that set of 8 or that set of 8, etc. Therefore, multiply the probability of getting a particular set of 20 genes by the number of different sets of 8 that could match in that set. Do this for all numbers from 8 to 20 and sum the probabilities.
     
     prob.8ormore.20.matchpf <- asNumeric(sum(comb.8ormore.20.pf*(1.00/(num.Choose.pf))))
     
     # Same logic for TempCtx
     
     prob.8ormore.21.matchtm <- asNumeric(sum(comb.8ormore.21.tm*(1.00/(num.Choose.tm))))
          
@


% {\bfseries {Using the hypergeometric distribution to test for randomness in the number of probes shared in common between the reference area and another area.}}\\
% 
% Testing for probe matches between a reference and a test brain area involves the {\bfseries {hypergeometric}} distribution.\\ The computation of probabilities when sampling without replacement is based on the following pdf:
% 
% \href{http://people.wku.edu/david.neal/109/Unit2/SamplingWO.pdf}{c('MATH 109 Sampling without Replacement)}
% 
% Here is the description of the calculation: \\
% 
% {\bfseries {Sampling Without Regard to Order}}\\
% Now  suppose  we  have  a  population  of N elements  that  are  divided  into  two  types: Type I  which has A elements,  and Type II which has B elements, where $A + B == N$.\\  
% 
% For  example,  a  standard  deck  of  $N == 52$  playing  cards  can  be  divided  in  many  ways. Type  I  could  be  “Hearts”  and  Type  II    could  be  “All  Others.”    Then  there  are   $A == 13$ Hearts and  $B == 39$ Others.\\
% 
% In analogy to the genes/probes problem, $N == 20,000$ probes,  $A == 50$ or 200, as in the top 50 or the top 200 most strongly positively/negatively {\textit {COMT}}-correlated probes. Thus B is either 19,950 ($A == 50 $) or B is 19,800 ( $A == 200$). 
% 
% There are two other parameters: $n == $the number of probes randomnly sampled without replacement, and  $k = $ the number of negatively correlated genes in the sample of size n that also are contained in A. The calculation for the probability that a sample of size n will contain k negatively correlated genes:\\
% $$
% p = \frac{\binom{A,k}*\binom{B,(n-k)}}{\binom{N,n}}
% $$


<<include=FALSE, echo=FALSE, results=tex>>=
################################################
### Select the top 200 by p-value to determine which genes expression levels (by chromosome) are most highly correlated with COMT expression.
################################################


# These are ordered by pvalue regardless of sign
data.by.Pval.area <- list()
data.by.Pval.area[[1]] <- gene.Major[[1]][order(gene.Major[[1]]$Sample.p.r.,decreasing=FALSE),]
data.by.Pval.area[[2]] <- gene.Major[[2]][order(gene.Major[[2]]$Sample.p.r.,decreasing=FALSE),]
data.by.Pval.area[[3]] <- gene.Major[[3]][order(gene.Major[[3]]$Sample.p.r.,decreasing=FALSE),]
data.by.Pval.area[[4]] <- gene.Major[[4]][order(gene.Major[[4]]$Sample.p.r.,decreasing=FALSE),]

n <- c(500)     # sample of 500 genes

summ.Sign.area <- matrix(rep(0,32),nrow=8)
summ.Sign.area <- data.frame(summ.Sign.area) 
colnames(summ.Sign.area) <- stand.Col.names

summ.Sign.area[3,] <- c(n)

mdat <- matrix(c(rep(0,(3*5)),0,rep(3,4),rep(0,(2*5)),0,rep(3,(1*4)),
                 0,rep(3,(1*4))),
                 nrow = 8, ncol=5, byrow=TRUE)


# summ.Sign.area <- data.frame(samp=rep(0,4),
#                              expect=rep(0,4),
#                              size=rep(200,4),
#                              prop.samp=rep(0,4),
#                              num.neg=rep(0,4),
#                              total=rep(0,4),
#                              prop.total=rep(0,4),
#                              Pval=rep(0,4))

# For each brain area, use the hypergeometric distribution to determine the probability of obtaining
# the observed number of negative correlations (or fewere) given the proportion of negative 
# correlations in the complete sample

for (j in ib)    {
     
     if (exists('prob.N')) {rm(prob.N)}

     ############ DEBUG
#     j <- c(1)
     ##################
          
total.Corsign.tab <- table(data.by.Pval.area[[j]]$corsign)
samp.Corsign.tab <- table(data.by.Pval.area[[j]]$corsign[1:n])

summ.Sign.area[1,j] <- samp.Corsign.tab[1]     # samp
summ.Sign.area[5,j] <- total.Corsign.tab[1]    # num.neg
summ.Sign.area[4,j] <- round(samp.Corsign.tab[1]/summ.Sign.area[3,j],3)


# Sampling without replacement

     num.Genes <- length(data.by.Pval.area[[j]]$Symbol)
     summ.Sign.area[6,j] <- num.Genes
     N <- num.Genes
     A <- total.Corsign.tab[1]   # number of genes with negative correlations in full sample
     B <- N - A         # number of genes with positive correlations

     summ.Sign.area[7,j] <- round(summ.Sign.area[5,j]/summ.Sign.area[6,j],3)
     summ.Sign.area[2,j] <- round(summ.Sign.area[3,j]*summ.Sign.area[7,j],1)
     

# prob.N will hold the discrete probability distribution for k matches from a sample size of n = 500.


#     prob.N[k+1] <- (chooseMpfr(A,k)*chooseMpfr(B,(n-k)))/chooseMpfr(N,n)
     
     # Use built in hypergeometric distribution in R
     prob.N <- log10(phyper(samp.Corsign.tab[1],A,B,n,lower.tail=TRUE,log.p=FALSE))

summ.Sign.area[8,j] <- prob.N

} #end brain area loop

row.names(summ.Sign.area) <- c('Number of negative correlations',
                              'Expected number of negative correlations',
                              'Sample size',
                              'Proportion of negative correlations: sample',
                              'Total number of negative correlations',
                              'Total number of genes',
                              'Proportion negative correlations: total',
                              'Log10(probability)')

summ.Sign.area.tab <- xtable(summ.Sign.area,
                             caption=c(paste('Observed, expected number of negative correlations and associated hypergeometric p-values by brain area for the 200 genes whose '," \\textit{COMT}",
' expression correlations had the smallest p values.',sep='')),
                             digits=mdat,
                              label=c('tab:hypergeom'))

# the table has been saved
print.xtable(summ.Sign.area.tab,
                         file=paste('top_500_ranked_by_pval_hypergeom.tex',sep=''),
                         type='latex',
                         floating=FALSE,
                         caption.placement='top',
                         tabular.environment='longtable',
                         caption.width ='0.5\\textwidth',
                         hline.after=c(-1,0,nrow(summ.Sign.area.tab)),
                         include.rownames=TRUE,
                         print.results=TRUE,
                         booktabs=TRUE,
                         comment=TRUE,
                         digits=mdat
                         )


@

The analysis of the proportion of negative correlations among the 500 genes with the smallest p-values showed that for all four brain areas, the observed number of negative correlations was significantly smaller (all p-values $< 10^{-30}$) than would have been expected based on the proportion of negative p-values in the total sample. In fact, while approximately 62\% of the correlations in the complete sample (gene as unit) were negative, no more than 22\% of the correlations were negative among the 500 genes whose correlations with MB-{\textit {COMT}} were largest.\\

This is in keeping with previous work that has shown that the strongest co-expressed genes tend to have positive correlations (need ref).\\

<<change.sign>>=
# Do any of the genes in the top 500 change sign between brain areas?

# For genes that are in common between pairs of brain areas, what is the rank order correlation between their COMT expression correlations. In other words, if a gene shows up in the top 500 in Prefrontal cortex, with a high positive correlation, and it also shows up in Cerebellum, is its correlation also high and positive?

sign.Diffs <- list()
rank.order.corrs <- list()
rank.order.stats <- data.frame(compare=c('PFCtx vs. Cereb',
                                         'PFCtx vs. TemCtx',
                                         'PFCtx vs. Pons',
                                         'Cereb vs. TemCtx',
                                         'Cereb vs. Pons',
                                         'TemCtx vs. Pons'),
                             n=rep(NA,6),
                             rho=rep(NA,6),
                             pvalue=rep(NA,6))

comp.indx <- matrix(c(1,2,
                    1,3,
                    1,4,
                    2,3,
                    2,4,
                    3,4), ncol=2,byrow=TRUE)

for (kl in 1:dim(comp.indx)[1])   {


     same.symbols <- match(hold.Lowest.pvals[[comp.indx[kl,1]]]$Symbol,hold.Lowest.pvals[[comp.indx[kl,2]]]$Symbol)

     tempa.indx <- which(!is.na(same.symbols))
     tempb.indx <- na.omit(same.symbols)
     
     comp.signs <- data.frame(signA=hold.Lowest.pvals[[comp.indx[kl,1]]]$corsign[c(tempa.indx)],signB=hold.Lowest.pvals[[comp.indx[kl,2]]]$corsign[c(tempb.indx)])
     
     comp.corrs <- data.frame(rA=hold.Lowest.pvals[[comp.indx[kl,1]]]$Sample.r[c(tempa.indx)],rB=hold.Lowest.pvals[[comp.indx[kl,2]]]$Sample.r[c(tempb.indx)])
     
     rank.order.corrs[[kl]] <- cor.test(comp.corrs$rA,comp.corrs$rB,method='spearman')
     
     sign.Diffs[[kl]] <- which(comp.signs$signA != comp.signs$signB)
     
     rank.order.stats[kl,2:4] <- c(round(length(comp.corrs$rA),0),
                                   round(rank.order.corrs[[kl]]$estimate,3),
                                   round(rank.order.corrs[[kl]]$p.value,11)
                                         )
}

rank.order.stats.tab <- print.xtable(xtable(rank.order.stats,
                               caption=c('Rank order correlations between the expression level correlations for genes shared between pairs of brain areas. The determination of which genes were \"shared\" between pairs of brain areas was restricted to the 500 most strongly COMT-correlated genes in each brain area.'),
                               include.rownames=FALSE,
                               digits=c(0,0,0,3,11),
                               print.results=TRUE))


numworking.genes.by.area <- matrix(lapply(gene.Major[ib], function(x,ib) dim(x)[1], ib),ncol=1)


colnames(numworking.genes.by.area) <- c('Number of Genes')
row.names(numworking.genes.by.area) <- stand.Col.names

xtable(numworking.genes.by.area,
       caption=c('Number of Genes with COMT Expression Correlations'),
       digits=0)

@

There are no genes in the top 500 in each brain area that change the sign of correlation between two different brain areas. In other words, if a strongly correlated gene in Prefrontal Cortex has expression levels that are positively correlated with COMT, then if that gene is also among the top 500 genes in Cerebellum, its correlation sign will also be positive.\\

Additionally, for the genes that are in common between two brain areas in their respective sets of 500 most strongly correlated genes, the rank order correlation between their expression correlations with COMT are significantly positive for all pairwise comparisons between brain areas.\\



<<results=hide>>=
# Get the distributions of + and - correlations, positive-only, and negative-only for the 
# onegene data by brain area

stand.Col.names.aug <- c(paste(stand.Col.names[1],' Cortex',sep=''),
                         paste(stand.Col.names[2],'',sep=''),
                         paste(stand.Col.names[3],' Cortex',sep=''),
                         paste(stand.Col.names[4],'',sep=''))


#for (b in 1:4)   {
     
     ############## DEBUG
     b <- c(1)
     ####################

 phisto <- ggplot(data=area.onegene.List[[b]], aes(as.numeric(area.onegene.List[[b]]$Sample.r))) +    #          geom_density(stat='density',fill='gray90') +
          
          
          stat_density(data = area.onegene.List[[b]], 
                       aes(as.numeric(area.onegene.List[[b]]$Sample.r)),geom = "area",
                       position = "stack", ..., bw = "nrd0", adjust = 1, kernel = "gaussian",
                       n = 1024, trim = FALSE, na.rm = FALSE, show.legend = NA,
                       inherit.aes = TRUE) +
    
     scale_x_continuous(name=c(paste("Correlation of expression with "," \\textit{COMT}",sep='')),
                               limits=c(-1.0,1.0)) +
          
     theme_bw() +
     theme(strip.background=element_rect(fill="gray70")) +
     theme(strip.text = element_text(colour = 'black')) +
     
     labs(x = c(paste("Correlation of expression with "," \\textit{COMT}",sep='')),
          y = c('Frequency'),
          title = c(paste('Distribution of Correlation Coefficients in ',stand.Col.names.aug[b],sep=''))) +
     theme(axis.text=element_text(size=7),
        axis.title=element_text(size=9)) +
     theme(plot.title=element_text(size=10,
                                   hjust=0.5)) 
          
          # annotate("text", x = 0.90*as.numeric(prefront.Data$bp[1]),
          #    y = c(28),
          #    label = "MB-italic(COMT)", 
          #    parse=TRUE,
          #    color="black",
          #    size=2)
     
     phisto

#} # end area loop

# phista
     # save plots to file
     
     # hist.22 <- paste('histogram_start_positions_Chr22_',stand.Col.names[i],'.eps',sep='')
     #      setEPS()
     #      postscript(hist.22,width=8,height=6)
     #      phista
     #      dev.off()







@


<<label=top10percent, echo=FALSE, results=tex>>=
################################################
### Select the top 200 by p-value to determine which genes expression levels (by chromosome) are most highly correlated with COMT expression.
### Done separately for positive and negative correlations
################################################

total.Corsign.tab <- table(prefront.by.Pval$corsign)
samp.Corsign.tab <- table(prefront.by.Pval$corsign[1:200]) 



##### Positive correlations with COMT expression only #####################
full.Count <- table(manhat.Posr$CHR)
order.by.P.pos <- manhat.Posr[order(manhat.Posr$P), ]
num.Pos <- dim(order.by.P.pos)[1]
ten.percent.Pos <- floor(0.10*num.Pos)
top.10percent.pos <- order.by.P.pos[1:ten.percent.Pos, ]
top10.pos.Count <- table(top.10percent.pos[,1])

# scaled.Props <- as.numeric(full.Count)/num.Pos
# scaled.top10.Props <- as.numeric(top10.pos.Count)/sum(as.numeric(top10.pos.Count))

## This scales the number of probes in the top 10% inversely by the fitted number of probes from the regression of number of probes by chromosome length. It also preserves the absolute number of probes found in the top 10% (~886)
fit.inverse.Scaled <- as.numeric(top10.pos.Count)/(adjust.By.fit[1:23]/sum(adjust.By.fit[1:23]))
fit.inverse.Scaled <- round((fit.inverse.Scaled*(sum(top10.pos.Count)/sum(fit.inverse.Scaled))),0)


# ratio.top10.pos <- data.frame(ratio=scaled.top10.Props/scaled.Props[1:23])
# ratio.top10.pos$chr <- c(1:23)
# ratio.top10.pos <- ratio.top10.pos[c(2,1)]
# scaled.Ratio <- data.frame(prop=ratio.top10.pos[,2]/sum(ratio.top10.pos[,2]))
# scaled.Ratio$chr <- c(1:23)
# scaled.Ratio$chr <- scaled.Ratio[c(2,1)]
# 
# num2get <- top10.pos.Count*scaled.Ratio$prop
num2get2 <- data.frame(n = as.numeric(fit.inverse.Scaled))
num2get2$chr <- as.numeric(c(1:23))
num2get2 <- num2get2[c(2,1)]

hold.pos <- data.frame(CHR=rep(NA,sum(num2get2$n)),
                       BP=rep(NA,sum(num2get2$n)),
                       P=rep(NA,sum(num2get2$n)),
                       GENE=rep(NA,sum(num2get2$n))
)
hold.pos$GENE <- as.character(hold.pos$GENE)
hold.pos$CHR <- as.numeric(hold.pos$CHR)
hold.pos$P <- as.numeric(hold.pos$P)

### hold.pos holds the top 883 positively correlated genes inversely weighted for the number of probes per # chromosome
### So the choice of the top genes is within chromosome, but the number of genes is inversely normalized by the fitted number of probes for that chromosome as regressed against chromosome length as well as the absolute rank of those genes against all the other genes
lims.Count <- matrix(c(0,0),nrow=1)                               
for (ig in 1:23) {
  lims.Count[1] <- lims.Count[2] + 1
  lims.Count[2] <- lims.Count[1] + num2get2$n[ig] - 1
  hold.pos[lims.Count[1]:lims.Count[2],1:4] <-data.frame(subset(manhat.Posr,manhat.Posr$CHR == ig)[1:num2get2$n[ig], ])
}

colnames(hold.pos) <- c('CHR','BP','P','GENE')

### Put this into a latex table sorted by chromosome number

top.Pos.ltx <- latex(hold.pos,file='top.Pos_genes.tex',
                      insert.top=('Top positively correlated genes normalized for number of probes per chromosome ordered by P value within chromosome'),
                      booktabs=TRUE,
                      label=c('top.Pos'),
#                      cgroup = c('Genes'),
#                      n.cgroup = c(4),
                      na.blank = TRUE,
                      vbar = FALSE,
                      longtable=TRUE,
                      table.env=FALSE,
                      continued=c('Top positively correlated genes continued'),
                      first.hline.double = TRUE,
                      size=c('tiny'),
                      append=FALSE
                      )
top.Pos.ltx

### Put this into a latex table sorted by p-value
hold.pos.byP <- hold.pos[order(hold.pos$P),]
hold.pos.byP$GENE <- as.character(hold.pos.byP$GENE)

top.PosbyP.ltx <- latex(hold.pos.byP,file='top.Pos_genes_by_P.tex',
                      insert.top=('Top positively correlated genes normalized for number of probes per chromosome ordered by P-value'),
                      booktabs=TRUE,
                      label=c('top.PosP'),
#                      cgroup = c('Genes'),
#                      n.cgroup = c(4),
                      na.blank = TRUE,
                      vbar = FALSE,
                      longtable=TRUE,
                      table.env=FALSE,
                      continued=c('Top positively correlated genes continued'),
                      first.hline.double = TRUE,
                      size=c('tiny'),
                      append=FALSE
                      )
top.PosbyP.ltx

############ End positive only ########################
  
##### Negative correlations with COMT expression only #####################
full.Count <- table(manhat.Negr$CHR)
order.by.P.neg <- manhat.Negr[order(manhat.Negr$P), ]
num.Neg <- dim(order.by.P.neg)[1]
ten.percent.Neg <- floor(0.10*num.Neg)
top.10percent.neg <- order.by.P.neg[1:ten.percent.Neg, ]
top10.neg.Count <- table(top.10percent.neg[,1])

scaled.Props <- as.numeric(full.Count)/num.Pos
scaled.top10.Props <- as.numeric(top10.neg.Count)/sum(as.numeric(top10.neg.Count))

## This scales the number of probes in the top 10% inversely by the fitted number of probes from the regression of number of probes by chromosome length. It also preserves the absolute number of probes found in the top 10% (~886)
fit.inverse.Scaled <- as.numeric(top10.neg.Count)/(adjust.By.fit[1:23]/sum(adjust.By.fit[1:23]))
fit.inverse.Scaled <- round((fit.inverse.Scaled*(sum(top10.neg.Count)/sum(fit.inverse.Scaled))),0)


# ratio.top10.neg <- data.frame(ratio=scaled.top10.Props/scaled.Props[1:23])
# ratio.top10.neg$chr <- c(1:23)
# ratio.top10.neg <- ratio.top10.neg[c(2,1)]
# scaled.Ratio <- data.frame(prop=ratio.top10.neg[,2]/sum(ratio.top10.neg[,2]))
# scaled.Ratio$chr <- c(1:23)
# scaled.Ratio <- scaled.Ratio[c(2,1)]
# 
# num2get <- top10.neg.Count*scaled.Ratio$prop
num2get2 <- data.frame(n = as.numeric(fit.inverse.Scaled))
num2get2$chr <- as.numeric(c(1:23))
num2get2 <- num2get2[c(2,1)]

hold.neg <- data.frame(CHR=rep(NA,sum(num2get2$n)),
                               BP=rep(NA,sum(num2get2$n)),
                               P=rep(NA,sum(num2get2$n)),
                               GENE=rep(NA,sum(num2get2$n))
)
hold.neg$GENE <- as.character(hold.neg$GENE)
manhat.Negr$GENE <- as.character(manhat.Negr$GENE)
hold.neg$CHR <- as.numeric(hold.neg$CHR)
hold.neg$P <- as.numeric(hold.neg$P)

### hold.neg holds the top 909 positively correlated genes weighted inversely for the number of probes per chromosome as determined from the fitted value when number of probes is regressed against chr length.
### So the choice of the top genes is within chromosome, but the number of genes inversely reflects the fitted number of probes used for that chromosome as well as the absolute rank of those genes against all the other genes
lims.Count <- matrix(c(0,0),nrow=1)                               
for (ig in 1:23) {
  lims.Count[1] <- lims.Count[2] + 1
  lims.Count[2] <- lims.Count[1] + num2get2$n[ig] - 1
  hold.neg[lims.Count[1]:lims.Count[2],1:4 ] <-data.frame(subset(manhat.Negr,manhat.Negr$CHR == ig)[1:num2get2$n[ig], ])
}

colnames(hold.neg) <- c('CHR','BP','P','GENE')


### Put this into a latex table sorted by chromosome number
top.Neg.ltx <- latex(hold.neg,file='top.Neg_genes.tex',
                      insert.top=('Top negatively correlated genes normalized for number of probes per chromosome ordered by P-value within chromosome'),
                      booktabs=TRUE,
                      label=c('top.Neg'),
#                      cgroup = c('Genes'),
#                      n.cgroup = c(4),
                      na.blank = TRUE,
                      vbar = FALSE,
                      longtable=TRUE,
                      table.env=FALSE,
                      continued=c('Top negatively correlated genes continued'),
                      first.hline.double = TRUE,
                      size=c('tiny'),
                      append=FALSE
                      )
top.Neg.ltx

### Put this into a latex table sorted by p-value
hold.neg.byP <- hold.neg[order(hold.neg$P),]
hold.neg.byP$GENE <- as.character(hold.neg.byP$GENE)

top.NegbyP.ltx <- latex(hold.neg.byP,file='top.Neg_genes_by_P.tex',
                      insert.top=('Top negatively correlated genes normalized for number of probes per chromosome ordered by P-value'),
                      booktabs=TRUE,
                      label=c('top.NegP'),
#                      cgroup = c('Genes'),
#                      n.cgroup = c(4),
                      na.blank = TRUE,
                      vbar = FALSE,
                      longtable=TRUE,
                      table.env=FALSE,
                      continued=c('Top positively correlated genes continued'),
                      first.hline.double = TRUE,
                      size=c('tiny'),
                      append=FALSE
                      )
top.NegbyP.ltx

############ End negative only ########################

@


<<include=FALSE, echo=FALSE, results=tex>>=
dim.areas <- matrix(c(dim(prefront.Data)[1],
                    dim(cbell.Data)[1],
                    dim(tempor.Data)[1],
                    dim(pons.Data)[1]),
                    nrow=4)

have.ENTREZ <- data.frame(indpf=c(1:dim.areas[1]),
                          ENTREZIDpf=rep(NA,dim.areas[1]),
                          ILMNpf=prefront.Data$Record,
                          indcb=c(1:dim.areas[1]),
                          ENTREZIDcb=rep(NA,dim.areas[2]),
                          ILMNcb=cbell.Data$Record,
                          indtm=c(1:dim.areas[1]),
                          ENTREZIDtm=rep(NA,dim.areas[3]),
                          ILMNtm=tempor.Data$Record,
                          indpo=c(1:dim.areas[1]),
                          ENTREZIDpo=rep(NA,dim.areas[4]),
                          ILMNpo=pons.Data$Record
                          )

# First determine which rows have the loc(Chromosome) listed as 'Un'. That is done below with
# the variables where.Un.pf, where.Un.cb, where.Un.tm, where.Un.po

# On an area by area basis separately, retrieve the ENTREZIDs for each Illumina probe.
have.Ent.pf <-na.omit(unlist(mget(x = prefront.Data$Record,envir=illuminaHumanv2ENTREZID)))   # n = 18724 of 20,000
have.Ent.cb <- na.omit(unlist(mget(x = cbell.Data$Record,envir=illuminaHumanv2ENTREZID)))      # n = 18726 of 20,000
have.Ent.tm <- na.omit(unlist(mget(x = tempor.Data$Record,envir=illuminaHumanv2ENTREZID)))     # n = 18698 of 20,000
have.Ent.po <- na.omit(unlist(mget(x = pons.Data$Record,envir=illuminaHumanv2ENTREZID)))       # n = 18713 of 20,000

# eliminate duplicates - these vectors show the unique ENTREZIDs in each brain area's data
# There are duplicates because there can be multiple ILMN probes for the same gene (ENTREZID)

############# Don't eliminate duplicates because the retention of rows will be done on the basis
############# of Illumina probe IDs which are unique
# notdups.pf <- which(!duplicated(have.Ent.pf))
# have.Ent.pf <- have.Ent.pf[c(notdups.pf),1]     
# 
# notdups.cb <- which(!duplicated(have.Ent.cb))
# have.Ent.cb <- have.Ent.cb[c(notdups.cb),1]
# 
# notdups.tm <- which(!duplicated(have.Ent.tm))
# have.Ent.tm <- have.Ent.tm[c(notdups.tm),1]
# 
# notdups.po <- which(!duplicated(have.Ent.po))
# have.Ent.po <- have.Ent.po[c(notdups.po),1]

entrez.By.area <- data.frame(num.entrez=c(length(have.Ent.pf),
                                          length(have.Ent.cb),
                                          length(have.Ent.tm),
                                          length(have.Ent.po)),
                             miss.entrez=c((20000 - length(have.Ent.pf)),
                                           (20000 -length(have.Ent.cb)),
                                           (20000 -length(have.Ent.tm)),
                                           (20000 -length(have.Ent.po)))
)

colnames(entrez.By.area) <- c('Number of Rows with ENTREZIDs','Number of Rows Missing ENTREZIDs')
row.names(entrez.By.area) <- c('Prefrontal Cortex',
                              'Cerebellum',
                              'Temporal Cortical Wall',
                              'Pons')

entrez.Area.tab <- xtable(entrez.By.area,
                         caption='Number of Unique ENTREZIDs in the Expression data\n for Each Brain Area. ENTREZIDs retrieved using ILMN identifiers.')

print(entrez.Area.tab)
@

\Sexpr{entrez.Area.tab}\\


<<include=FALSE, echo=FALSE, results=tex>>=

# The vectors above hold only the rows with ENTREZIDs in each area.
# NAs have been eliminated, and there are no duplicates.

# Attach a column with the ENTREZIDs to each of the 20,000 rows data frames
# Don't eliminate the NAs
prefront.Data$ENTREZID <- unlist(mget(x = prefront.Data$Record,envir=illuminaHumanv2ENTREZID))   # n = 18724 without NA; 1276 with NA
cbell.Data$ENTREZID <- unlist(mget(x = cbell.Data$Record,envir=illuminaHumanv2ENTREZID))      # n = 18726 withput NA, 1274 with NA
tempor.Data$ENTREZID <- unlist(mget(x = tempor.Data$Record,envir=illuminaHumanv2ENTREZID))     # n = 18698 without NA, 1302 with NA
pons.Data$ENTREZID <- unlist(mget(x = pons.Data$Record,envir=illuminaHumanv2ENTREZID))       # n = 18713 without NA, 1287 with NA

# Use the Illumina Human ref 8 v 2 bead chip reference file to try to find additional ENTREZIDs
# data.frame illumina.Data

# Get the list of ILMN probes for each data.frame that do not have ENTREZIDs
no.Entrez.pf <- prefront.Data$Record[c(which(is.na(prefront.Data$ENTREZID)))]
no.Entrez.pf.indx <- which(is.na(prefront.Data$ENTREZID))

no.Entrez.cb <- cbell.Data$Record[c(which(is.na(cbell.Data$ENTREZID)))]
no.Entrez.cb.indx <- which(is.na(cbell.Data$ENTREZID))

no.Entrez.tm <- tempor.Data$Record[c(which(is.na(tempor.Data$ENTREZID)))]
no.Entrez.tm.indx <- which(is.na(tempor.Data$ENTREZID))

no.Entrez.po <- pons.Data$Record[c(which(is.na(pons.Data$ENTREZID)))]
no.Entrez.po.indx <- which(is.na(pons.Data$ENTREZID))

# Get the indices in the illumina.Data$ilmn vector for which the entry matches a probe in 
# no.Entrez.xx that does not have an ENTREZID attached

extra.ILMN.pf <- match(no.Entrez.pf,illumina.Data$ilmn)
extra.ILMN.cb <- match(no.Entrez.cb,illumina.Data$ilmn)
extra.ILMN.tm <- match(no.Entrez.tm,illumina.Data$ilmn)
extra.ILMN.po <- match(no.Entrez.po,illumina.Data$ilmn)


# The lengths of these vactors show that every ILMN with a missing ENTREZID has a match
# in the ilumina.Data$ilmn vector. This doesn't necessarily mean that the ENTREZID is there
# as well

# These hold the ENTREZIDs that were missing from the original data set, but were found in the Illumina data set
extra.Entrez.pf <- illumina.Data$entrez[c(extra.ILMN.pf)]
# num.NA(extra.Entrez.pf) = 0; all of the missing ENTREZIDs were recovered for prefrontal
extra.Entrez.cb <- illumina.Data$entrez[c(extra.ILMN.cb)]
# num.NA(extra.Entrez.cb) = 0; all of the missing ENTREZIDs were recovered for cerebellum
extra.Entrez.tm <- illumina.Data$entrez[c(extra.ILMN.tm)]
# num.NA(extra.Entrez.cb) # = 0; all of the missing ENTREZIDs were recovered for temporal
extra.Entrez.po <- illumina.Data$entrez[c(extra.ILMN.po)]
# num.NA(extra.Entrez.cb) # = 0; all of the missing ENTREZIDs were recovered for pons

# a. Set up a correspondence matrix that holds the index in the Illumina file of the probes for which there was not an ENTREZID in the <area>.Data$ENTREZID column
# b. With the index in the Illumina data file that has a probe ID that matches one listed as not having an ENTREZID (a.)
correspond.Data.ILMN.pf <- matrix(c(no.Entrez.pf.indx,extra.ILMN.pf),
                               ncol=2)
correspond.Data.ILMN.cb <- matrix(c(no.Entrez.cb.indx,extra.ILMN.cb),
                               ncol=2)
correspond.Data.ILMN.tm <- matrix(c(no.Entrez.tm.indx,extra.ILMN.tm),
                               ncol=2)
correspond.Data.ILMN.po <- matrix(c(no.Entrez.po.indx,extra.ILMN.po),
                               ncol=2)
corresp.Data.ILM <- list(correspond.Data.ILMN.pf,
                         correspond.Data.ILMN.cb,
                         correspond.Data.ILMN.tm,
                         correspond.Data.ILMN.po)


# For example, corresp.Data.ILM[[1]][1,1] = 7
# corresp.Data.ILM[[1]][1,2] = 6147
# Thus, prefront.Data$ENTREZID[7] has an ILMN of "ILMN_1683883" and is missing and ENTREZID
# illumina.Data[6147,] has an ILMN of "ILMN_1683883" and it has a corresponding entrez = 95
# The illumina.Data$entrez[6147] = 95 can be used to fill in the missing ENTREZID in
# prefront.Data$ENTREZID[7]

# use the indices in extra.ILMN.xx to fill in the missing ENTREZID values
#Both sides have lengths of 20000. There are NAs in te ENTREZID columns
prefront.Data$ENTREZID <- as.character(prefront.Data$ENTREZID)
illumina.Data$entrez <- as.character(illumina.Data$entrez)

prefront.Data$ENTREZID[c(corresp.Data.ILM[[1]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[1]][,2])]

cbell.Data$ENTREZID <- as.character(cbell.Data$ENTREZID)
cbell.Data$ENTREZID[c(corresp.Data.ILM[[2]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[2]][,2])]

tempor.Data$ENTREZID <- as.character(tempor.Data$ENTREZID)
tempor.Data$ENTREZID[c(corresp.Data.ILM[[3]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[3]][,2])]

pons.Data$ENTREZID <- as.character(pons.Data$ENTREZID)
pons.Data$ENTREZID[c(corresp.Data.ILM[[4]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[4]][,2])]

# All 20,000 rows in each areal data.frame have ENTREZIDs (no NAs)
# This means also that all Illumina probe IDs also have identifiers that are mapped to a gene (ENTREZID)
# All of the ENTREZIDs are unique - not duplicated.
# This doesn't mean that the set of ENTREZIDs for each <area>.Data data.frame is the same
# In other words, because the <area>.Data correlation files with 20,000 correlations were
# obtained ranked by the p-values of the correlations, and because there are more than
# 20,000 Illumina probes, the sets of probes do not have to correspond
num.NA(prefront.Data$ENTREZID)    # n = 510 NA
num.NA(cbell.Data$ENTREZID)   # n = 229 NA
num.NA(tempor.Data$ENTREZID)  # n = 45 NA
num.NA(pons.Data$ENTREZID)    # n = 237 NA


# Next, intersect on the basis of ENTREZID (which is necessary to look up missing chromosomes;
# the ones that are listed as 'Un'). This will store only the ENTREZIDs that are in common
# across all four brain areas


all.areas.ENTREZID <- intersect(pons.Data$ENTREZID,intersect(tempor.Data$ENTREZID,intersect(prefront.Data$ENTREZID,cbell.Data$ENTREZID)))    # length = 13027

# all.areas.ENTREZID now holds all of the ENTREZIDs shared across all four brain areas


# Before finding the set of common Illumina probes across all areas, first try to find the 
# missing Chromosomes for each <area>.Data separately.
# Leverage the fact that the set of Illumina probes differs across areas, and some could be
# missing a chromosome name in one area while the same probe has the Chromosome in another area.

# Get the union of all Illumina probes across areas. First extract the probes, entrezids 
# and chromosomes into a data frame for each area

illum.entr.chr.pf <- data.frame(illum=prefront.Data$Record,
                                entrez=prefront.Data$ENTREZID,
                                chr=prefront.Data$loc)
illum.entr.chr.cb <- data.frame(illum=cbell.Data$Record,
                                entrez=cbell.Data$ENTREZID,
                                chr=cbell.Data$loc)
illum.entr.chr.tm <- data.frame(illum=tempor.Data$Record,
                                entrez=tempor.Data$ENTREZID,
                                chr=tempor.Data$loc)
illum.entr.chr.po <- data.frame(illum=pons.Data$Record,
                                entrez=pons.Data$ENTREZID,
                                chr=pons.Data$loc)

# Next get the union of all Illumina probes across the four areas

union.Illum.pfcb <- union(illum.entr.chr.pf$illum,illum.entr.chr.cb$illum)   # length 22016
union.Illum.pfcbtm <- union(union.Illum.pfcb,illum.entr.chr.tm$illum)     # length 22151
union.Illum.all <- union(union.Illum.pfcbtm,illum.entr.chr.po$illum)   # length 22180
# There are 22180 different probes across all four areas

diff.Probe.num <- matrix(c(rep(0,6)),nrow=6)
# Get the number of probe differences between each area
diff.Probe.num[1] <- length(setdiff(illum.entr.chr.pf$illum,illum.entr.chr.cb$illum))
diff.Probe.num[2] <- length(setdiff(illum.entr.chr.pf$illum,illum.entr.chr.tm$illum))
diff.Probe.num[3] <- length(setdiff(illum.entr.chr.pf$illum,illum.entr.chr.po$illum))
diff.Probe.num[4] <- length(setdiff(illum.entr.chr.cb$illum,illum.entr.chr.tm$illum))
diff.Probe.num[5] <- length(setdiff(illum.entr.chr.cb$illum,illum.entr.chr.po$illum))
diff.Probe.num[6] <- length(setdiff(illum.entr.chr.tm$illum,illum.entr.chr.po$illum))

row.names(diff.Probe.num) <- c('Prefrontal Cortex vs. Ceberebellum',
                               'Prefrontal Cortex vs. Temporal Cerebral Wall',
                               'Prefrontal Cortex vs. Pons',
                               'Cerebellum vs. Temporal Cerebral Wall',
                               'Cerebellum vs. Pons',
                               'Temporal Cerebral Wall vs. Pons'
                               )
colnames(diff.Probe.num) <- c('Number of Illumina Probe Differences')

diff.Probe.tab <- xtable(diff.Probe.num,
                         caption='Number of Illumina Probe Differences Between Brain Areas:\n Base of 20,000 Probes per Area',digits=0)

print(diff.Probe.tab)

@

\Sexpr{diff.Probe.tab}\\


<<include=FALSE,echo=FALSE,results=tex>>=
############# ********** Compare the top 50 and top 200 +/- correlations in Prefrontal with those
### in the other three areas






@


<<echo=FALSE, include=FALSE, results=hide>>=
### Create a data.frame with all areas, but only those variables necessary to find the top N genes averaged across all four areas. Use Alexander's (1990) method for averaging correlations.

### The relevant variables are:
#### area: prefront, cbell, tempcort, pons
#### Chr number
#### Gene Symbol
#### Correlation of expression with COMT expressiomn in that area
#### P-value of correlation

# dimensions of data sets
dim.Area <- data.frame(area=c('prefront', 'cbell','tempor','pons'),
                       len=rep(0,4), wid=rep(0,4))
# prefrontal
dim.Area$len[1] <- dim(prefront.Meanbothr)[1]
dim.Area$wid[1] <- dim(prefront.Meanbothr)[2]

#cerebellum
dim.Area$len[2] <- dim(cbell.Data)[1]
dim.Area$wid[2] <- dim(cbell.Data)[2]

#temporal cortex
dim.Area$len[3] <- dim(tempor.Data)[1]
dim.Area$wid[3] <- dim(tempor.Data)[2]

#pons
dim.Area$len[4] <- dim(pons.Data)[1]
dim.Area$wid[4] <- dim(pons.Data)[2]

@

<<include=FALSE,echo=FALSE,results=hide>>=

all.Area.dat <- data.frame(areapf=rep(NA,dim.Area$len[1]),
                           chrpf=rep(NA,dim.Area$len[1]),
                           genepf=rep(NA,dim.Area$len[1]),
                           corrpf=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpf=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpf=rep(NA,dim.Area$len[1]),
                           areacb=rep(NA,dim.Area$len[1]),
                           chrcb=rep(NA,dim.Area$len[1]),
                           genecb=rep(NA,dim.Area$len[1]),
                           corrcb=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalcb=as.numeric(rep(NA,dim.Area$len[1])),
                           illumcb=rep(NA,dim.Area$len[1]),
                           areatc=rep(NA,dim.Area$len[1]),
                           chrtc=rep(NA,dim.Area$len[1]),
                           genetc=rep(NA,dim.Area$len[1]),
                           corrtc=as.numeric(rep(NA,dim.Area$len[1])),
                           pvaltc=as.numeric(rep(NA,dim.Area$len[1])),
                           illumtc=rep(NA,dim.Area$len[1]),
                           areapo=rep(NA,dim.Area$len[1]),
                           chrpo=rep(NA,dim.Area$len[1]),
                           genepo=rep(NA,dim.Area$len[1]),
                           corrpo=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpo=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpo=rep(NA,dim.Area$len[1])
                           )




prefront.Ess <- data.frame(area=rep('prefront',dim.Area$len[1]),
                      loc=prefront.Meanbothr$chr,
                      Symbol=prefront.Meanbothr$gene,
                      Sample.r=prefront.Meanbothr$corr,
                      Sample.p.r=prefront.Meanbothr$pval,
                      Record=prefront.Meanbothr$record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(prefront.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
prefront.Ess <- prefront.Ess[c(sort.Ind$ix),]


cbell.Ess <- data.frame(area=rep('cbell',dim.Area$len[1]),
                      loc=cbell.Data$loc,
                      Symbol=cbell.Data$Symbol,
                      Sample.r=cbell.Data$Sample.r,
                      Sample.p.r=cbell.Data$Sample.p.r.,
                      Record=cbell.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(cbell.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
cbell.Ess <- cbell.Ess[c(sort.Ind$ix),]


tempor.Ess <- data.frame(area=rep('tempor',dim.Area$len[1]),
                      loc=tempor.Data$loc,
                      Symbol=tempor.Data$Symbol,
                      Sample.r=tempor.Data$Sample.r,
                      Sample.p.r=tempor.Data$Sample.p.r.,
                      Record=tempor.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(tempor.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
tempor.Ess <- tempor.Ess[c(sort.Ind$ix),]


pons.Ess <- data.frame(area=rep('pons',dim.Area$len[1]),
                      loc=pons.Data$loc,
                      Symbol=pons.Data$Symbol,
                      Sample.r=pons.Data$Sample.r,
                      Sample.p.r=pons.Data$Sample.p.r.,
                      Record=pons.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(pons.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
pons.Ess <- pons.Ess[c(sort.Ind$ix),]

all.Area.dat[,1:6] <- prefront.Ess
all.Area.dat[,7:12] <- cbell.Ess
all.Area.dat[,13:18] <- tempor.Ess
all.Area.dat[,19:24] <- pons.Ess

cols.Corr <- c(4,10,16,22)
cols.Gene <- c(3,9,15,21)

ind.Ill <- matrix(rep(NA,4*dim.Area$len[1]),ncol=4)
for (i in 1:dim.Area$len[1]) {
     
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumcb)) {
               ind.Ill[i,2] <- which(as.character(all.Area.dat$illumcb)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,2] <- c(NA)
     }         
               
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumtc)) {            ind.Ill[i,3] <- which(as.character(all.Area.dat$illumtc)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,3] <- c(NA)
     }         
               
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumpo)) {
          ind.Ill[i,4] <- which(as.character(all.Area.dat$illumpo)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,4] <- c(NA)
     } 
          
          }

ind.Ill[,1] <- seq(1,dim.Area$len[1],1)     

#### ******* In all.Area.dat, each area's columns, are sorted separately by area on the correlation. ind.Ill shows where each probe is (index) by area


# This orders the data independently in each brain area by a particular variable
# all.Area.dat[,1:6] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[1]]),decreasing=FALSE),c(1:6)]
# all.Area.dat[,7:12] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[2]]),decreasing=FALSE),c(7:12)]
# all.Area.dat[,13:18] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[3]]),decreasing=FALSE),c(13:18)]
# all.Area.dat[,19:24] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[4]]),decreasing=FALSE),c(19:24)]

@

<<include=FALSE, echo=FALSE, results=tex>>=
# Calculate average correlation with COMT expression of each probe's expression
# Use Alexander (1990) to average correlations
# ind.Ill holds the indices for cerebellum, temporal cortex and pons of each probe on prefrontal cortex.

hold.Corrs <- data.frame(illum=rep(NA,dim.Area$len[1]),
                         gene=rep(NA,dim.Area$len[1]),
                         corpf=rep(0,dim.Area$len[1]),
                         corcb=rep(0,dim.Area$len[1]),
                         cortc=rep(0,dim.Area$len[1]),
                         corpo=rep(0,dim.Area$len[1])
                         )

##### ***** The next code sorts hold.Corrs by the sorted correlations in the prefrontal cortex
##### ***** In other words, the correlations are no longer sorted separately by area, but ###### instead the probeID order in prefrontal cortex after having been sorted by pf
##### correlation determines the correlations shown in that row in the other three areas
# For example, just making up a scenario, whatever probeID has the second strongest expression correlation with COMT in prefrontal cortex might have a correlation of r=.65 in the cerebellum. That is the correlation that would show up in the second row for the cerebellum

hold.Corrs$illum <- all.Area.dat$illumpf
hold.Corrs$gene <- all.Area.dat$genepf
hold.Corrs$corpf <- all.Area.dat$corrpf
hold.Corrs$corcb <- all.Area.dat$corrcb[c(ind.Ill[,2])]
hold.Corrs$cortc <- all.Area.dat$corrtc[c(ind.Ill[,3])]
hold.Corrs$corpo <- all.Area.dat$corrpo[c(ind.Ill[,4])]

# average these four correlations and put them into a new column
# Use Alexander (1990) to average

ki <- c(4)
n.subj <- c(144,144,144,144)

# Calculate in parts then put together

sum.corr <- matrix(rep(0,dim.Area$len[1]),ncol=1)
for (l in 1:dim.Area$len[1]) {
     
     sum.corr[l] <-sum((((n.subj[1:4] - 1))/(sum(n.subj) - ki))*(hold.Corrs[l,3:6] + (hold.Corrs[l,3:6]*(1 - hold.Corrs[l,3:6]^2))/(2*(n.subj[1:4] - 3))))
     
hold.Corrs$avgCorr[l] <- sum.corr[l]
}

@

<<include=FALSE, echo=FALSE, results=tex>>=

## Leave columns sorted by correlation in prefrontal cortex

top200_pos_ordered_by_pf_corr <- xtable(hold.Corrs[1:cut.Part,],
                           caption=paste('Correlations of expression with COMT in each brain area for the ',cut.Part,' probes that show the strongest positive correlations in prefrontal cortex',sep=''))


write.table(hold.Corrs[1:cut.Part,],file=paste('top',cut.Part,'_pos_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,
            quote=FALSE)
write.table(hold.Corrs[1:cut.Part,1:3],file=paste('top',cut.Part,'_pos_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,
            quote=FALSE)



top200_neg_ordered_by_pf_corr <- xtable(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-200),],
                           caption=paste('Correlations of expression with COMT in each brain area for the ',cut.Part,' probes that show the strongest negative correlations in prefrontal cortex',sep=''))

# Note that these are written in reverse order because they are negative: 20,000:19800
write.table(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-200),],file=paste('top',cut.Part,'_neg_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,quote=FALSE)
write.table(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-200),1:3],file=paste('top',cut.Part,'_neg_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,quote=FALSE)


@



<<include=FALSE, echo=FALSE, results=tex>>=
# Tally the chromosome numbers of the top 200 + and top 200 - in each brain area separately
# Are (+) correlated genes more likely to be on the same chromosome than (-) correlated genes?
# Do this both for the top 200 as well as for all 20000 probes.
# Use the data.frame dfsort
# colnames(dfsort)
#[1] "chr"     "corsign" "freq"
# dfsort is already in tabular form

corsign.By.chr <- dfsort
corsign.By.chr$pm <- factor(rep(c('minus','plus'),each=24))
corsign.By.chr <- corsign.By.chr[,c(1,4,3)]

colnames(corsign.By.chr) <- c('chr','corsign','count')

xtabs.ChrCorsign <- xtabs(count ~ chr + corsign,data=corsign.By.chr)

chisq.ChrCorsign.out <- chisq.test(xtabs.ChrCorsign)
print(chisq.ChrCorsign.out)

@

The chi-square test of independence shows that the number of genes showing positive versus negative correlations with COMT is not independent of Chromosome number in prefrontal cortex.\\

Next, use the binomial distribution to determine if the distribution on Chr 22 where COMT is differs from the distribution on all other chromosomes.\\

<<include=FALSE, echo=FALSE, results=tex>>=
# First get the numbers of plus and minus correlations aggregated across all chromosomes except Chr 22.
# Get total probes/genes on Chr 22

pm.Sans22 <- c(rep(0,2))
pm.Sans22[1] <- sum(xtabs.ChrCorsign[,1]) - xtabs.ChrCorsign[22,1]
pm.Sans22[2] <- sum(xtabs.ChrCorsign[,2]) - xtabs.ChrCorsign[22,2]

counts.22 <- sum(xtabs.ChrCorsign[22,])
counts.Sans22 <- sum(pm.Sans22)

obs.Minus.22 <- xtabs.ChrCorsign[22,1]

p.minus.22 <- obs.Minus.22/counts.22


# probability of negative correlations across all chromosomes except Chr 22
p.minus <- pm.Sans22[1]/counts.Sans22

# get the binomial distribution with p = p.minus and the sample size of the number of probes on Chr 22
d.minus <- dbinom(seq(0,counts.22,1),counts.22,p.minus)

d.minus <- data.frame(num.minus = seq(0,counts.22,1),prob=d.minus)

# Now get the probability of xtabs.ChrCorsign[22,1] minuses or fewer given counts.22 probes. In this case
# p(k <= 286 minuses) with Binomial(N=19171, p = 0.63888)

cumul.d.minus <- sum(d.minus[1:(obs.Minus.22 + 1),2])

binom.test(obs.Minus.22, counts.22, p = p.minus,
           alternative = c("less"),
           conf.level = 0.95)

binom.test(obs.Minus.22, counts.22, p = p.minus,
           alternative = c("two.sided"),
           conf.level = 0.95)


# The proportion of negatively COMT-correlated genes in prefrontal cortex, 0.54806, is significantly lower than the proportion aggregated across all the other chromosomes, 0.63888.
@

The proportion genes with negative correlations mwith MB-COMT on Chr 22, \Sexpr{p.minus.22}, is signficantly lower than the proportion aggregated across all of the other chromosomes, \Sexpr{p.minus}.\\ 

<<include=FALSE, echo=FALSE, fig=TRUE, pdf=TRUE>>=

vcut <- data.frame(x1=(obs.Minus.22 + 0.5), x2=(obs.Minus.22 + 0.5), y1=-0.00075, y2=0.02)
p.low.d.minus <- subset(d.minus,d.minus$num.minus < (obs.Minus.22 + 1))

minus.plot <- ggplot() +
          
          geom_point(data=d.minus, aes(x=num.minus,y=prob,group=1),
                     size=0.6,color='blue',shape=1) +
     
          geom_point(data=p.low.d.minus, aes(x=num.minus,y=prob,group=1),
                     size=0.6,color='red',shape=1) +
     
          geom_segment(data=vcut, aes(x=x1,xend=x2,y=y1,yend=y2), color='red',size=0.5)  +
          
          scale_y_continuous(breaks = seq(0,0.05,0.01),
                             labels = comma(seq(0,0.05,0.01), digits = 2)) +
          
          scale_x_continuous(name='Number of Negative Correlations (k)',
                             limits=c(0,round((counts.22 + 5),0)),
                             breaks=seq(0,round((counts.22 + 5),0),200)) +
          
          theme_classic() +
          
          
          ggtitle('Probability of Negative Correlations Based on All Chromosomes Except Chr 22' ) +
          
          ylab('Probability density') + 
          theme(aspect.ratio=1/gold.R) + 
          theme(plot.title = element_text(color="black",
                                          size=8.5,
                                          hjust=0.5)) +
          theme(axis.title = element_text(color="black",
                                          size=10,
                                          vjust=1
          )) +

               theme(axis.text.x = element_text(size=8),
                axis.text.y = element_text(size=8)) +
          
          annotate("text", x = (obs.Minus.22 - 65),
                   y = 0.005,
                   label = c(paste('p(k < ',(obs.Minus.22 + 1),') = ',
                                   round(cumul.d.minus,8),sep='')),
                   color="black",
                   size=3.0)    +
     
          annotate("text", x = 0.10*(round((counts.22 + 5),0)),
                   y = 1.10*max(d.minus$prob),
                   label = c(paste('unique ID: ',prog.Name,sep='')),
                   parse=FALSE,
                   color="gray20",
                   size=1.5) 

file1.pdf <- c('p_binomial_mb_comt.pdf')
   ggsave(file1.pdf, plot = minus.plot, width = 8, height = 5.5)

minus.plot

@

%\includegraphics[width=0.5\textwidth]{p_binomial_comt_s.eps}\\

<<include=FALSE, echo=FALSE, results=tex>>=
#Get the mean and sd of the top 200 positives and negatives in each area

mean.sd.By.areaPos <- psych::describe(all.Area.dat[2:(cut.Part+1),cols.Corr])
mean.sd.By.areaNeg <- psych::describe(all.Area.dat[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]- cut.Part),cols.Corr])


@





<<include=FALSE, echo=FALSE, results=TEX>>= 
# Test the hypothesis that the rank order of the most negatively correlated genes changes more across brain area than do the rank orders of the most highly positively correlated genes.

# Rank the genes on their correlations separately by area, then compare the ranks of specific genes across areas to determine if there are greater differences among negatively correlated genes than among positively correlated genes.

### Do this with the all.Area.dat which has the strongest correlations in each brain area separately. Have to use ind.Ill to find out what those probes are in each area.

hold.Area.dat <- data.frame(areapf=rep(NA,dim.Area$len[1]),
                           chrpf=rep(NA,dim.Area$len[1]),
                           genepf=rep(NA,dim.Area$len[1]),
                           corrpf=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpf=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpf=rep(NA,dim.Area$len[1]),
                           areacb=rep(NA,dim.Area$len[1]),
                           chrcb=rep(NA,dim.Area$len[1]),
                           genecb=rep(NA,dim.Area$len[1]),
                           corrcb=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalcb=as.numeric(rep(NA,dim.Area$len[1])),
                           illumcb=rep(NA,dim.Area$len[1]),
                           areatc=rep(NA,dim.Area$len[1]),
                           chrtc=rep(NA,dim.Area$len[1]),
                           genetc=rep(NA,dim.Area$len[1]),
                           corrtc=as.numeric(rep(NA,dim.Area$len[1])),
                           pvaltc=as.numeric(rep(NA,dim.Area$len[1])),
                           illumtc=rep(NA,dim.Area$len[1]),
                           areapo=rep(NA,dim.Area$len[1]),
                           chrpo=rep(NA,dim.Area$len[1]),
                           genepo=rep(NA,dim.Area$len[1]),
                           corrpo=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpo=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpo=rep(NA,dim.Area$len[1])
                           )
     
cols.Corr <- c(4,10,16,22)
cols.Gene <- c(3,9,15,21)     
     
hold.Area.dat[,1:6] <- all.Area.dat[order(all.Area.dat[,cols.Corr[1]],decreasing=TRUE),c(1:6)]
hold.Area.dat[,7:12] <- all.Area.dat[order(all.Area.dat[,cols.Corr[2]],decreasing=TRUE),c(7:12)]
hold.Area.dat[,13:18] <- all.Area.dat[order(all.Area.dat[,cols.Corr[3]],decreasing=TRUE),c(13:18)]
hold.Area.dat[,19:24] <- all.Area.dat[order(all.Area.dat[,cols.Corr[4]],decreasing=TRUE),c(19:24)]

@


<<include=FALSE, echo=FALSE, results=tex>>=
# now for the 200 genes with the largest negative correlations in Prefrontal Cortex, find their ranks in the other three areas



rank.Stab.neg <- matrix(rep(0,4*cut.Part),ncol=4)

# First do negative correlations
for (h in 1:cut.Part) {
     
     rank.Stab.neg[h,1] <-(20000 - (cut.Part -h))
     
     if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumcb)) {
          rank.Stab.neg[h,2] <- which(as.character(hold.Area.dat$illumcb) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,2] <-  c(NA)  
          
     }    
     
     if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumtc)) {
          rank.Stab.neg[h,3] <- which(as.character(hold.Area.dat$illumtc) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,3] <-  c(NA)  
          
     }
     
    if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumpo)) {
          rank.Stab.neg[h,4] <- which(as.character(hold.Area.dat$illumpo) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,4] <-  c(NA)  
          
     }
     
}

colnames(rank.Stab.neg) <- c('rankpf','rankcb','ranktc','rankpo')
rank.Stab.neg <- data.frame(rank.Stab.neg)
rank.Stab.neg$illum <- hold.Area.dat$illumpf[(20000 - (cut.Part -1)):20000]
rank.Stab.neg$gene <- hold.Area.dat$genepf[(20000 - (cut.Part -1)):20000]
rank.Stab.neg <- rank.Stab.neg[,c(5,6,1:4)]

overlap.Area <- list()

# [[1]] pf vs cb
# [[2]] pf vs tc
# [[3]] pf vs po
# [[4]] cb vs tc
# [[5]] cb vs po
# [[6]] tc vs po

overlap.Area[[1]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$rankcb)
overlap.Area[[2]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$ranktc)
overlap.Area[[3]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$rankpo)
overlap.Area[[4]] <- intersect(rank.Stab.neg$rankcb,rank.Stab.neg$ranktc)
overlap.Area[[5]] <- intersect(rank.Stab.neg$rankcb,rank.Stab.neg$rankpo)
overlap.Area[[6]] <- intersect(rank.Stab.neg$ranktc,rank.Stab.neg$rankpo)

perc.Overlap <- data.frame(compare=(rep(NA,6)),num=c(rep(0,6)),percentage=c(rep(0,6)),
                           n.base=c(rep(0,6)),ofn=c(rep(NA,6)))
perc.Overlap$compare <- c('prefrontal cortex vs. cerebellum',
                         'prefrontal cortex vs. temporal cortex',
                         'prefrontal cortex vs. pons',
                         'cerebellum vs. temporal cortex',
                         'cerebellum vs. pons',
                         'temporal cortex vs. pons')

for (g in 1:6) {
     
    perc.Overlap$n.base[g]  <- cut.Part - length(which(is.na(rank.Stab.neg[,g])))
     perc.Overlap$num[g]  <- length(overlap.Area[[g]]) 
    perc.Overlap$percentage[g]  <- paste(round(100*(perc.Overlap$num[g])/(perc.Overlap$n.base[g]),0),'%',sep='')
}

perc.Overlap.neg <- perc.Overlap
perc.Overlap.neg$ofn <- paste(perc.Overlap$num,' (',perc.Overlap$n.base,')',sep='')

colnames(perc.Overlap.neg) <- c('Comparison','number shared','Percentage','base n',
                                'Shared Genes (N)')
overlap.Neg <- xtable(perc.Overlap.neg[,c(1,5,3)],
                         caption=c('Of the genes with the strongest negative correlations with COMT expression,\n the percentage of genes found in both areas'))

overlap.Neg


@

<<include=FALSE, echo=FALSE, results=tex>>=
# now for the 200 genes with the largest positive correlations in Prefrontal Cortex, find their ranks in the other three areas


#cut.Part <- c(200)
rank.Stab.pos <- matrix(rep(0,4*cut.Part),ncol=4)

# Now do positive correlations
for (h in 1:cut.Part) {
     
     rank.Stab.pos[h,1] <- h
     
     if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumcb)) {
          rank.Stab.pos[h,2] <- which(as.character(hold.Area.dat$illumcb) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.pos[h,2] <-  c(NA)  
          
     }    
     
     if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumtc)) {
          rank.Stab.pos[h,3] <- which(as.character(hold.Area.dat$illumtc) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.pos[h,3] <-  c(NA)  
          
     }
     
    if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumpo)) {
          rank.Stab.pos[h,4] <- which(as.character(hold.Area.dat$illumpo) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.pos[h,4] <-  c(NA)  
          
     }
     
}



colnames(rank.Stab.pos) <- c('rankpf','rankcb','ranktc','rankpo')
rank.Stab.pos <- data.frame(rank.Stab.pos)
rank.Stab.pos$illum <- hold.Area.dat$illumpf[1:cut.Part]
rank.Stab.pos$gene <- hold.Area.dat$genepf[1:cut.Part]
rank.Stab.pos <- rank.Stab.pos[,c(5,6,1:4)]

overlap.Area <- list()

# [[1]] pf vs cb
# [[2]] pf vs tc
# [[3]] pf vs po
# [[4]] cb vs tc
# [[5]] cb vs po
# [[6]] tc vs po

overlap.Area[[1]] <- intersect(rank.Stab.pos$rankpf,rank.Stab.pos$rankcb)
overlap.Area[[2]] <- intersect(rank.Stab.pos$rankpf,rank.Stab.pos$ranktc)
overlap.Area[[3]] <- intersect(rank.Stab.pos$rankpf,rank.Stab.pos$rankpo)
overlap.Area[[4]] <- intersect(rank.Stab.pos$rankcb,rank.Stab.pos$ranktc)
overlap.Area[[5]] <- intersect(rank.Stab.pos$rankcb,rank.Stab.pos$rankpo)
overlap.Area[[6]] <- intersect(rank.Stab.pos$ranktc,rank.Stab.pos$rankpo)


perc.Overlap <- data.frame(compare=(rep(NA,6)),num=c(rep(0,6)),percentage=c(rep(0,6)),
                           n.base=c(rep(0,6)),ofn=c(rep(NA,6)))
perc.Overlap$compare <- c('prefrontal cortex vs. cerebellum',
                         'prefrontal cortex vs. temporal cortex',
                         'prefrontal cortex vs. pons',
                         'cerebellum vs. temporal cortex',
                         'cerebellum vs. pons',
                         'temporal cortex vs. pons')

for (g in 1:6) {
     
    perc.Overlap$n.base[g]  <- cut.Part - length(which(is.na(rank.Stab.pos[,g])))
     perc.Overlap$num[g]  <- length(overlap.Area[[g]]) 
    perc.Overlap$percentage[g]  <- paste(round(100*(perc.Overlap$num[g])/(perc.Overlap$n.base[g]),0),'%',sep='')
}

perc.Overlap.pos <- perc.Overlap
perc.Overlap.pos$ofn <- paste(perc.Overlap$num,' (',perc.Overlap$n.base,')',sep='')

colnames(perc.Overlap.pos) <- c('Comparison','number shared','Percentage','base n',
                                'Shared Genes (N)')
overlap.Pos <- xtable(perc.Overlap.pos[,c(1,5,3)],
                         caption=c('Of the genes with the strongest positive correlations with COMT expression,\n the percentage of genes found in both areas'))

overlap.Pos


@


% {\bfseries {Using the hypergeometric distribution to test for randomness in the number of probes shared in common between the reference area and another area.}}\\
% 
% Testing for probe matches between a reference and a test brain area involves the {\bfseries {hypergeometric}} distribution.\\ The computation of probabilities when sampling without replacement is based on the following pdf:
% 
% \href{http://people.wku.edu/david.neal/109/Unit2/SamplingWO.pdf}{c('MATH 109 Sampling without Replacement)}
% 
% Here is the description of the calculation: \\
% 
% {\bfseries {Sampling Without Regard to Order}}\\
% Now  suppose  we  have  a  population  of N elements  that  are  divided  into  two  types: Type I  which has A elements,  and Type II which has B elements, where $A + B == N$.\\  
% 
% For  example,  a  standard  deck  of  $N == 52$  playing  cards  can  be  divided  in  many  ways. Type  I  could  be  “Hearts”  and  Type  II    could  be  “All  Others.”    Then  there  are   $A == 13$ Hearts and  $B == 39$ Others.\\
% 
% In analogy to the genes/probes problem, $N == 20,000$ probes,  $A == 50$ or 200, as in the top 50 or the top 200 most strongly positively/negatively {\textit {COMT}}-correlated probes. Thus B is either 19,950 ($A == 50 $) or B is 19,800 ( $A == 200$). 
% 
% There are two other parameters: $n == $the number of probes randomnly sampled without replacement, and  $k = $ the number of probes in the sample of size n that also are contained in A. The calculation for the probability that a sample of size n will contain k probes in common with the set in A is:\\
% $$
% p = \frac{\binom{A,k}*\binom{B,(n-k)}}{\binom{N,n}}
% $$


<<include=FALSE, echo=FALSE, results=tex>>=
# Conditional on the 500 probes with expression levels most strongly positively and negatively correlated with COMT expression in Prefrontal Cortex, find the probability of n of 500 matching

# Sampling without replacement

# rank.order.stats
#            compare   n   rho        pvalue
# 1  PFCtx vs. Cereb 120 0.510 0.00000000263
# 2 PFCtx vs. TemCtx 254 0.544 0.00000000000
# 3   PFCtx vs. Pons 114 0.460 0.00000026122
# 4 Cereb vs. TemCtx 109 0.399 0.00001709187
# 5   Cereb vs. Pons 208 0.428 0.00000000012
# 6  TemCtx vs. Pons 113 0.472 0.00000013108

# numworking.genes.by.area
#            Number of Genes
# Prefrontal 16670          
# Cerebellum 16685          
# Temporal   16636          
# Pons       16616  



# First compare PFCtx to Cerebellum

     num.Probes <- as.integer(unlist(numworking.genes.by.area[1]))
     N <- num.Probes
     A <- c(500)   # number of probes in the reference area that could be matched
     B <- c(N - A)         # number of probes not in slected set in reference area
n <- A     # sample of 500 probes
# then k ranges from 0 to A matches

###*** Note ***#####
# The average NUMBER of matches to the top 500 probes expected with a sample of 500 randomly
# selected genes in another area will be n x A/N or 500(500/16670) = 14.99; the expected number of matches by chance.

# prob.N will hold the discrete probability distribution for k matches from a sample size either of 500.

prob.N <- mpfr(matrix(rep(0,(A+1))),precBits=50)
for (k in 1:A) {
     
     prob.N[k+1] <- (chooseMpfr(A,k)*chooseMpfr(B,(n-k)))/chooseMpfr(N,n)
}


prob.N[1] <- 1.0 - sum(prob.N[2:(A+1)])


     prob.N.500 <- data.frame(n.match=seq(0,A,1),log10prob=as.numeric(log10(prob.N)))
     write.table(prob.N.500,file=paste('hypergeometric_probability_table_',A,'.csv',sep=''),sep=', ',row.names=FALSE)


Nx <- N      # number of objects
Ax <- A       # sample size
k <- Ax        # number of matches
pairs.probA <- mpfr(matrix(rep(0,2*(k+1)),ncol=2),10557)
pairs.probA[,1] <- c(0:k)



for (hj in 0:k) {
     
     hj <- as.integer(c(10))
     pairs.probA[hj+1,2] <- chooseMpfr(Nx,(Ax-hj))*(((Nx^2) - Nx)/Nx^2)^(Ax-hj)*chooseMpfr((Nx-(Ax-hj)),hj)*(1/Nx)^hj
     
}

repts <- c(10000)
Nx <- N #c(10)
Ax <- A #c(5)
pairs.prob <- matrix(rep(0,(Ax+1)*2),ncol=2)
pairs.prob[,1] <- c(0:Ax)

for (kl in 1:repts)   {
     
     samp1 <- sample(c(1:Nx),Ax,replace=FALSE)
     samp2 <- sample(c(1:Nx),Ax,replace=FALSE)
     num.match <- sum(samp1 %in% samp2)
     pairs.prob[num.match + 1,2] <- pairs.prob[num.match + 1,2] + 1 

}

pairs.prob[,2] <- pairs.prob[,2]/repts
plot(pairs.prob[,1],pairs.prob[,2])


@


<<include=FALSE, echo=FALSE>>=  # , fig=TRUE, pdf=TRUE
# For plotting purposes, the last probability in each frame is 0, so leave that out
# also because it is a discrete distribution, only plot every 5th or 10th point

     
# Using <<- instead of <- allows the variable to used globally
     # Do this when prob.N.500 is first set up in another program
#prob.N.500.plot <- prob.N.500[c(seq(1,200,10)),]
     # Call the hyperplot.R function to plot the hypergeometric distributions

hiLim <- c(500)
limitseq <- c(-1000,0,100)

# Using <<- instead of <- allows the variable to used globally
     # Do this when prob.N.200 is first set up in another program

     p.plot <- hyper.plot(prob.N.500,hiLim,limitseq,prog.Name,N)     

p.plot

# file.eps <- c('hypergeometric_distribution_500.pdf')
#   postscript(file=file.eps,horiz=FALSE,onefile=FALSE,width=8.0,height=5.5,paper='letter')
# 
# p.plot

@

The hypergeometric distributions using the parameters described above are shown in the next figure.\\

%\includegraphics[width=0.5\textwidth]{hypergeometric_matching_genes_diagram.pdf}\\


<<include=FALSE, echo=FALSE, results=tex>>=
############## This needs to be changed to reflect the two prob.N as prob.N.50 and prob.N.200 and the fact that the probabilities are already represented as log10

genes.In.common <- cbind(perc.Overlap.pos[,c(1,5,3)],perc.Overlap.neg[,c(5,3)])



     genes.In.common$logp.valpos <- round(as.numeric(prob.N.200[(perc.Overlap.pos[,2]+1),2]),1)
     genes.In.common$logp.valneg <- round(as.numeric(prob.N.200[(perc.Overlap.neg[,2]+1),2]),1)

     
genes.In.common <- genes.In.common[,c(1:3,6,4,5,7)]

genes.In.common.tab <- xtable(genes.In.common,
                   caption = c(paste("Percentages of the ",cut.Part," Most Strongly Correlated Genes Shared in Common Between Two Brain Areas",sep="")))


genes.In.common.ltx <- latex(genes.In.common.tab,file='',
                   caption = c(paste("Percentages of the ",cut.Part," Most Strongly Correlated Genes Shared in Common Between Two Brain Areas",sep="")),
                     caption.loc = c('top'),
#                     colname = c('Name','URL'),
                     rowlabel = NULL,
                     colnamesTexCmd="bfseries",
                     booktabs=TRUE,
                     label=c('tab:sharedgenes'),
                     na.blank = TRUE,
                     vbar = FALSE,
                     longtable=TRUE,
                     table.env=TRUE,
                     center=c('center'),
                     continued=c('Genes Shared Across Areas Continued'),
                     first.hline.double = TRUE,
                     append=FALSE
                     )
                  
print(genes.In.common.ltx)

write.table(genes.In.common,paste('shared_perc_',cut.Part,'_posneg.csv',sep=', '),row.names = FALSE)

@


<<echo=FALSE, results=tex>>=
################################################
### Select the top 200 by p-value to determine which genes expression levels (by chromosome) are most highly correlated with COMT expression.
### Done separately for positive and negative correlations
### Inversely normalized by fitted number of probes from the regression on chr length, but weighted by proportion of each chromosome in the top 200. 
################################################

##### Positive correlations with COMT expression only #####################
num.Sel <- cut.Part
full.Count <- table(manhat.Posr.pf$CHR)
order.by.P.pos <- manhat.Posr.pf[order(manhat.Posr.pf$P), ]

order.by.P.pos$P <- -log10(order.by.P.pos$P)
colnames(order.by.P.pos)[3] <- c('-log10p')
xtable(order.by.P.pos[1:num.Sel,],caption=c(paste(cut.Part,' Genes with Strongest Positive Correlations with COMT in Prefrontal Cortex',sep='')))

############ End positive only ########################
  
##### Negative correlations with COMT expression only #####################
full.Count <- table(manhat.Negr.pf$CHR)
order.by.P.neg <- manhat.Negr.pf[order(manhat.Negr.pf$P), ]
order.by.P.neg$P <- -log10(order.by.P.neg$P)
colnames(order.by.P.neg)[3] <- c('-log10p')

xtable(order.by.P.neg[1:num.Sel,],caption=c(paste(cut.Part,' Genes with Strongest Negative Correlations with COMT in Prefrontal Cortex',sep='')))

############ End negative only ########################

@

{\bfseries {Gene ontology analysis}}\\

<<echo=FALSE, include=FALSE, results=tex>>=

if (!exists('ensembl')) {
 ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")   
}

normal.chroms <- c(1:22, "X", "Y", "M")

if (!exists('ah')) {
 ah <- AnnotationHub()   
}

if (!exists('orgs')) {
 orgs <- AnnotationHub::query(ah, "org.Hs.eg.db")   
}

if (!exists('gene.DB')) {
 gene.DB <- orgs[["AH57973"]]   
}

# columns(gene.DB)
# keytypes(gene.DB)




# input entrez ID output gene symbol
# temp.Gene <- c('COMT',   'PHGDH',  'DDR1',   'SCAMP2', 'ZFAND3', 'NECAP2', 'HDAC1',  'FTL', 'TST',    'CRYL1')
# 

topplusr.Data$GENE <- gsub(" ", "", topplusr.Data$GENE)
topminusr.Data$GENE <- gsub(" ", "", topminusr.Data$GENE)

twohundred_comt_plus <- na.omit(biomaRt::select(gene.DB,keys=as.character(topplusr.Data$GENE[2:51]),columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL')))

write.table(twohundred_comt_plus,file='twohundred_comt_plus_corr.csv',sep=', ',quote=FALSE)


twohundred_comt_minus <- na.omit(biomaRt::select(gene.DB,keys=as.character(topminusr.Data$GENE[2:51]),columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL')))

write.table(twohundred_comt_minus,file='twohundred_comt_minus_corr.csv',sep=', ',quote=FALSE)


     

     top200.Pos <- biomaRt::select(gene.DB,keys=order.by.P.pos$GENE[1:num.Sel],columns=c('GENENAME','SYMBOL','ENTREZID'),keytype=c('SYMBOL'))
     
#          top.Pos <- top200.Pos
     top.Pos <- twohundred_comt_plus
          
     top200.Neg <- biomaRt::select(gene.DB,keys=order.by.P.neg$GENE[1:num.Sel],columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL'))
     


#          top.Neg <- top200.Neg
          top.Neg <- twohundred_comt_minus


pos.Tab <- xtable(top.Pos,caption=c(paste('Top ',cut.Part,' Positively Correlated Genes with COMT in Prefrontal Cortex',sep='')))

pos.Tab

neg.Tab <- xtable(top.Neg,caption=c(paste('Top ',cut.Part,' Negatively Correlated Genes with COMT in Prefrontal Cortex',sep='')))

neg.Tab

@

<<include=FALSE, echo=FALSE, results=tex>>=

#org.Hs.egGO is an R object that provides
#mappings between entrez gene identifers and the GO
#identifers that they are directly associated with
entrez_object <- org.Hs.egGO    # 


# *********** Ontology on various ranking criteria:

# sort the 500 lowest p-value genes by sign of correlation

lowest.pval.sign.pos <- list()
lowest.pval.sign.neg <- list()


lowest.pval.sign.pos <- lapply(hold.Lowest.pvals[ib], function(x,ib)  subset(x,x$corsign == 1),
                               ib)
lowest.pval.sign.neg <- lapply(hold.Lowest.pvals[ib], function(x,ib)  subset(x,x$corsign == -1),
                               ib)

lowest.pval.sign <- list(pos=lowest.pval.sign.pos,
                         neg=lowest.pval.sign.neg)

# lowest.pval.sign[[1]]$pf$corsign     
                    

gene.Set <- as.character(lowest.pval.sign$neg$pf$ENTREZID)

universe <- as.character(unique(gene.Major[[1]]$ENTREZID))
#################################################################
          
##### Coefficient of variation - correlation   
          
# one.genelims[2,1] <- length(area.colwise$coeffVar.expr)
# one.genelims[2,2] <- length(area.colwise$coeffVar.expr) - (top.Num - 1)
# 
# gene.Set <- as.character(area.colwise$ENTREZID[one.genelims[q,1]:one.genelims[q,2]])
# 
# universe <- as.character(unique(area.colwise$ENTREZID))
########################################################


params <- new('GOHyperGParams',                          #
              geneIds=gene.Set,
              universeGeneIds=universe,
              ontology='MF',
              pvalueCutoff=0.0001,
              conditional=F,
              testDirection='over',
              annotation="org.Hs.eg.db"
             )
bp.ontol <- hyperGTest(params)
bp.ontology.results <- summary(bp.ontol)

# Now get the genes that matched each ontology term
ontol.genes <- list()
max.Count <- 0

for (i in 1:dim(bp.ontology.results)[1]) {

     allgos <- geneIdUniverse(bp.ontol)[[i]]
     mygos <- geneIds(bp.ontol)[geneIds(bp.ontol) %in% allgos]
#mygos
# "93664" "22930" "6456"  "9581"  "6860"  "8618"

     # goid.and.term <- data.frame(gobpid=bp.ontology.results$GOBPID[i],
     #                        term=bp.ontology.results$Term[i])
     gene.Symbols <- getBM(c("hgnc_symbol"),
                             filters = c("entrezgene"),
                             values = list(entrezgene=mygos),
                             mart = ensembl)
# temp.list <- list(goid.and.term,
#                   gene.Symbols)
     if (bp.ontology.results$Count[i] > max.Count) {
          max.Count <- bp.ontology.results$Count[i]
     } else {}
     
ontol.genes[[i]] <- c(bp.ontology.results[i,],
                             gene.Symbols)

}

fname_ontology <- c(paste('genes500_by_MF_ontolTerm_pos_po.txt',
                          sep=''))

write_lines(ontol.genes,fname_ontology)

########## end get matching genes to ontology terms

# make a list that holds the ontology term and the genes that were associated with that term


num.ontol <- dim(bp.ontology.results)[1]


# for (k in 1:num.ontol)  {
#      
#    write(print(unlist(ontol.genes[[k]]),rownames=FALSE,quote=FALSE),ncolumns=(7+max.Count),append=TRUE,file=fname_ontology,sep=',')       
# }

ontology.tab <- xtable(bp.ontology.results,
                                caption=c('MF Ontology for the positively correlated genes with the lowest p-values for expression correlations with {\\textit {COMT}}: Pons'),
                                digits=c(0,0,17,2,2,0,0,0))

#} # end sign loop
#} # end area loop

print.xtable(ontology.tab,
             file=,
                         type='latex',
                         floating=FALSE,
                         caption.placement='top',
                         tabular.environment='longtable',
                         caption.width ='0.5\\textwidth',
                         hline.after=c(-1,0,nrow(ontology.tab)),
                         include.rownames=FALSE,
                         print.results=TRUE,
                         booktabs=TRUE,
                         comment=TRUE
                         )


@

The above analyses show that for the most part, ordering the genes by the largest correlation-variancle or z(expression)-variance or by the corresponding coefficients of variation (CV), and doing ontology on the 20 highest ranking genes, produces little significance in almost all areas of ontology.\\

Ranking by these measures would reveal the genes whose correlations or mean expression levels changed the most across brain areas. Thus, these would not necessarily be the genes co-expressed with COMT, but rather those that in some brain areas could have been strongly co-expressed with COMT while in others, those same genes were not or were negatively co-expressed.\\

In contrast, ranking on the correlation coefficient alone (split by sign) tended to produce more significant ontology results.\\



<<echo=FALSE, include=FALSE, results=tex>>=
print(xtable(coexpress.URL[1,],caption=c('The next co-expression analysis used the database at this URL to find the top 500 genes coexpressed with COMT. That list was then checked against the top 200 genes (+ and - separately) from the comt-prefrontal data to find agreement between the two lists.')))

num.Sel <- c(500)
### read the COMT coexpression data file 

wbhsa <- loadWorkbook('comt_coex_list_500_hsa.xlsx')
# wbhsa2 <- loadWorkbook('comt_coex_list_500_hsa2.xlsx')
# wbhsa3 <- loadWorkbook('comt_coex_list_500_hsa3.xlsx')

coexpress.Data <- data.frame(read.xlsx(wbhsa,         # now tell R to read that workbook and which sheet
                                  sheet = "coex500"))


coexpress.Data$Entrez.Gene.ID <- as.character(coexpress.Data$Entrez.Gene.ID)

pos.match.coexpress.indx <- list()
neg.match.coexpress.indx <- list()
match.coexpress.indx <- list(pos=pos.match.coexpress.indx,
                             neg=neg.match.coexpress.indx)
pos.Matches.genes <- list()
neg.Matches.genes <- list()


     for (im in ib)   {

          pos.match.coexpress.indx[[im]] <- match(lowest.pval.sign[[1]][[im]]$ENTREZID,coexpress.Data$Entrez.Gene.ID)
          neg.match.coexpress.indx[[im]] <- match(lowest.pval.sign[[2]][[im]]$ENTREZID,coexpress.Data$Entrez.Gene.ID)
          
          match.coexpress.indx$pos[[im]] <- pos.match.coexpress.indx[[im]]
          match.coexpress.indx$neg[[im]] <- neg.match.coexpress.indx[[im]]
          pos.Matches.genes[[im]] <- coexpress.Data$Gene[c(na.omit(match.coexpress.indx$pos[[im]]))]
          neg.Matches.genes[[im]] <- coexpress.Data$Gene[c(na.omit(match.coexpress.indx$neg[[im]]))]

     }

pos.match.genes.tab <- list()
neg.match.genes.tab <- list()

posmatch.DF <- list()
negmatch.DF <- list()

for (im in ib)    {
     if (length(pos.Matches.genes[[im]]) > 0) {
          my.symbols <- pos.Matches.genes[[im]]
          my.regions <- getBM(c("hgnc_symbol", "chromosome_name", "start_position", "end_position"),
                    filters = c("hgnc_symbol", "chromosome_name"),
                    values = list(hgnc_symbol=my.symbols, chromosome_name=normal.chroms),
                    mart = ensembl)
         
          my.regions$chromosome_name

          posmatch.DF[[im]] <- data.frame(geneSymbol=my.regions$hgnc_symbol,
                                    chromosome=my.regions$chromosome_name)


     } else {posmatch.DF[[im]] <- data.frame(geneSymbol=NA,chromosome=NA)
     }

     pos.match.genes.tab[[im]] <- xtable(posmatch.DF[[im]],caption=c(paste('Genes co-expressed with COMT from ',coexpress.URL[1,2],' matching the top ',num.Sel,' positively COMT - correlated genes in ',stand.Col.names[im],sep='')))

}

# Generate tables for any negatively correlated genes
for (im in ib)    {
     if (length(neg.Matches.genes[[im]]) > 0) {
          my.symbols <- neg.Matches.genes[[im]]
          my.regions <- getBM(c("hgnc_symbol", "chromosome_name", "start_position", "end_position"),
                    filters = c("hgnc_symbol", "chromosome_name"),
                    values = list(hgnc_symbol=my.symbols, chromosome_name=normal.chroms),
                    mart = ensembl)
         
          my.regions$chromosome_name

          negmatch.DF[[im]] <- data.frame(geneSymbol=my.regions$hgnc_symbol,
                                    chromosome=my.regions$chromosome_name)


     } else {negmatch.DF[[im]] <- data.frame(geneSymbol=NA,chromosome=NA)
     }

     neg.match.genes.tab[[im]] <- xtable(negmatch.DF[[im]],caption=c(paste('Genes co-expressed with COMT from ',coexpress.URL[1,2],' matching the top ',num.Sel,' negatively COMT - correlated genes in ',stand.Col.names[im],sep='')))

}

@

<<overrep.chr.22>>=

# Check on whether genes on Chromosome 22 (COMT location) aree overrepresented among the genes overlapping the COMT-co-expressed genes from COXPRESdb http://coxpresdb.jp/

# get proportion of Chr 22 genes in the top 500 in each brain area for the positively correlated genes
chr22.propor.COXPRES <- data.frame(xnum=rep(NA,4),
                               nnum=rep(NA,4))

chr22.propor.500 <- unlist(lapply(hold.Lowest.pvals[ib], function(x,ib) (dim(subset(x,
                x$loc == '22' & x$corsign == 1))[1])/(dim(subset(x,x$corsign == 1))[1]), ib))

chr22.propor.COXPRES[,1] <- unlist(lapply(posmatch.DF[ib], function(x,ib) (dim(subset(x,
                x$chromosome == '22'))[1]), ib))
chr22.propor.COXPRES[,2] <- unlist(lapply(posmatch.DF[ib], function(x,ib) (length(x$chromosome)), ib))

binom.chr22.enrich <- list()

# Note: confidence level has been Bonferroni corrected .05/4 = 0.0125
for (im in ib)   {

     binom.chr22.enrich[[im]] <- binom.test(chr22.propor.COXPRES[im,1], chr22.propor.COXPRES[im,2], 
           p = chr22.propor.500[im],alternative = c("greater"),conf.level = (1-.05/4))

}

writeLines(binom.chr22.enrich,con='chr22_enrichment_genes_500_and_COXPRESdb.txt',sep='\n')

lapply(binom.chr22.enrich, write,'chr22_enrichment_genes_500_and_COXPRESdb.txt', append=TRUE,
       ncolumns=1000)

sink('chr22_enrichment_genes_500_and_COXPRESdb.txt')
print(binom.chr22.enrich)
sink()

@

The proportion of the 500 most strongly positively correlated genes (from the NIH data set) that were located on Chromosome 22 (COMT location) and that overlapped with the 500 most strongly co-expressed genes from COXPRESdb http://coxpresdb.jp/ was significantly greater in all brain areas except pons than the overall proportion of the top 500 positively correlated genes from the NIH data set that were located on Chromosome 22 (note: this latter set did not include the requirement that they overlap with the COXPRESdb genes). In other words, genes for which there were two sources of positive COMT-coexpression evidence (NIH data and COXPRESdb data) were enriched on Chromosome 22. This could be an indication of sharing transcription factors.


<< results=tex>>=
# use the web interface at http://amp.pharm.mssm.edu/Enrichr/enrich to do various kinds of ontology on the top (+) and bottom (-) of the <area-abbrev>.Data.onegene correlation-ranked data.


# first, verify that prefront.Data.onegene is ordered by Sample.r (this only verifies that the
# max(r) and min(r) are at the top and bottom of the ranked data)
check.Order <- as.vector(c(rep(NA,8)))

for (vi in seq(1,7,2))   {

 if(max(area.onegene.List[[vi]]$Sample.r) != area.onegene.List[[vi]]$Sample.r[1])  {
      
      check.Order[vi] <- FALSE
      
 }  else if (max(area.onegene.List[[vi]]$Sample.r) == area.onegene.List[[vi]]$Sample.r[1]) {
      
      check.Order[vi] <- TRUE
 }  else {
      
 }

# negative
# Check ordering at bottom of data

  if(min(area.onegene.List[[vi]]$Sample.r) != area.onegene.List[[vi]]$Sample.r[length(area.onegene.List[[vi]]$Sample.r)])  {
      
      check.Order[vi + 1] <- FALSE
      
 }  else if (min(area.onegene.List[[vi]]$Sample.r) == area.onegene.List[[vi]]$Sample.r[length(area.onegene.List[[vi]]$Sample.r)]) {
      
      check.Order[vi + 1] <- TRUE
 }  else {
      
 }
     
} # end combined brain area and sign loop

check.Order

num.Ont <- c(50)

symbols.top.bottom.50 <- data.frame(pfpos=rep(0,num.Ont),
                                    pfneg=rep(0,num.Ont),
                                    cbpos=rep(0,num.Ont),
                                    cbneg=rep(0,num.Ont),
                                    tmpos=rep(0,num.Ont),
                                    tmneg=rep(0,num.Ont),
                                    popos=rep(0,num.Ont),
                                    poneg=rep(0,num.Ont))

# my.mod <-function(x,m)
#   {
#     return(m - (x %% m))
#   }

for (v in seq(1,7,2))   {
     for (w in 1:2)   {
          
          lims.Ont <- matrix(c(1,
                             num.Ont,
                             length(area.onegene.List[[(v+(w-1))]]$Sample.r),
                             (length(area.onegene.List[[(v+(w-1))]]$Sample.r) - num.Ont + 1)),
                             ncol=2,byrow=TRUE)
     
symbols.top.bottom.50[1:num.Ont,(v+(w-1))] <- noquote(area.onegene.List[[(v+(w-1))]]$Symbol[lims.Ont[w,1]:lims.Ont[w,2]])

     } # end sign loop
} # end brain area loop

@

<< >>=
######### ******** Enrichr ontology ********* #############

dbs.Poss <- listEnrichrDbs()

dbs.up <- c('GTEx_Tissue_Sample_Gene_Expression_Profiles_up')
dbs.down <- c('GTEx_Tissue_Sample_Gene_Expression_Profiles_down')

#enriched <- enrichr(as.character(symbols.top.bottom.50$pfneg), dbs)
enriched <- enrichr(as.character(pf.specific.up$pf.a[1:50]), dbs.down)

enriched[['GTEx_Tissue_Sample_Gene_Expression_Profiles_down']][1:40,]





@


\end{document}


 
