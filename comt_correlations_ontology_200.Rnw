% NEW based on COMT-MB data
<<include=FALSE, echo=FALSE, results=hide>>=
# Generate a uinique ID for this program by path and filename. This unique ID is attached to this file using a tag in the filesystem.
source('unique_id_generator.R')

fname <- c("/Volumes/Macintosh_HD_3/genetics/genenetwork2/comt_correlations_ontology _1.Rnw")

prog.Name <- unique.ID(fname)

prog.Name

@

This program has the unique ID: \Sexpr{prog.Name}.


\documentclass[11pt]{article}
\usepackage{graphicx, subfig}
\usepackage{float}
\pagenumbering{arabic}
\usepackage{enumerate}
\usepackage{Sweave}
\usepackage{booktabs}
\usepackage[table]{xcolor}
\usepackage{framed}
\usepackage{longtable}
\usepackage{tablefootnote}
\usepackage{amsmath}
\usepackage{hyperref}


\begin{document}
\SweaveOpts{concordance=TRUE}
\SweaveOpts{keep.source=TRUE} 


\hspace{-1.5em}Gene Network\\
COMT expression correlations Prefrontal cortext\\
Fall, 2017\\

<<echo=FALSE>>=
library(ggplot2,ggthemes)
library(ggExtra)
library(psych)
library(ggpubr)       ### Make sure this is installed
library(knitr)
library(Hmisc)
library(openxlsx)
library(xtable)
library(magrittr)
library(tables)
library(stargazer)
library(plyr)
library(rlist)
library(qqman)
library(manhattanly)
library(Cairo)
library(RColorBrewer)
library(HGNChelper)
library(tools)
library(scales)
library(devtools)
library(utils)

if (!exists("drveera/ggman")) {
  install_github("drveera/ggman")   
}


library(ggman)
library(dplyr)
library(biomaRt)
library(combinat)
library(Rmpfr)
library(stats)

source("https://bioconductor.org/biocLite.R")
if (!exists("GenomicFeatures")) {
  biocLite(c("GenomicFeatures"))   
}

if (!exists("AnnotationDbi")) {
  biocLite(c("AnnotationDbi"))   
}

if (!exists("org.Hs.eg.db")) {
  biocLite(c("org.Hs.eg.db"))   
}

library("AnnotationHub")
library("GenomicFeatures")
library("org.Hs.eg.db")


if (!exists("hgu95av2.db")) {
     biocLite(c('hgu95av2.db'))
}

library('hgu95av2.db')

if (!exists("illuminaHumanv4.db")) {
     biocLite("illuminaHumanv4.db")
}

library("illuminaHumanv4.db")

source("https://bioconductor.org/workflows.R")

if (!exists("annotation")) {
 workflowInstall("annotation")   
}

if (!exists("txdb")) {
 biocLite("TxDb.Hsapiens.UCSC.hg19.knownGene")
 library(TxDb.Hsapiens.UCSC.hg19.knownGene)
 txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene #shorthand (for convenience)    
}

if (!exists("GO.db")) {
biocLite("GO.db")
}

if (!exists("topGO")) {
biocLite("topGO")
}     

if (!exists("GOstats")) {
biocLite("GOstats")
} 
     
library("GO.db")
library("topGO")
library("GOstats")

if (!exists("lumi")) {
     biocLite('lumi')
}

library(lumi)

if (!exists("lumiHumanIDMapping")) {
     biocLite('lumiHumanIDMapping')
}

library(lumiHumanIDMapping)

if(!exists('lumiHumanAll.db')) {
     biocLite('lumiHumanAll.db')
}

library('lumiHumanAll.db')

if(!exists('rBLAST')) {
     biocLite('rBLAST')
}

library(rBLAST)

if (!exists("illuminaHumanv2.db")) {
     biocLite (c( "beadarray" , "limma" , "GEOquery" , "illuminaHumanv2.db"))
}

if (!exists('annotate')) {
     biocLite('annotate')
}

library('annotate')

library("illuminaHumanv2.db")
library("beadarray","limma","GEOquery")

options(scipen = 999, digits = 5, width = 60)
@

<<echo=FALSE, results=hide >>=
### to prepend filename strings to plots
#pre.Name <- c('comt_expression-') #pre-ppended to eps output files
# RColorBrewer palette
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
source('/Volumes/Macintosh_HD_3/genetics/genenetwork/histChrfunc.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork/onlycisChr.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork/hypergeom_plot.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/countNA.R') # function num.NA()
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/func_get_match_length.R') #len.match()

samp.Size <- c(50,200)
cut.Part <- samp.Size[2]
@

<<echo=FALSE, include=FALSE, results=tex>>=
coexpress.URL <- data.frame(site=NA,addr=NA)
coexpress.URL[1,1:2] <- c('COXPRESdb','http://coxpresdb.jp/')
coexpress.URL[2,1:2] <- c('OMICtools','https://omictools.com/')
coexpress.URL[3,1:2] <- c('Coexpedia','http://www.coexpedia.org/search.php')
coexpress.URL[4,1:2] <- c('GeneFriends','http://www.genefriends.org/RNAseq/')
coexpress.URL[5,1:2] <- c('Illumina Probes','http://www.genomequebec.mcgill.ca/compgen/integrated_vervet_genomics/transcriptome/Illumina/allprobes.html')
coexpress.URL[6,1:2] <- c('Gibbs Expression Data','https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE15745')


url.Tab <- xtable(coexpress.URL)
url.Table <- latex(url.Tab,file='',
                   caption = c("Gene Co-expression Databases"),
                   caption.loc = c('top'),
                     colname = c('Name','URL'),
                     rowlabel = c(''),
                     colnamesTexCmd="bfseries",
                     booktabs=TRUE,
                     label=c('tab:coexpressurls'),
                     na.blank = TRUE,
                     vbar = FALSE,
                     longtable=TRUE,
                     table.env=TRUE,
                     center=c('center'),
                     continued=c('Gene Co-expression Databases Continued'),
                     first.hline.double = TRUE,
                     append=FALSE
                     )
print(url.Table)


@


<<echo=FALSE>>=
### read the data file 

if (!exists('wb')) {
  wb <- loadWorkbook('comt_all_areas_correlation_results.xlsx')   
}

if (!exists('prefront.Data')) {
  prefront.Data <- data.frame(read.xlsx(wb,  # now tell R to read that workbook and which sheet
                                  sheet = "prefrontal"))

  # chrom.Data <- data.frame(read.xlsx(wb,  # now tell R to read that workbook and which sheet
  #                        sheet = "chrom_length"))   
}

# Replace any NULL entries in the Location columns with NA
## Location looks like "Chr22: 18.328774" "ChrX: 13.866617"  "ChrUn: 1.000000" 
## I will eventually extract bothe the Chromosome name and starting position of the gene

     prefront.Data$Location[prefront.Data$Location =="NULL"] <- NA



if (!exists('wpr')) {
  wpr <- loadWorkbook('mb_comt_top_pos_r_prefrontal.xlsx')   
}
if (!exists('topplusr.Data')) {
  topplusr.Data <- data.frame(read.xlsx(wpr,  # now tell R to read that workbook and which sheet
                                  sheet = "posr_prefront"))
}

if (!exists('wnr')) {
  wnr <- loadWorkbook('mb_comt_top_neg_r_prefrontal.xlsx')   
}
if (!exists('topminusr.Data')) {
  topminusr.Data <- data.frame(read.xlsx(wnr,  # now tell R to read that workbook and which sheet
                                  sheet = "negr_prefront"))
}


if (!exists('cbell.Data')) {

cbell.Data <- data.frame(read.xlsx(wb,         # now tell R to read that workbook and which sheet
                                  sheet = "cerebellum"))
}
     
# Replace any NULL entries in the Location columns with NA
## Location looks like "Chr22: 18.328774" "ChrX: 13.866617"  "ChrUn: 1.000000" 
## I will eventually extract bothe the Chromosome name and starting position of the gene

     cbell.Data$Location[cbell.Data$Location =="NULL"] <- NA

     
     

if (!exists('tempor.Data')) {

tempor.Data <- data.frame(read.xlsx(wb,         # now tell R to read that workbook and which sheet
                                  sheet = "temporal"))
}

# Replace any NULL entries in the Location columns with NA
## Location looks like "Chr22: 18.328774" "ChrX: 13.866617"  "ChrUn: 1.000000" 
## I will eventually extract bothe the Chromosome name and starting position of the gene

     tempor.Data$Location[tempor.Data$Location =="NULL"] <- NA
     
     
     
if (!exists('pons.Data')) {

pons.Data <- data.frame(read.xlsx(wb,         # now tell R to read that workbook and which sheet
                                  sheet = "pons"))
}

# Replace any NULL entries in the Location columns with NA
## Location looks like "Chr22: 18.328774" "ChrX: 13.866617"  "ChrUn: 1.000000" 
## I will eventually extract bothe the Chromosome name and starting position of the gene

     pons.Data$Location[pons.Data$Location =="NULL"] <- NA
     
     
     

if (!exists('ilmn')) {
  ilmn <- loadWorkbook('illumina_human_ref_8_v2.xlsx')   
}

if (!exists('illumina.Data')) {

illumina.Data <- data.frame(read.xlsx(ilmn,         # now tell R to read that workbook and which sheet
                                  sheet = "illumina"))
}

chrom.Names <- c(as.character(seq(1,22,1)),'X','Y')

# Use the hgu95av2.db and the hgu95av2CHRLENGTHS data to get the chromosome lengths

yy <- hgu95av2CHRLENGTHS
chrom.Data <- data.frame(chrom=chrom.Names,
                         chrom.Length=yy[chrom.Names]
)


### Note to convert r correlations into p values use these transformations
### store the results in a column in the original data frame - without the print statements
# example: r = 0.809, n = 138
# r.test(n = , r12 = )
# out.t <- r.test(n = 138, r12 = 0.809)
# print(out.t$t,digits=10)
# [1] 16.05025766
# pval <- 2*pt(-abs(t),df=n-2)
# pval <- 2*pt(-abs(print(out.t$t,digits=20)),df=136)
# print(pval,digits=10)

@

<<echo=FALSE>>=
### Strip all characters after : in Location
prefront.Data$loc <- sub("\\::*\\s[0-9]*\\.[0-9]*","",prefront.Data$Location)
# Results look like: "Chr22" "ChrX"  "ChrUn" "Chr11" "Chr11"
substring(prefront.Data$loc,1,3) <- "   "
prefront.Data$loc <- ordered(prefront.Data$loc)
### Get start locations from prefront.Data$Location
prefront.Data$bp <- as.numeric(sub('.*\\:', '', prefront.Data$Location))



########### Check for step that loses data when selecting specific chromosomes ##############
# prefront.Data$loc contains the chromosome number as a factor stripped from location
# prefront.Data$bp is the base pair location of the probe/gene within the chromosome
# head(prefront.Data$loc)
# head(prefront.Data$bp)


### Check and correct/update where possible gene symbols
### Need to remove '-' because R interprets it as math mode and halts when it doesn't find $
out.Symb <- checkGeneSymbols(prefront.Data$Symbol, unmapped.as.na=FALSE, hgnc.table=NULL)
prefront.Data$Symbol <-  out.Symb$Suggested.Symbol
prefront.Data$Symbol[which(prefront.Data$Symbol == '-')] <- c(".")

#### Clean illegal characters from the gene names: -
#grep('.*\\-',prefront.Data$Symbol)
prefront.Data$Symbol <- gsub("-", ".", prefront.Data$Symbol)

@

<<echo=FALSE>>=
### Strip all characters after : in Location
cbell.Data$loc <- sub("\\::*\\s[0-9]*\\.[0-9]*","",cbell.Data$Location)
substring(cbell.Data$loc,1,3) <- "   "
cbell.Data$loc <- ordered(cbell.Data$loc)
### Get start locations from cbell.Data$Location
cbell.Data$bp <- as.numeric(sub('.*\\:', '', cbell.Data$Location))


### Check and correct/update where possible gene symbols
### Need to remove '-' because R interprets it as math mode and halts when it doesn't find $
out.Symb <- checkGeneSymbols(cbell.Data$Symbol, unmapped.as.na=FALSE, hgnc.table=NULL)
cbell.Data$Symbol <-  out.Symb$Suggested.Symbol
cbell.Data$Symbol[which(cbell.Data$Symbol == '-')] <- c(".")

#### Clean illegal characters from the gene names: -
#grep('.*\\-',cbell.Data$Symbol)
cbell.Data$Symbol <- gsub("-", ".", cbell.Data$Symbol)

@

<<echo=FALSE, include=FALSE, results=hide>>=
########### Clean up cbell data ##############
# tempor.Data$loc contains the chromosome number as a factor stripped from location
# tempor.Data$bp is the base pair location of the probe/gene within the chromosome
# head(tempor.Data$loc)
# head(tempor.Data$bp)
### Strip all characters after : in Location
tempor.Data$loc <- sub("\\::*\\s[0-9]*\\.[0-9]*","",tempor.Data$Location)
substring(tempor.Data$loc,1,3) <- "   "
tempor.Data$loc <- ordered(tempor.Data$loc)
### Get start locations from tempor.Data$Location
tempor.Data$bp <- as.numeric(sub('.*\\:', '', tempor.Data$Location))


### Check and correct/update where possible gene symbols
### Need to remove '-' because R interprets it as math mode and halts when it doesn't find $
out.Symb <- checkGeneSymbols(tempor.Data$Symbol, unmapped.as.na=FALSE, hgnc.table=NULL)
tempor.Data$Symbol <-  out.Symb$Suggested.Symbol
tempor.Data$Symbol[which(tempor.Data$Symbol == '-')] <- c(".")

#### Clean illegal characters from the gene names: -
#grep('.*\\-',tempor.Data$Symbol)
tempor.Data$Symbol <- gsub("-", ".", tempor.Data$Symbol)

@

<<echo=FALSE, include=FALSE, results=hide>>=
########### Clean up cbell data ##############
# pons.Data$loc contains the chromosome number as a factor stripped from location
# pons.Data$bp is the base pair location of the probe/gene within the chromosome
# head(pons.Data$loc)
# head(pons.Data$bp)
pons.Data$loc <- sub("\\::*\\s[0-9]*\\.[0-9]*","",pons.Data$Location)
substring(pons.Data$loc,1,3) <- "   "
pons.Data$loc <- ordered(pons.Data$loc)
### Get start locations from pons.Data$Location
pons.Data$bp <- as.numeric(sub('.*\\:', '', pons.Data$Location))


### Check and correct/update where possible gene symbols
### Need to remove '-' because R interprets it as math mode and halts when it doesn't find $
out.Symb <- checkGeneSymbols(pons.Data$Symbol, unmapped.as.na=FALSE, hgnc.table=NULL)
pons.Data$Symbol <-  out.Symb$Suggested.Symbol
pons.Data$Symbol[which(pons.Data$Symbol == '-')] <- c(".")

#### Clean illegal characters from the gene names: -
#grep('.*\\-',pons.Data$Symbol)
pons.Data$Symbol <- gsub("-", ".", pons.Data$Symbol)

@


<<echo=FALSE>>=
### Function to take a vector of numbers, and turn it into a comma-separated string.

comma.Sep <- function(in.vec) {
  out.Sep <- c('')
    out.Sep <- c(paste(out.Sep,as.character(in.vec[1]),sep=''))
  
  if (length(in.vec) > 1) {
    
    for (q in 2:length(in.vec)) {
      out.Sep <- c(paste(out.Sep,', ',as.character(in.vec[q])))
    }

  } else {
    
  }
        
    return(out.Sep)
}

@



<<echo=FALSE, results=hide>>=
### Function to plot on equal-SD scaled square axes.
######################### Begin square.Axes function ###################################
square.Axes <- function(xvar,yvar,title.Text,xlabel.Text,ylabel.Text,corval) {
  
  dat <- data.frame(x = c(xvar), y = c(yvar))
  
  range.Lims.x <- c(mean(xvar) - 4*sd(xvar), mean(xvar) + 4*sd(xvar))
  range.Lims.y <- c(mean(yvar) - 4*sd(yvar), mean(yvar) + 4*sd(yvar))
  
  
  
  sq.Plt <-   ggplot(dat, aes(x=xvar,y=yvar)) +
    geom_point(color = "blue",size=1.0) + 
    geom_smooth(method=lm,   # Add linear regression line
                se=FALSE,
                color="yellow",
                size = 1)  +  # Don't add shaded confidence region
    #            theme(aspect.ratio=1) +
    # This adds  the little lines to each axis that represent the densities of the variables
    geom_rug() +    
    geom_abline(intercept = mean(yvar)  + (-sign(corval))*(mean(xvar)/sd(xvar))*sd(yvar),
                slope = sign(corval)*(sd(yvar)/sd(xvar)),
                linetype='dashed',
                size = 1) + 
    scale_y_continuous(name=ylabel.Text,
                       limits=range.Lims.y) +
    scale_x_continuous(name=xlabel.Text,
                       limits=range.Lims.x) +
    ggtitle(title.Text) + 
#    theme_minimal() + 
    theme_classic() + 
    theme(aspect.ratio=1) +
    theme(axis.line = element_line(colour = "grey80",size=1.0),
          panel.border = element_rect(colour = "grey80", fill=NA,
                                      size=2.5)) +
    theme(plot.title = element_text(color="black",
                                    face="bold",
                                    size=18,
                                    hjust=0.5)) +
    theme(axis.title = element_text(color="black",
                                    size=15)) +
    theme(axis.text.x = element_text(size=14),
          axis.text.y = element_text(size=14)) +
    geom_vline(xintercept = mean(xvar),
               col='red',
               size = 1) +
    geom_hline(yintercept = mean(yvar),
               col='red',
               size = 1) +
    annotate("text", x = mean(xvar)+3*sd(xvar),
             y = mean(yvar)+3.8*sd(yvar),
             label = c(paste('r = ',toString(corval),sep='')),
             color="black",
             size=5)
  
  return(sq.Plt) # This is what gets returned by the function. In this case it is an actual plot.
}                # <<<< This is actually the last stement in the function.
######
@


%%%%%%%%%%%%%%% Statistics

<<echo=FALSE, results=tex>>=
# prefront.Meanposr <- data.frame(mean=NA,corr=NA,chr=NA,gene=NA,bp=NA,pval=NA,record=NA)
# prefront.Meannegr <- data.frame(mean=NA,corr=NA,chr=NA,gene=NA,bp=NA,pval=NA,record=NA)
# prefront.Meanbothr <- data.frame(mean=prefront.Data$Mean,corr=prefront.Data$Sample.r,chr=prefront.Data$loc,
#                              gene=prefront.Data$Symbol,bp=prefront.Data$bp,pval=prefront.Data$Sample.p.r.,record=prefront.Data$Record)
# prefront.Meanbothr$corsign <- as.factor(sign(prefront.Data$Sample.r))

entrez_object <- org.Hs.egGO    # 

# Add a column with the sign of the correlation top each areal data.frame
prefront.Data$corsign <- as.factor(sign(prefront.Data$Sample.r))
cbell.Data$corsign <- as.factor(sign(cbell.Data$Sample.r))
tempor.Data$corsign <- as.factor(sign(tempor.Data$Sample.r))
pons.Data$corsign <- as.factor(sign(pons.Data$Sample.r))




############## **** Very important ****: To compare top correlations across areas, it is 
####### necessary that all areas share the same probes (and ENTREZIDs). For example,
####### to compare the top positive and negative correlations across areas to see which
####### (+ or -) shows the most consistency, all of the probes that were in the top
####### 50 positive correlations in prefrontal, have to also be in set of probes that
####### have correlations available in cerebellum, temporal and pons, and the same
####### holds for the top negative correlations.
####### **** Thus it is necessary to restrict the analysis to only those probes that are
####### in common across all four brain regions. The following code (down to the intersect)
####### statements determines which probes that also all have ENTREZIDs were shared
####### among the four brain areas


# Use the actual Illumina probes converted to ENTREZIDs in the data set


dim.areas <- matrix(c(dim(prefront.Data)[1],
                    dim(cbell.Data)[1],
                    dim(tempor.Data)[1],
                    dim(pons.Data)[1]),
                    nrow=4)

have.ENTREZ <- data.frame(indpf=c(1:dim.areas[1]),
                          ENTREZIDpf=rep(NA,dim.areas[1]),
                          ILMNpf=prefront.Data$Record,
                          indcb=c(1:dim.areas[1]),
                          ENTREZIDcb=rep(NA,dim.areas[2]),
                          ILMNcb=cbell.Data$Record,
                          indtm=c(1:dim.areas[1]),
                          ENTREZIDtm=rep(NA,dim.areas[3]),
                          ILMNtm=tempor.Data$Record,
                          indpo=c(1:dim.areas[1]),
                          ENTREZIDpo=rep(NA,dim.areas[4]),
                          ILMNpo=pons.Data$Record
                          )

# On an area by area basis separately, retrieve the ENTREZIDs for each Illumina probe.
have.Ent.pf <-na.omit(unlist(mget(x = prefront.Data$Record,envir=illuminaHumanv2ENTREZID)))   # n = 18724 of 20,000
have.Ent.cb <- na.omit(unlist(mget(x = cbell.Data$Record,envir=illuminaHumanv2ENTREZID)))      # n = 18726 of 20,000
have.Ent.tm <- na.omit(unlist(mget(x = tempor.Data$Record,envir=illuminaHumanv2ENTREZID)))     # n = 18698 of 20,000
have.Ent.po <- na.omit(unlist(mget(x = pons.Data$Record,envir=illuminaHumanv2ENTREZID)))       # n = 18713 of 20,000

# eliminate duplicates - these vectors show the unique ENTREZIDs in each brain area's data
# There are duplicates because there can be multiple ILMN probes for the same gene (ENTREZID)

############# Don't eliminate duplicates because the retention of rows will be done on the basis
############# of Illumina probe IDs which are unique
# notdups.pf <- which(!duplicated(have.Ent.pf))
# have.Ent.pf <- have.Ent.pf[c(notdups.pf),1]     
# 
# notdups.cb <- which(!duplicated(have.Ent.cb))
# have.Ent.cb <- have.Ent.cb[c(notdups.cb),1]
# 
# notdups.tm <- which(!duplicated(have.Ent.tm))
# have.Ent.tm <- have.Ent.tm[c(notdups.tm),1]
# 
# notdups.po <- which(!duplicated(have.Ent.po))
# have.Ent.po <- have.Ent.po[c(notdups.po),1]

entrez.By.area <- data.frame(num.entrez=c(length(have.Ent.pf),
                                          length(have.Ent.cb),
                                          length(have.Ent.tm),
                                          length(have.Ent.po)),
                             miss.entrez=c((20000 - length(have.Ent.pf)),
                                           (20000 -length(have.Ent.cb)),
                                           (20000 -length(have.Ent.tm)),
                                           (20000 -length(have.Ent.po)))
)

colnames(entrez.By.area) <- c('Number of Rows with ENTREZIDs','Number of Rows Missing ENTREZIDs')
row.names(entrez.By.area) <- c('Prefrontal Cortex',
                              'Cerebellum',
                              'Temporal Cortical Wall',
                              'Pons')

entrez.Area.tab <- xtable(entrez.By.area,
                         caption='Number of Unique ENTREZIDs in the Expression data\n for Each Brain Area. ENTREZIDs retrieved using ILMN identifiers.')
@

\Sexpr{entrez.Area.tab}\\


<<include=FALSE, echo=FALSE, results=tex>>=

# The vectors above hold only the rows with ENTREZIDs in each area.
# NAs have been eliminated, and there are no duplicates.

# Attach a column with the ENTREZIDs to each of the 20,000 rows data frames
# Don't eliminate the NAs
prefront.Data$ENTREZID <- unlist(mget(x = prefront.Data$Record,envir=illuminaHumanv2ENTREZID))   # n = 18724 without NA; 1276 with NA
cbell.Data$ENTREZID <- unlist(mget(x = cbell.Data$Record,envir=illuminaHumanv2ENTREZID))      # n = 18726 withput NA, 1274 with NA
tempor.Data$ENTREZID <- unlist(mget(x = tempor.Data$Record,envir=illuminaHumanv2ENTREZID))     # n = 18698 without NA, 1302 with NA
pons.Data$ENTREZID <- unlist(mget(x = pons.Data$Record,envir=illuminaHumanv2ENTREZID))       # n = 18713 without NA, 1287 with NA

# Use the Illumina Huamn ref 8 v 2 bead chip reference file to try to find additional ENTREZIDs
# data.frame illumina.Data

# Get the list of ILMN probes for each data.frame that do not have ENTREZIDs
no.Entrez.pf <- prefront.Data$Record[c(which(is.na(prefront.Data$ENTREZID)))]
no.Entrez.pf.indx <- which(is.na(prefront.Data$ENTREZID))

no.Entrez.cb <- cbell.Data$Record[c(which(is.na(cbell.Data$ENTREZID)))]
no.Entrez.cb.indx <- which(is.na(cbell.Data$ENTREZID))

no.Entrez.tm <- tempor.Data$Record[c(which(is.na(tempor.Data$ENTREZID)))]
no.Entrez.tm.indx <- which(is.na(tempor.Data$ENTREZID))

no.Entrez.po <- pons.Data$Record[c(which(is.na(pons.Data$ENTREZID)))]
no.Entrez.po.indx <- which(is.na(pons.Data$ENTREZID))

# Get the indices in the illumina.Data$ilmn vector for which the entry matches a probe in 
# no.Entrez.xx that does not have an ENTREZID attached

extra.ILMN.pf <- match(no.Entrez.pf,illumina.Data$ilmn)
extra.ILMN.cb <- match(no.Entrez.cb,illumina.Data$ilmn)
extra.ILMN.tm <- match(no.Entrez.tm,illumina.Data$ilmn)
extra.ILMN.po <- match(no.Entrez.po,illumina.Data$ilmn)


# The lengths of these vactors show that every ILMN with a missing ENTREZID has a match
# in the ilumina.Data$ilmn vector. This doesn't necessarily mean that the ENTREZID is there
# as well

# These hold the ENTREZIDs that were missing from the original data set, but were found in the Illumina data set
extra.Entrez.pf <- illumina.Data$entrez[c(extra.ILMN.pf)]
# num.NA(extra.Entrez.pf) = 0; all of the missing ENTREZIDs were recovered for prefrontal
extra.Entrez.cb <- illumina.Data$entrez[c(extra.ILMN.cb)]
# num.NA(extra.Entrez.cb) = 0; all of the missing ENTREZIDs were recovered for cerebellum
extra.Entrez.tm <- illumina.Data$entrez[c(extra.ILMN.tm)]
# num.NA(extra.Entrez.cb) # = 0; all of the missing ENTREZIDs were recovered for temporal
extra.Entrez.po <- illumina.Data$entrez[c(extra.ILMN.po)]
# num.NA(extra.Entrez.cb) # = 0; all of the missing ENTREZIDs were recovered for pons

# a. Set up a correspondence matrix that holds the index in the Illumina file of the probes for which there was not an ENTREZID in the <area>.Data$ENTREZID column
# b. With the index in the Illumina data file that has a probe ID that matches one listed as not having an ENTREZID (a.)
correspond.Data.ILMN.pf <- matrix(c(no.Entrez.pf.indx,extra.ILMN.pf),
                               ncol=2)
correspond.Data.ILMN.cb <- matrix(c(no.Entrez.cb.indx,extra.ILMN.cb),
                               ncol=2)
correspond.Data.ILMN.tm <- matrix(c(no.Entrez.tm.indx,extra.ILMN.tm),
                               ncol=2)
correspond.Data.ILMN.po <- matrix(c(no.Entrez.po.indx,extra.ILMN.po),
                               ncol=2)
corresp.Data.ILM <- list(correspond.Data.ILMN.pf,
                         correspond.Data.ILMN.cb,
                         correspond.Data.ILMN.tm,
                         correspond.Data.ILMN.po)


# For example, corresp.Data.ILM[[1]][1,1] = 7
# corresp.Data.ILM[[1]][1,2] = 6147
# Thus, prefront.Data$ENTREZID[7] has an ILMN of "ILMN_1683883" and is missing and ENTREZID
# illumina.Data[6147,] has an ILMN of "ILMN_1683883" and it has a corresponding entrez = 95
# The illumina.Data$entrez[6147] = 95 can be used to fill in the missing ENTREZID in
# prefront.Data$ENTREZID[7]

# use the indices in extra.ILMN.xx to fill in the missing ENTREZID values
#Both sides have lengths of 20000. There are NAs in te ENTREZID columns
prefront.Data$ENTREZID <- as.character(prefront.Data$ENTREZID)
illumina.Data$entrez <- as.character(illumina.Data$entrez)

prefront.Data$ENTREZID[c(corresp.Data.ILM[[1]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[1]][,2])]

cbell.Data$ENTREZID <- as.character(cbell.Data$ENTREZID)
cbell.Data$ENTREZID[c(corresp.Data.ILM[[2]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[2]][,2])]

tempor.Data$ENTREZID <- as.character(tempor.Data$ENTREZID)
tempor.Data$ENTREZID[c(corresp.Data.ILM[[3]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[3]][,2])]

pons.Data$ENTREZID <- as.character(pons.Data$ENTREZID)
pons.Data$ENTREZID[c(corresp.Data.ILM[[4]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[4]][,2])]

# All 20,000 rows in each areal data.frame have ENTREZIDs (no NAs)
# This means also that all Illumina probe IDs also have identifiers that are mapped to a gene (ENTREZID)
# All of the ENTREZIDs are unique - not duplicated.
# This doesn't mean that the set of ENTREZIDs for each <area>.Data data.frame is the same
# In other words, because the <area>.Data correlation files with 20,000 correlations were
# obtained ranked by the p-values of the correlations, and because there are more than
# 20,000 Illumina probes, the sets of probes do not have to correspond
num.NA(prefront.Data$ENTREZID)    # n = 0 NA
num.NA(cbell.Data$ENTREZID)   # n = 0 NA
num.NA(tempor.Data$ENTREZID)  # n = 0 NA
num.NA(pons.Data$ENTREZID)    # n = 0 NA


# Next, intersect on the basis of ENTREZID (which is necessary to look up missing chromosomes;
# the ones that are listed as 'Un'). This will store only the ENTREZIDs that are in common
# across all four brain areas


all.areas.ENTREZID <- intersect(pons.Data$ENTREZID,intersect(tempor.Data$ENTREZID,intersect(prefront.Data$ENTREZID,cbell.Data$ENTREZID)))    # length = 13027

# all.areas.ENTREZID now holds all of the ENTREZIDs shared across all four brain areas


# Before finding the set of common Illumina probes across all areas, first try to find the 
# missing Chromosomes for each <area>.Data separately.
# Leverage the fact that the set of Illumina probes differs across areas, and some could be
# missing a chromosome name in one area while the same probe has the Chromosome in another area.

# Get the union of all Illumina probes across areas. First extract the probes, entrezids 
# and chromosomes into a data frame for each area

illum.entr.chr.pf <- data.frame(illum=prefront.Data$Record,
                                entrez=prefront.Data$ENTREZID,
                                chr=prefront.Data$loc)
illum.entr.chr.cb <- data.frame(illum=cbell.Data$Record,
                                entrez=cbell.Data$ENTREZID,
                                chr=cbell.Data$loc)
illum.entr.chr.tm <- data.frame(illum=tempor.Data$Record,
                                entrez=tempor.Data$ENTREZID,
                                chr=tempor.Data$loc)
illum.entr.chr.po <- data.frame(illum=pons.Data$Record,
                                entrez=pons.Data$ENTREZID,
                                chr=pons.Data$loc)

# Next get the union of all Illumina probes across the four areas

union.Illum.pfcb <- union(illum.entr.chr.pf$illum,illum.entr.chr.cb$illum)   # length 22016
union.Illum.pfcbtm <- union(union.Illum.pfcb,illum.entr.chr.tm$illum)     # length 22151
union.Illum.all <- union(union.Illum.pfcbtm,illum.entr.chr.po$illum)   # length 22180
# There are 22180 different probes across all four areas

diff.Probe.num <- matrix(c(rep(0,6)),nrow=6)
# Get the number of probe differences between each area
diff.Probe.num[1] <- length(setdiff(illum.entr.chr.pf$illum,illum.entr.chr.cb$illum))
diff.Probe.num[2] <- length(setdiff(illum.entr.chr.pf$illum,illum.entr.chr.tm$illum))
diff.Probe.num[3] <- length(setdiff(illum.entr.chr.pf$illum,illum.entr.chr.po$illum))
diff.Probe.num[4] <- length(setdiff(illum.entr.chr.cb$illum,illum.entr.chr.tm$illum))
diff.Probe.num[5] <- length(setdiff(illum.entr.chr.cb$illum,illum.entr.chr.po$illum))
diff.Probe.num[6] <- length(setdiff(illum.entr.chr.tm$illum,illum.entr.chr.po$illum))

row.names(diff.Probe.num) <- c('Prefrontal Cortex vs. Ceberebellum',
                               'Prefrontal Cortex vs. Temporal Cerebral Wall',
                               'Prefrontal Cortex vs. Pons',
                               'Cerebellum vs. Temporal Cerebral Wall',
                               'Cerebellum vs. Pons',
                               'Temporal Cerebral Wall vs. Pons'
                               )
colnames(diff.Probe.num) <- c('Number of Illumina Probe Differences')

diff.Probe.tab <- xtable(diff.Probe.num,
                         caption='Number of Illumina Probe Differences Between Brain Areas:\n Base of 20,000 Probes per Area',digits=0)

@

\Sexpr{diff.Probe.tab}\\

<<include=FALSE, echo=FALSE, results=tex>>=
# Before getting the probes in common across all four brain areas, try finding the missing
# Chromosome names and gene starting positions in each area separately
# Next, try to get the Chromosomes for the entries that have 'Un' as the loc column.
# Note: these entries are not necessarily the same in all four data sets
# First, eliminate the 3 spaces in front of every chromosome (loc)
prefront.Data$loc <- gsub('   ','',as.character(prefront.Data$loc))  # n = 2055
cbell.Data$loc <- gsub('   ','',as.character(cbell.Data$loc))        # n = 247
tempor.Data$loc <- gsub('   ','',as.character(tempor.Data$loc))      # n = 2042
pons.Data$loc <- gsub('   ','',as.character(pons.Data$loc))          # n = 2027

#Need to convert all NULL values to NA
prefront.Data$loc[prefront.Data$loc =="NULL"] <- NA
cbell.Data$loc[cbell.Data$loc =="NULL"] <- NA
tempor.Data$loc[tempor.Data$loc =="NULL"] <- NA
pons.Data$loc[pons.Data$loc =="NULL"] <- NA

# Do the same for NULL values in bp position
prefront.Data$bp[prefront.Data$bp =="NULL"] <- NA
cbell.Data$bp[cbell.Data$bp =="NULL"] <- NA
tempor.Data$bp[tempor.Data$bp =="NULL"] <- NA
pons.Data$bp[pons.Data$bp =="NULL"] <- NA


where.Un.pf <- which(as.character(prefront.Data$loc) == 'Un')
where.Un.cb <- which(cbell.Data$loc == 'Un')
where.Un.tm <- which(tempor.Data$loc == 'Un')
where.Un.po <- which(pons.Data$loc == 'Un')

num.NA(prefront.Data$loc)
length(where.Un.pf)


# Note: in prefrontal there are more locations that lack chromosome names (1313) than have entries of 1 for the location of the gene (1222). In other words, some of the rows that have the starting location of the gene, do not have the chromosome name.

# This stores the indices of each data.frame that has 1 as the starting location of the probe
where.1.bp.pf <- which(prefront.Data$bp == 1)
where.1.bp.cb <- which(cbell.Data$bp == 1)
where.1.bp.tm <- which(tempor.Data$bp == 1)
where.1.bp.po <- which(pons.Data$bp == 1)

common.df <- data.frame(matrix(c(unpf=length(where.Un.pf),
                        uncb=length(where.Un.cb),
                        untm=length(where.Un.tm),
                        unpo=length(where.Un.po),
                        bpmisspf=length(where.1.bp.pf),
                        bpmisscb=length(where.1.bp.cb),
                        bpmisstm=length(where.1.bp.tm),
                        bpmisspo=length(where.1.bp.po)),
                        nrow=4,ncol=2,byrow=FALSE
                        ))
colnames(common.df) <- c('n Missing Chr ','n Missing start loc')
row.names(common.df) <- c('prefrontal cortex','cerebellum','temporal cortex','pons')

@

\Sexpr{print(common.df)}\\

The table shows that the brain areas differ both on the number of missing chromosomes and on the number of missing gene starting positions.\\

<<include=FALSE, echo=FALSE, results=text>>=
# Recover missing 'Un' chromosomes
if (!exists('ensembl')) {
 ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
}

if (!exists('entrezg')) {
 entrezg <- useMart("entrezgene", dataset = "hsapiens_gene_ensembl")
}

normal.chroms <- c(1:22, "X", "Y", "M")

if (!exists('ah')) {
 ah <- AnnotationHub()
}

if (!exists('orgs')) {
 orgs <- AnnotationHub::query(ah, "org.Hs.eg.db")
}

if (!exists('gene.DB')) {
 gene.DB <- orgs[["AH57973"]]
}



# columns(gene.DB)
# keytypes(gene.DB)

############### Start: find and fill in missing CHR and probe start positions (bp)######
### USE ENTREZIDs to find the missing chromosomes
############### prefrontal #############################################################
## Bimap interface:
x <- org.Hs.egCHR
# Get the entrez gene identifiers that are mapped to a chromosome
mapped_genes <- mappedkeys(x)
# Convert to a list
xx <- as.list(x[mapped_genes])

@


Ther strategy for finding missing Chromosome names and gene starting positions is this:

\begin{enumerate}
     \item Use bioconductor and biomart to try to find the missing information based either on ENTREZIDs or Illumina Probe IDs
     \item Use the data file illumina_human_ref_8_v2.xlsx to look up remaining missing information.
\end{enumerate}

<<include=FALSE, echo=FALSE, results=tex>>=

# Replace any NULL entries with NA
prefront.Data$loc[prefront.Data$loc =="NULL"] <- NA

# this code returns the chromosome name given the entrezid
     temp.CHR.pf <- as.character(na.omit(xx[prefront.Data$ENTREZID[c(where.Un.pf)]]))
# There are 2055 with CHR labeled as 'Un'. The above vector holds the recovered Chr names
# for al 2055 of these.

na.missCHR.pf  <- num.NA(temp.CHR.pf)  
 # 0 - there are a additional 22 missing chromosomes that could not be found using ENTREZIDs

# 2055 ('Un') were without chromosome names

# The number originally missing CHRs includes those labeled as 'Un' 
num.Chr.recov <- matrix(c(length(temp.CHR.pf),(common.df[1,1] + na.missCHR.pf),
                        0,0,
                        0,0,
                        0,0),
                        ncol=2,byrow=TRUE)

colnames(num.Chr.recov) <- c('Number Chr recovered','Number initially missing')
row.names(num.Chr.recov) <- c('Prefrontal Cortex',
                              'Cerebellum',
                              'Temporal Cortical Wall',
                              "Pons")

# It appears that the above method was able to retrive the Chr names for all of the missing ones


# There are no additional missing chromosome names, so the next method is not necessary
# Try to get the missing Chrs from the illumina data

## --->   remain.noChr.pf <- which(is.na(prefront.Data$loc))

# All of the missing Chr rows have illumina IDs that match those in te illumina.Data$ilmn

## ---> illum.indx.pf <- match(prefront.Data$Record[remain.noChr.pf],illumina.Data$ilmn)

# Now determine if those cases also have entries for the corresponding entrez values.

## ---> prefront.Data$loc[remain.noChr.pf] <- gsub('chr','',sub("(*\\:[0-9]*\\-[0-9]*)+", "", illumina.Data$loc[matched.Illum.pf]))


# The next variable holds the indices of the captured illumina IDs in the prefront.Data

## ---=> matched.Illum.pf <- match(prefront.Data$Record[illum.indx.pf],illumina.Data$ilmn)

# Note: there are corresponding ILMN values for all but 2 of these illumina probes
# that were missing Chr numbers
# Now need to find the entrezids of the ilmn probes from the illumina data 

## ---> found.entrez.pf <- illumina.Data$entrez[matched.Illum.pf]


###### Return to the 'Un' cases

# This match() function pulls out only the ones that were indicated by where.Un.pf. It is necessary if there are more Chr names in temp.CHR.pf than the 'Un' entries in the original data

## --->  wh.Match.CHR.pf <- match(prefront.Data.sel$ENTREZID[c(where.Un.pf)],temp.CHR.pf)

## ---=>  wh.Match.CHR.pf holds the indices (in the temp.CHR.pf$CHR variable) given the original 
# missing locations

# Now replace the Un entries with known chromosomes in prefront.Data$loc
prefront.Data$loc[c(where.Un.pf)] <- temp.CHR.pf
# This replaces 2055 of the missing CHR values.



num.Chr.recov[1,1] <- num.Chr.recov[1,2] - na.missCHR.pf


############### End prefrontal #############################################################
@
Using the two sources of information, I was able to find all of the missing Chromosome names of the originally missing \Sexpr{num.Chr.recov[1,2]} in the prefrontal data set. \\


<<include=FALSE, echo=FALSE, results=tex>>=

############### Start: find and fill in missing CHR ######
############### cerebellum #############################################################
# Replace any NULL entries with NA
cbell.Data$loc[cbell.Data$loc =="NULL"] <- NA

# this code returns the chromosome name given the exntrezid for those entries that were origionally labeled as 'Un'
     temp.CHR.cb <- as.character(na.omit(xx[cbell.Data$ENTREZID[c(where.Un.cb)]]))
# There are 2047 with CHR labeled as 'Un'
     
na.missCHR.cb  <- num.NA(temp.CHR.cb)  
 # 0 - there are no additional NA missing chromosomes that could not be found using ENTREZIDs

# 2047 ('Un') + 0 (NAs) == 2047 without chromosome names

# Now replace the Un entries with known chromosomes in cbell.Data$loc
cbell.Data$loc[c(where.Un.cb)] <- temp.CHR.cb
# This replaces all 2047 of the missing CHR values.


###### There are no additional missing chromosome names, so the next method is not necessary.

# The next variable holds the indices of the captured illumina IDs in the cbell.Data

## --> matched.Illum.cb <- match(cbell.Data$Record[illum.indx.cb],illumina.Data$ilmn)

# Note: there are corresponding ILMN values for all but 2 of these illumina probes
# that were missing Chr numbers
# Now need to find the entrezids of the ilmn probes from the illumina data 

## --> found.entrez.cb <- illumina.Data$entrez[matched.Illum.cb]

# Now use the found entrezids to try to get the chromosome name.

# This match() function pulls out only the ones that were indicated by where.Un.cb

## ---> wh.Match.CHR.cb <- match(cbell.Data.sel$ENTREZID[c(where.Un.cb)],temp.CHR.cb)

## --->  wh.Match.CHR.cb holds the indices (in the temp.CHR.cb$CHR variable) given the original 
# missing locations

# Try to get the missing Chrs from the illumina data

## ---> remain.noChr.cb <- which(is.na(cbell.Data$loc))

# All of the missing Chr rows have illumina IDs that match those in te illumina.Data$ilmn

## ---> illum.indx.cb <- match(cbell.Data$Record[remain.noChr.cb],illumina.Data$ilmn)

# Now determine if those cases also have entries for the corresponding entrez values.

## --- > cbell.Data$loc[remain.noChr.cb] <- gsub('chr','',sub("(*\\:[0-9]*\\-[0-9]*)+", "", illumina.Data$loc[matched.Illum.cb]))

# Result is: "chr2"  "chr1"  "chr11" NA      "chr21" ... ---> '2', '1' ...

#This leaves only 3 rows with NA as missing chromosome
num.NA(cbell.Data$loc)

num.Chr.recov[2,1:2] <- c(length(temp.CHR.cb),(common.df[2,1] + na.missCHR.pf))

############### End cerebellum #############################################################

@

<<include=FALSE, echo=FALSE, results=tex>>=
############### Start: find and fill in missing CHR and probe start positions (bp)######
############### temporal #############################################################

# Replace any NULL entries with NA
tempor.Data$loc[tempor.Data$loc =="NULL"] <- NA

temp.CHR.tm <- as.character(na.omit(xx[tempor.Data$ENTREZID[c(where.Un.tm)]]))

na.missCHR.tm  <- num.NA(temp.CHR.tm)  

num.Chr.recov[3,1:2] <- c(length(temp.CHR.tm),(common.df[3,1] + na.missCHR.tm))

# Regardless of whether or not there are duplicates in temp.CHR.pf, this match() function
# pulls out only the ones that were indicated by where.Un.pf

#wh.Match.CHR.tm <- match(tempor.Data.sel$ENTREZID[c(where.Un.tm)],temp.CHR.tm)

# wh.Match.CHR.pf holds the indices (in the temp.CHR.pf$CHR variable) given the original 
# missing locations

# Now replace the Un entries with known chromosomes in prefront.Data.sel$loc

tempor.Data$loc[c(where.Un.tm)] <- as.character(temp.CHR.tm)

############### End temporal #############################################################

@


<<include=FALSE, echo=FALSE, results=tex>>=
############### Start: find and fill in missing CHR and probe start positions (bp)######
############### pons #############################################################

# Replace any NULL entries with NA
pons.Data$loc[pons.Data$loc =="NULL"] <- NA

temp.CHR.po <- as.character(na.omit(xx[pons.Data$ENTREZID[c(where.Un.po)]]))

na.missCHR.po  <- num.NA(temp.CHR.po)

num.Chr.recov[4,1:2] <- c(length(temp.CHR.po),(common.df[4,1] + na.missCHR.po))

# Regardless of whether or not there are duplicates in temp.CHR.pf, this match() function
# pulls out only the ones that were indicated by where.Un.pf

#wh.Match.CHR.po <- match(pons.Data.sel$ENTREZID[c(where.Un.po)],temp.CHR.po)

# wh.Match.CHR.pf holds the indices (in the temp.CHR.pf$CHR variable) given the original 
# missing locations

# Now replace the Un entries with known chromosomes in prefront.Data.sel$loc

pons.Data$loc[c(where.Un.po)] <- temp.CHR.po

############### End pons #############################################################
@

\Sexpr{print(num.Chr.recov)}
All missing chromosome names in all brain areas were recovered; there are no "Un" nor NA entries.\\


<<include=FALSE, echo=FALSE, results=tex>>=
# Now use the same strategy to find and fill in the rows with $bp == 1


###################### Prefrontal

# Replace any NULL entries with NA
prefront.Data$bp[prefront.Data$bp =="NULL"] <- NA

bp.Temp.pf <- data.frame(getBM(attributes = c("entrezgene","start_position","end_position"), filters = "entrezgene", values = as.character(prefront.Data$ENTREZID[c(where.1.bp.pf)]),mart = ensembl))

bp.Temp.pf$chr <- as.character(prefront.Data$loc[c(where.1.bp.pf)]) 

# The basic problem at this point is that in attempting to retrieve the starting positions


# Notice:
missing.bp.pf <- length(where.1.bp.pf)
retrieved.bp.pf <- dim(bp.Temp.pf)[1]
# n = 2113 missing bp from original data
# n = 2264 start positions retrieved based on those missing start positions
# This happens because the start positions are retrieved for genes, and there can be multiple
# transcripts per ENTREZID

dup.bp.pf <- sum(duplicated(bp.Temp.pf[,1]))
# There are 418 duplicated ENTREZIDs in the original data. Some of these are duplicatded 
# several times. There is no need to change these duplicated genes because they probably have
# different probes associated with them.

# On the other hand, having multiple possible starting positions with only one missing slot, is
# more problematic. One solution might be to check the ILMN in the original file against the ILMN # in the illumina.Data data set to see if they correspond. If they do, and there is a starting
# position in the illumina.Data file, then that one could be used. Unfortunately, the illumina.Data file has the starting location information embedded with the chromosome.  

# Try to reduce the number of retrieved starting positions in bp.Temp.pf to the number in
# missing.bp.pf 2264 to 2113

# Search for the starting position extracted from the illumina.Data data set, and if there
# is a match, then compare the two and if there is agreement, then use the starting position
# matches in the two data sets.

# First, extract the starting positions from the illumina.Data
temp.Start.pf <- sub("chr[\\::[X-Y0-9]*\\:","",illumina.Data$loc)
illumina.Data$startp <- sub("-[0-9]*\\:*[0-9]*-*[0-9]*","",temp.Start.pf)
illumina.Data$startp <- as.integer(illumina.Data$startp)

hold.pos.pf <- which(bp.Temp.pf$start_position %in% illumina.Data$startp)


for (rt in 1:length(bp.Temp.pf$start_position)) {
     
    if (bp.Temp.pf$start_position[rt] == illumina.Data$startp[1:dim(illumina.Data)[1]]) {
         
        bp.Temp.pf$inIll[rt] <-  c(1)
    } else {
         bp.Temp.pf$inIll[rt] <- c(0)
    }
     
}

sum(bp.Temp.pf$start_position[3] %in% illumina.Data$startp)

# How many of the rows that are missing start locations (bp) have ILMN IDs that match IDs in the illumina.Data?

illum.Match.illum.pf <- match(prefront.Data$Record[c(where.1.bp.pf)],illumina.Data$ilmn)



alt.Start.pf <- getBM(attributes = c("entrezgene","start_position","end_position",
                     "chromosome_name",'external_gene_name'), filters = "entrezgene", values = as.character(prefront.Data$ENTREZID[c(where.1.bp.pf)]),mart = ensembl)

############ using library nuID

illumina.Data$cleanseq <- sub(' Experimental','',illumina.Data$Reporter.Sequence)
temp.nuID <- seq2id(illumina.Data$cleanseq)
illumina.Data$nuID <- temp.nuID


if (exists('temp.nuID')) {
     rm(temp.nuID)
}


nuIDs <- illumina.Data$nuID
       ## return all mapping information
     if (require(lumiHumanIDMapping)) nuID2EntrezID(nuIDs[1:10], lib.mapping='lumiHumanIDMapping')

mappingInfo <- nuID2EntrezID(nuIDs[1:10], lib.mapping='lumiHumanIDMapping', returnAllInfo =TRUE)
head(mappingInfo)

if (require(lumiHumanAll.db)) lookUp(nuIDs[4], "lumiHumanAll.db", what="ENTREZID")
num.NA(getSYMBOL(nuIDs, "lumiHumanAll.db"))
num.NA(illumina.Data$symbol)

# There are 3924 probes in the illumina.Data file for which the unique sequence identifiers nuIDs
# cannot retrieve their gene symbols.


# The ENTREZID values were originally set using:
     # unlist(mget(x = prefront.Data$Record,envir=illuminaHumanv2ENTREZID))
# But there are apparent differences between getting the ENTREZID that way versus what
# is shown in the illumina.Data data. For example, the third row in prefront.Data is missing Chr name and start position. Its illumina ID is ILMN_1695598 and the ENTREZID is 6141.
# That same illumina ID, ILMN_1695598, occurs in row 15571 of the illumina.Data data, and
# there, the ENTREZID is 441775. The gene symbol is the same.

# Need to compare the two methods in terms of what they show as the ENTREZID

entrez.By.mget <- data.frame(illum = prefront.Data$Record[c(where.1.bp.pf)],
                             entrez=unlist(mget(x = as.character(prefront.Data$Record[c(where.1.bp.pf)]),envir=illuminaHumanv2ENTREZID)))

entrez.By.lookup <- data.frame(illum = illumina.Data$ilmn[c(illum.Match.illum.pf)],
                               entrez = illumina.Data$entrez[c(illum.Match.illum.pf)])

compare.Entrez <- data.frame(mgillum=entrez.By.mget$illum,
                             mgentrez=entrez.By.mget$entrez,
                             luillum=entrez.By.lookup$illum,
                             luentrez=entrez.By.lookup$entrez)
     
     
dg <- as.character(compare.Entrez$mgentrez) == as.character(compare.Entrez$luentrez)

table(dg)
#dg
# FALSE  TRUE 
#   55  1949 

# There are 55 of  2113 rows in the set that was missing starting locations where the ENTREZID
# obtained using bioconductor mget differs from the one that was obtained by looking
# up the illumina probe ID in the illumina.Data data.frame.

# The ENTREZIDs obtained from the web are more likely to be up-to-date, so the mget method will be used.

# Problem as below: length(bp.Temp.xx) > length(where.1.bp.pf) because multiple probes can be used for a single gene. bp.Temp.pf has 93 more entries than where.Un.pf. Some of the entrezgene values repeat in bp.Temp

num.StartPos.recov <- matrix(c(length(bp.Temp.pf$start_position),common.df[1,2],
                        0,0,
                        0,0,
                        0,0),
                        ncol=2,byrow=TRUE)

colnames(num.StartPos.recov) <- c('Number Gene Starting Positions Recovered','Number initially missing')
row.names(num.StartPos.recov) <- c('Prefrontal Cortex',
                              'Cerebellum',
                              'Temporal Cortical Wall',
                              "Pons")

# This pulls out only one occurrence of each entrezgene that was in the missing list

wh.Match.bp.pf <- match(prefront.Data$ENTREZID[c(where.1.bp.pf)],bp.Temp.pf$entrezgene)

# Now fill in the rows with missing probe start positions

prefront.Data$bp[c(where.1.bp.pf)] <- round((bp.Temp.pf$start_position[c(wh.Match.bp.pf)])/1000000.,3)

####################### Cerebellum
# Now use the same strategy to find and fill in the rows with $bp == 1

bp.Temp.cb <- getBM(attributes = c("entrezgene", "start_position"), filters = "entrezgene", values = as.character(cbell.Data$ENTREZID[c(where.1.bp.cb)]),mart = ensembl)

num.StartPos.recov[2,1:2] <- c(length(bp.Temp.cb$start_position),common.df[2,2])

# problem as below: length(bp.Temp) > length(where.Un.pf) because multiple probes can be used for a single gene. bp.Temp has 55 more entries than where.Un.pf. Some of the entrezgene values repeat in bp.Temp

# This pulls out only one occurrence of each entrezgene that was in the missing list

wh.Match.bp.cb <- match(cbell.Data$ENTREZID[c(where.1.bp.cb)],bp.Temp.cb$entrezgene)

# Now fill in the rows with missing probe start positions

cbell.Data$bp[c(where.1.bp.cb)] <- round((bp.Temp.cb$start_position[c(wh.Match.bp.cb)])/1000000.,3)
####################### Temporal
# Now use the same strategy to find and fill in the rows with $bp == 1

bp.Temp.tm <- getBM(attributes = c("entrezgene", "start_position"), filters = "entrezgene", values = as.character(tempor.Data$ENTREZID[c(where.1.bp.tm)]),mart = ensembl)

num.StartPos.recov[3,1:2] <- c(length(bp.Temp.tm$start_position),common.df[3,2])

# problem as below: length(bp.Temp) > length(where.Un.pf) because multiple probes can be used for a single gene. bp.Temp has 55 more entries than where.Un.pf. Some of the entrezgene values repeat in bp.Temp

# This pulls out only one occurrence of each entrezgene that was in the missing list

wh.Match.bp.tm <- match(tempor.Data$ENTREZID[c(where.1.bp.tm)],bp.Temp.tm$entrezgene)

# Now fill in the rows with missing probe start positions

tempor.Data$bp[c(where.1.bp.tm)] <- round((bp.Temp.tm$start_position[c(wh.Match.bp.tm)])/1000000.,3)

####################### Pons

bp.Temp.po <- getBM(attributes = c("entrezgene", "start_position"), filters = "entrezgene", values = as.character(pons.Data$ENTREZID[c(where.1.bp.po)]),mart = ensembl)


num.StartPos.recov[4,1:2] <- c(length(bp.Temp.po$start_position),common.df[4,2])

# problem as below: length(bp.Temp) > length(where.Un.pf) because multiple probes can be used for a single gene. bp.Temp has 55 more entries than where.Un.pf. Some of the entrezgene values repeat in bp.Temp

# This pulls out only one occurrence of each entrezgene that was in the missing list

wh.Match.bp.po <- match(pons.Data$ENTREZID[c(where.1.bp.po)],bp.Temp.po$entrezgene)

# Now fill in the rows with missing probe start positions

pons.Data$bp[c(where.1.bp.po)] <- round((bp.Temp.po$start_position[c(wh.Match.bp.po)])/1000000.,3)

############### End pons #############################################################

@


\Sexpr{print(num.StartPos.recov)}\\
All of the missing start positions were recovered for all four brain areas.\\

The expression correlation data from all four areas (20,000 per area), now has complete Chromosome name and gene starting position data.\\

<<include=FALSE, echo=FALSE, results=tex>>=
# Write out the complete data files to be used in subsequent analyses

# write.csv(prefront.Data,'prefront_20000_corr_complete_chr_startpos.csv')
# write.csv(cbell.Data,'cbell_20000_corr_complete_chr_startpos.csv')
# write.csv(tempor.Data,'tempor_20000_corr_complete_chr_startpos.csv')
# write.csv(pons.Data,'pons_20000_corr_complete_chr_startpos.csv')


@

<<include=FALSE, echo=FALSE, results=tex>>=
# Try intersecting directly on the basis of Illumina probes
all.areas.ILMN <- intersect(pons.Data$Record,intersect(tempor.Data$Record,intersect(prefront.Data$Record,cbell.Data$Record)))    # length = 14919

# all.areas.ILMN now holds all of the Illumina probes (n = 14919) shared across all four brain areas

# Because all.areas.ILMN has more probes in common across the four brain areas, it would make more sense to use that list of probes as the in-common list rather than the in-common ENTREZIDs

# Store the index for each of the in-common ILMN separately by area
# In other words for each of the 14919 Illumina probes in common across the four areas
# what is the oridinal position of each of those probes in each of the xx.Data dataframes

###### First, sort the data files by probability of r

prefront.Data <- prefront.Data[order(prefront.Data$Sample.p.r.),]
cbell.Data <- cbell.Data[order(cbell.Data$Sample.p.r.),]
tempor.Data <- tempor.Data[order(tempor.Data$Sample.p.r.),]
pons.Data <- pons.Data[order(pons.Data$Sample.p.r.),]

all.Indx.pf <- match(all.areas.ILMN,prefront.Data$Record)
all.Indx.cb <- match(all.areas.ILMN,cbell.Data$Record)
all.Indx.tm <- match(all.areas.ILMN,tempor.Data$Record)
all.Indx.po <- match(all.areas.ILMN,pons.Data$Record)

all.Indx.ilmn <- matrix(c(all.Indx.pf, all.Indx.cb, all.Indx.tm, all.Indx.po),
                   ncol=4)  # 14919 x 4


# A = intersect(prefront.Data$Record,cbell.Data$Record)  n = 17984
# B = intersect(tempor.Data$Record,A)   n = 16405
# intersect(pons.Data$Record,B)   n = 14919

##### ***** Another option, would be just to compare the other three areas to Prefrontal instead of all to each other ***** ###### 

## Proceed using only those ILMNs held in common across the 4 areas

# All of these reduced data sets contain only those rows with the same Illumina probes (not
# necessarily in the same order) in common across all 4 brain areas
######### In common by ENTREZID
     # prefront.Data.sel <- prefront.Data[match(all.areas.ENTREZID,as.character(prefront.Data$ENTREZID)),]
     # cbell.Data.sel <- cbell.Data[match(all.areas.ENTREZID,as.character(cbell.Data$ENTREZID)),]
     # tempor.Data.sel <- tempor.Data[match(all.areas.ENTREZID,as.character(tempor.Data$ENTREZID)),]
     # pons.Data.sel <- pons.Data[match(all.areas.ENTREZID,as.character(pons.Data$ENTREZID)),]
######### END In common by ENTREZID

######### In common by ILMN
# Each of these reduced data frames is 14919 x 18
     prefront.Data.sel <- prefront.Data[c(all.Indx.ilmn[,1]),]
     cbell.Data.sel <- cbell.Data[c(all.Indx.ilmn[,2]),]
     tempor.Data.sel <- tempor.Data[c(all.Indx.ilmn[,3]),]
     pons.Data.sel <- pons.Data[c(all.Indx.ilmn[,4]),] 
     
     # reorder thesae reduced data sets by p-val
     prefront.Data.sel <- prefront.Data.sel[order(prefront.Data.sel$Sample.p.r.),]
     cbell.Data.sel <- cbell.Data.sel[order(cbell.Data.sel$Sample.p.r.),]
     tempor.Data.sel <- tempor.Data.sel[order(tempor.Data.sel$Sample.p.r.),]
     pons.Data.sel <- pons.Data.sel[order(pons.Data.sel$Sample.p.r.),]
     
     
######### END In common by ILMN     
     
##############################

@




<<include=FALSE, echo=FALSE, results=tex>>=
# For use in other scripts that require the same set of probes across all four areas:
# write out the four dataframes to a csv file


prefront.Data.sel$Description <- gsub(', ',' ',prefront.Data.sel$Description)
prefront.Data.sel$Description <- gsub('mRNA.','mRNA',prefront.Data.sel$Description)

write.csv(prefront.Data.sel,"mb_comt_prefront_shared_probes.csv")
write.csv(cbell.Data.sel,"mb_comt_cbell_shared_probes.csv")
write.csv(tempor.Data.sel,"mb_comt_tempor_shared_probes.csv")
write.csv(pons.Data.sel,"mb_comt_pons_shared_probes.csv")

@



<<include=FALSE, echo=FALSE, results=tex>>=
Adim <- dim(prefront.Data.sel)[1]
Bdim <- dim(cbell.Data.sel)[1]
Cdim <- dim(tempor.Data.sel)[1]
Ddim <- dim(pons.Data.sel)[1]
diff.Dims <- matrix(c(Adim-Bdim,
                    Adim-Cdim,
                    Adim-Ddim,
                    Bdim-Cdim,
                    Bdim-Ddim,
                    Cdim-Ddim),
                    nrow=6)
if (sum(diff.Dims != 0)) {
     print('the dataframes differ in size')
} else {
     print('the dataframes are the same size')
}

@

<<include-FALSE, echo=FALSE, results=tex>>=
# Order the dataframe for each area independently by the correlation

prefront.Data.sel <- prefront.Data.sel[order(prefront.Data.sel$Sample.r,decreasing=TRUE),]
cbell.Data.sel <- cbell.Data.sel[order(cbell.Data.sel$Sample.r,decreasing=TRUE),]
tempor.Data.sel <- tempor.Data.sel[order(tempor.Data.sel$Sample.r,decreasing=TRUE),]
pons.Data.sel <- pons.Data.sel[order(pons.Data.sel$Sample.r,decreasing=TRUE),]

@


<<include-FALSE, echo=FALSE, results=tex>>=
# Table of frequencies of pos and neg correlated genes per chromosome


df2 <- data.frame(table(as.factor(prefront.Data.sel$loc),prefront.Data.sel$corsign))
# 23=UN, 24=X, 25=Y
df2 <- data.frame(df2,chr=rep(c(1,10,11,12,13,14,15,16,17,18,19,2,20,21,22,3,4,5,6,7,8,9,23,24),2))
colnames(df2) <- c('origchr','corsign','freq','chr')
df2$chr <- as.numeric(df2$chr)
dfsort <-df2[order(df2$corsign,df2$chr), ]


### First column is redundant
dfsort <- dfsort[,2:4]
dfsort <- dfsort[,c(3,1,2)]
dfsort$chr <- ordered(dfsort$chr)

posrmeans.pf <- prefront.Meanbothr$mean[which(prefront.Meanbothr$corr > 0)]
negrmeans.pf <- prefront.Meanbothr$mean[which(prefront.Meanbothr$corr < 0)]
posrcorrs.pf <- prefront.Meanbothr$corr[which(prefront.Meanbothr$corr > 0)]
negrcorrs.pf <- prefront.Meanbothr$corr[which(prefront.Meanbothr$corr < 0)]
posrchr.pf <- as.factor(prefront.Meanbothr$chr[which(prefront.Meanbothr$corr > 0)])
negrchr.pf <- as.factor(prefront.Meanbothr$chr[which(prefront.Meanbothr$corr < 0)])
posgene.pf <- prefront.Meanbothr$gene[which(prefront.Meanbothr$corr > 0)]
neggene.pf <- prefront.Meanbothr$gene[which(prefront.Meanbothr$corr < 0)]
posbp.pf <- prefront.Meanbothr$bp[which(prefront.Meanbothr$corr > 0)]
negbp.pf <- prefront.Meanbothr$bp[which(prefront.Meanbothr$corr < 0)]
pospval.pf <- prefront.Meanbothr$pval[which(prefront.Meanbothr$corr > 0)]
negpval.pf <- prefront.Meanbothr$pval[which(prefront.Meanbothr$corr < 0)]
posrecord.pf <- prefront.Meanbothr$record[which(prefront.Meanbothr$corr > 0)]
negrecord.pf <- prefront.Meanbothr$record[which(prefront.Meanbothr$corr < 0)]
poscorsign.pf <- prefront.Meanbothr$corsign[which(prefront.Meanbothr$corr > 0)]
negcorsign.pf <- prefront.Meanbothr$corsign[which(prefront.Meanbothr$corr < 0)]


prefront.Meanposr <- data.frame(mean=posrmeans.pf,corr=posrcorrs.pf,chr=posrchr.pf,gene=posgene.pf,bp=posbp.pf,pval=pospval.pf,record=posrecord.pf,corsign=poscorsign.pf)
prefront.Meannegr <- data.frame(mean=negrmeans.pf,corr=negrcorrs.pf,chr=negrchr.pf,gene=neggene.pf,bp=negbp.pf,pval=negpval.pf,record=negrecord.pf,corsign=negcorsign.pf)
prefront.Meanposr$chr <- as.character(prefront.Meanposr$chr)
prefront.Meannegr$chr <- as.character(prefront.Meannegr$chr)


#### Replace Chr 'X' with 23
prefront.Meanposr$chr[which(prefront.Meanposr$chr == '   X')] <- as.character(c('   23'))
prefront.Meannegr$chr[which(prefront.Meannegr$chr == '   X')] <- as.character(c('   23'))

#### Replace Chr 'Y' with 24
prefront.Meanposr$chr[which(prefront.Meanposr$chr == '   Y')] <- as.character(c('   24'))
prefront.Meannegr$chr[which(prefront.Meannegr$chr == '   Y')] <- as.character(c('   24'))

prefront.Meanposr$chr <- gsub('   ','',prefront.Meanposr$chr)
prefront.Meannegr$chr <- gsub('   ','',prefront.Meannegr$chr)

### Positive r only
manhat.Posr.pf <- data.frame(
#                         CHR=as.integer(prefront.Meanposr$chr),
                          CHR=prefront.Meanposr$chr,
                          BP=prefront.Meanposr$bp,
                          PVAL=prefront.Meanposr$pval,
                          GENE=prefront.Meanposr$gene,
                          CORR=prefront.Meanposr$corr,
                          MEAN=prefront.Meanposr$mean,
                          ILMN=prefront.Meanposr$record,
                          CORSIGN=prefront.Meanposr$corsign
                          )

#manhat.Posr.pf$CHR <- as.integer(as.character(manhat.Posr.pf$CHR))
manhat.Posr.pf$GENE <- as.character(manhat.Posr.pf$GENE)
# Save data including COMT for later analysis
manhat.Posr.pf.withCOMT <- manhat.Posr.pf
#### Exclude COMT because p = 0.000
manhat.Posr.pf <- manhat.Posr.pf[2:dim(manhat.Posr.pf)[1],]


### Negative r only
manhat.Negr.pf <- data.frame(
#     CHR=as.integer(prefront.Meannegr$chr),
                          CHR=prefront.Meannegr$chr,
                          BP=prefront.Meannegr$bp,
                          PVAL=prefront.Meannegr$pval,
                          GENE=prefront.Meannegr$gene,
                          CORR=prefront.Meannegr$corr,
                          MEAN=prefront.Meannegr$mean,
                          ILMN=prefront.Meannegr$record,
                          CORSIGN=prefront.Meannegr$corsign
                          )

#manhat.Negr.pf$CHR <- as.integer(as.character(manhat.Negr.pf$CHR))
manhat.Negr.pf$GENE <- as.character(manhat.Negr.pf$GENE)


# Reverse order in columns so that the most negative correlations are at the bottom\

manhat.Negr.pf <- manhat.Negr.pf[c(dim(manhat.Negr.pf)[1]:1),]

@

<<echo=FALSE, include=FALSE, results=hide>>=
### Create a data.frame with all areas, but only those variables necessary to find the top N genes averaged across all four areas. Use Alexander's (1990) method for averaging correlations.

### The relevant variables are:
#### area: prefront, cbell, tempcort, pons
#### Chr number
#### Gene Symbol
#### Correlation of expression with COMT expressiomn in that area
#### P-value of correlation

# dimensions of data sets
dim.Area <- data.frame(area=c('prefront', 'cbell','tempor','pons'),
                       len=rep(0,4), wid=rep(0,4))
# prefrontal
dim.Area$len[1] <- dim(prefront.Meanbothr)[1]
dim.Area$wid[1] <- dim(prefront.Meanbothr)[2]

#cerebellum
dim.Area$len[2] <- dim(cbell.Data)[1]
dim.Area$wid[2] <- dim(cbell.Data)[2]

#temporal cortex
dim.Area$len[3] <- dim(tempor.Data)[1]
dim.Area$wid[3] <- dim(tempor.Data)[2]

#pons
dim.Area$len[4] <- dim(pons.Data)[1]
dim.Area$wid[4] <- dim(pons.Data)[2]

@

<<include=FALSE,echo=FALSE,results=hide>>=

all.Area.dat <- data.frame(areapf=rep(NA,dim.Area$len[1]),
                           chrpf=rep(NA,dim.Area$len[1]),
                           genepf=rep(NA,dim.Area$len[1]),
                           corrpf=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpf=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpf=rep(NA,dim.Area$len[1]),
                           areacb=rep(NA,dim.Area$len[1]),
                           chrcb=rep(NA,dim.Area$len[1]),
                           genecb=rep(NA,dim.Area$len[1]),
                           corrcb=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalcb=as.numeric(rep(NA,dim.Area$len[1])),
                           illumcb=rep(NA,dim.Area$len[1]),
                           areatc=rep(NA,dim.Area$len[1]),
                           chrtc=rep(NA,dim.Area$len[1]),
                           genetc=rep(NA,dim.Area$len[1]),
                           corrtc=as.numeric(rep(NA,dim.Area$len[1])),
                           pvaltc=as.numeric(rep(NA,dim.Area$len[1])),
                           illumtc=rep(NA,dim.Area$len[1]),
                           areapo=rep(NA,dim.Area$len[1]),
                           chrpo=rep(NA,dim.Area$len[1]),
                           genepo=rep(NA,dim.Area$len[1]),
                           corrpo=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpo=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpo=rep(NA,dim.Area$len[1])
                           )




prefront.Ess <- data.frame(area=rep('prefront',dim.Area$len[1]),
                      loc=prefront.Meanbothr$chr,
                      Symbol=prefront.Meanbothr$gene,
                      Sample.r=prefront.Meanbothr$corr,
                      Sample.p.r=prefront.Meanbothr$pval,
                      Record=prefront.Meanbothr$record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(prefront.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
prefront.Ess <- prefront.Ess[c(sort.Ind$ix),]


cbell.Ess <- data.frame(area=rep('cbell',dim.Area$len[1]),
                      loc=cbell.Data$loc,
                      Symbol=cbell.Data$Symbol,
                      Sample.r=cbell.Data$Sample.r,
                      Sample.p.r=cbell.Data$Sample.p.r.,
                      Record=cbell.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(cbell.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
cbell.Ess <- cbell.Ess[c(sort.Ind$ix),]


tempor.Ess <- data.frame(area=rep('tempor',dim.Area$len[1]),
                      loc=tempor.Data$loc,
                      Symbol=tempor.Data$Symbol,
                      Sample.r=tempor.Data$Sample.r,
                      Sample.p.r=tempor.Data$Sample.p.r.,
                      Record=tempor.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(tempor.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
tempor.Ess <- tempor.Ess[c(sort.Ind$ix),]


pons.Ess <- data.frame(area=rep('pons',dim.Area$len[1]),
                      loc=pons.Data$loc,
                      Symbol=pons.Data$Symbol,
                      Sample.r=pons.Data$Sample.r,
                      Sample.p.r=pons.Data$Sample.p.r.,
                      Record=pons.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(pons.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
pons.Ess <- pons.Ess[c(sort.Ind$ix),]

all.Area.dat[,1:6] <- prefront.Ess
all.Area.dat[,7:12] <- cbell.Ess
all.Area.dat[,13:18] <- tempor.Ess
all.Area.dat[,19:24] <- pons.Ess

cols.Corr <- c(4,10,16,22)
cols.Gene <- c(3,9,15,21)

ind.Ill <- matrix(rep(NA,4*dim.Area$len[1]),ncol=4)
for (i in 1:dim.Area$len[1]) {
     
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumcb)) {
               ind.Ill[i,2] <- which(as.character(all.Area.dat$illumcb)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,2] <- c(NA)
     }         
               
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumtc)) {            ind.Ill[i,3] <- which(as.character(all.Area.dat$illumtc)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,3] <- c(NA)
     }         
               
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumpo)) {
          ind.Ill[i,4] <- which(as.character(all.Area.dat$illumpo)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,4] <- c(NA)
     } 
          
          }

ind.Ill[,1] <- seq(1,dim.Area$len[1],1)     

#### ******* In all.Area.dat, each area's columns, are sorted separately by area on the correlation. ind.Ill shows where each probe is (index) by area


# This orders the data independently in each brain area by a particular variable
# all.Area.dat[,1:6] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[1]]),decreasing=FALSE),c(1:6)]
# all.Area.dat[,7:12] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[2]]),decreasing=FALSE),c(7:12)]
# all.Area.dat[,13:18] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[3]]),decreasing=FALSE),c(13:18)]
# all.Area.dat[,19:24] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[4]]),decreasing=FALSE),c(19:24)]

@

<<include=FALSE, echo=FALSE, results=tex>>=
# Calculate average correlation with COMT expression of each probe's expression
# Use Alexander (1990) to average correlations
# ind.Ill holds the indices for cerebellum, temporal cortex and pons of each probe on prefrontal cortex.

hold.Corrs <- data.frame(illum=rep(NA,dim.Area$len[1]),
                         gene=rep(NA,dim.Area$len[1]),
                         corpf=rep(0,dim.Area$len[1]),
                         corcb=rep(0,dim.Area$len[1]),
                         cortc=rep(0,dim.Area$len[1]),
                         corpo=rep(0,dim.Area$len[1])
                         )

##### ***** The next code sorts hold.Corrs by the sorted correlations in the prefrontal cortex
##### ***** In other words, the correlations are no longer sorted separately by area, but ###### instead the probeID order in prefrontal cortex after having been sorted by pf
##### correlation determines the correlations shown in that row in the other three areas
# For example, just making up a scenario, whatever probeID has the second strongest expression correlation with COMT in prefrontal cortex might have a correlation of r=.65 in the cerebellum. That is the correlation that would show up in the second row for the cerebellum

hold.Corrs$illum <- all.Area.dat$illumpf
hold.Corrs$gene <- all.Area.dat$genepf
hold.Corrs$corpf <- all.Area.dat$corrpf
hold.Corrs$corcb <- all.Area.dat$corrcb[c(ind.Ill[,2])]
hold.Corrs$cortc <- all.Area.dat$corrtc[c(ind.Ill[,3])]
hold.Corrs$corpo <- all.Area.dat$corrpo[c(ind.Ill[,4])]

# average these four correlations and put them into a new column
# Use Alexander (1990) to average

ki <- c(4)
n.subj <- c(144,144,144,144)

# Calculate in parts then put together

sum.corr <- matrix(rep(0,dim.Area$len[1]),ncol=1)
for (l in 1:dim.Area$len[1]) {
     
     sum.corr[l] <-sum((((n.subj[1:4] - 1))/(sum(n.subj) - ki))*(hold.Corrs[l,3:6] + (hold.Corrs[l,3:6]*(1 - hold.Corrs[l,3:6]^2))/(2*(n.subj[1:4] - 3))))
     
hold.Corrs$avgCorr[l] <- sum.corr[l]
}

@

<<include=FALSE, echo=FALSE, results=tex>>=

## Leave columns sorted by correlation in prefrontal cortex

top200_pos_ordered_by_pf_corr <- xtable(hold.Corrs[1:cut.Part,],
                           caption=paste('Correlations of expression with COMT in each brain area for the ',cut.Part,' probes that show the strongest positive correlations in prefrontal cortex',sep=''))


write.table(hold.Corrs[1:cut.Part,],file=paste('top',cut.Part,'_pos_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,
            quote=FALSE)
write.table(hold.Corrs[1:cut.Part,1:3],file=paste('top',cut.Part,'_pos_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,
            quote=FALSE)



top200_neg_ordered_by_pf_corr <- xtable(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-200),],
                           caption=paste('Correlations of expression with COMT in each brain area for the ',cut.Part,' probes that show the strongest negative correlations in prefrontal cortex',sep=''))

# Note that these are written in reverse order because they are negative: 20,000:19800
write.table(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-200),],file=paste('top',cut.Part,'_neg_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,quote=FALSE)
write.table(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-200),1:3],file=paste('top',cut.Part,'_neg_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,quote=FALSE)


@



<<include=FALSE, echo=FALSE, results=tex>>=
# Tally the chromosome numbers of the top 200 + and top 200 - in each brain area separately
# Are (+) correlated genes more likely to be on the same chromosome than (-) correlated genes?
# Do this both for the top 200 as well as for all 20000 probes.
# Use the data.frame dfsort
# colnames(dfsort)
#[1] "chr"     "corsign" "freq"
# dfsort is already in tabular form

corsign.By.chr <- dfsort
corsign.By.chr$pm <- factor(rep(c('minus','plus'),each=24))
corsign.By.chr <- corsign.By.chr[,c(1,4,3)]

colnames(corsign.By.chr) <- c('chr','corsign','count')

xtabs.ChrCorsign <- xtabs(count ~ chr + corsign,data=corsign.By.chr)

chisq.ChrCorsign.out <- chisq.test(xtabs.ChrCorsign)
print(chisq.ChrCorsign.out)

@

The chi-square test of independence shows that the number of genes showing positive versus negative correlations with COMT is not independent of Chromosome number in prefrontal cortex.\\

Next, use the binomial distribution to determine if the distribution on Chr 22 where COMT is differs from the distribution on all other chromosomes.\\

<<include=FALSE, echo=FALSE, results=tex>>=
# First get the numbers of plus and minus correlations aggregated across all chromosomes except Chr 22.
# Get total probes/genes on Chr 22

pm.Sans22 <- c(rep(0,2))
pm.Sans22[1] <- sum(xtabs.ChrCorsign[,1]) - xtabs.ChrCorsign[22,1]
pm.Sans22[2] <- sum(xtabs.ChrCorsign[,2]) - xtabs.ChrCorsign[22,2]

counts.22 <- sum(xtabs.ChrCorsign[22,])
counts.Sans22 <- sum(pm.Sans22)

obs.Minus.22 <- xtabs.ChrCorsign[22,1]

p.minus.22 <- obs.Minus.22/counts.22


# probability of negative correlations across all chromosomes except Chr 22
p.minus <- pm.Sans22[1]/counts.Sans22

# get the binomial distribution with p = p.minus and the sample size of the number of probes on Chr 22
d.minus <- dbinom(seq(0,counts.22,1),counts.22,p.minus)

d.minus <- data.frame(num.minus = seq(0,counts.22,1),prob=d.minus)

# Now get the probability of xtabs.ChrCorsign[22,1] minuses or fewer given counts.22 probes. In this case
# p(k <= 286 minuses) with Binomial(N=19171, p = 0.63888)

cumul.d.minus <- sum(d.minus[1:(obs.Minus.22 + 1),2])

binom.test(obs.Minus.22, counts.22, p = p.minus,
           alternative = c("less"),
           conf.level = 0.95)

binom.test(obs.Minus.22, counts.22, p = p.minus,
           alternative = c("two.sided"),
           conf.level = 0.95)


# The proportion of negatively COMT-correlated genes in prefrontal cortex, 0.54806, is significantly lower than the proportion aggregated across all the other chromosomes, 0.63888.
@

The proportion genes with negative correlations mwith MB-COMT on Chr 22, \Sexpr{p.minus.22}, is signficantly lower than the proportion aggregated across all of the other chromosomes, \Sexpr{p.minus}.\\ 

<<include=FALSE, echo=FALSE, fig=TRUE, pdf=TRUE>>=
gold.R <- c(1.61803398875)

vcut <- data.frame(x1=(obs.Minus.22 + 0.5), x2=(obs.Minus.22 + 0.5), y1=-0.00075, y2=0.02)
p.low.d.minus <- subset(d.minus,d.minus$num.minus < (obs.Minus.22 + 1))

minus.plot <- ggplot() +
          
          geom_point(data=d.minus, aes(x=num.minus,y=prob,group=1),
                     size=0.6,color='blue',shape=1) +
     
          geom_point(data=p.low.d.minus, aes(x=num.minus,y=prob,group=1),
                     size=0.6,color='red',shape=1) +
     
          geom_segment(data=vcut, aes(x=x1,xend=x2,y=y1,yend=y2), color='red',size=0.5)  +
          
          scale_y_continuous(breaks = seq(0,0.05,0.01),
                             labels = comma(seq(0,0.05,0.01), digits = 2)) +
          
          scale_x_continuous(name='Number of Negative Correlations (k)',
                             limits=c(0,round((counts.22 + 5),0)),
                             breaks=seq(0,round((counts.22 + 5),0),200)) +
          
          theme_classic() +
          
          
          ggtitle('Probability of Negative Correlations Based on All Chromosomes Except Chr 22' ) +
          
          ylab('Probability density') + 
          theme(aspect.ratio=1/gold.R) + 
          theme(plot.title = element_text(color="black",
                                          size=8.5,
                                          hjust=0.5)) +
          theme(axis.title = element_text(color="black",
                                          size=10,
                                          vjust=1
          )) +

               theme(axis.text.x = element_text(size=8),
                axis.text.y = element_text(size=8)) +
          
          annotate("text", x = (obs.Minus.22 - 65),
                   y = 0.005,
                   label = c(paste('p(k < ',(obs.Minus.22 + 1),') = ',
                                   round(cumul.d.minus,8),sep='')),
                   color="black",
                   size=3.0)    +
     
          annotate("text", x = 0.10*(round((counts.22 + 5),0)),
                   y = 1.10*max(d.minus$prob),
                   label = c(paste('unique ID: ',prog.Name,sep='')),
                   parse=FALSE,
                   color="gray20",
                   size=1.5) 

file1.pdf <- c('p_binomial_mb_comt.pdf')
   ggsave(file1.pdf, plot = minus.plot, width = 8, height = 5.5)

minus.plot

@

%\includegraphics[width=0.5\textwidth]{p_binomial_comt_s.eps}\\

<<include=FALSE, echo=FALSE, results=tex>>=
#Get the mean and sd of the top 200 positives and negatives in each area

mean.sd.By.areaPos <- psych::describe(all.Area.dat[2:(cut.Part+1),cols.Corr])
mean.sd.By.areaNeg <- psych::describe(all.Area.dat[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]- cut.Part),cols.Corr])


@





<<include=FALSE, echo=FALSE, results=TEX>>= 
# Test the hypothesis that the rank order of the most negatively correlated genes changes more across brain area than do the rank orders of the most highly positively correlated genes.

# Rank the genes on their correlations separately by area, then compare the ranks of specific genes across areas to determine if there are greater differences among negatively correlated genes than among positively correlated genes.

### Do this with the all.Area.dat which has the strongest correlations in each brain area separately. Have to use ind.Ill to find out what those probes are in each area.

hold.Area.dat <- data.frame(areapf=rep(NA,dim.Area$len[1]),
                           chrpf=rep(NA,dim.Area$len[1]),
                           genepf=rep(NA,dim.Area$len[1]),
                           corrpf=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpf=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpf=rep(NA,dim.Area$len[1]),
                           areacb=rep(NA,dim.Area$len[1]),
                           chrcb=rep(NA,dim.Area$len[1]),
                           genecb=rep(NA,dim.Area$len[1]),
                           corrcb=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalcb=as.numeric(rep(NA,dim.Area$len[1])),
                           illumcb=rep(NA,dim.Area$len[1]),
                           areatc=rep(NA,dim.Area$len[1]),
                           chrtc=rep(NA,dim.Area$len[1]),
                           genetc=rep(NA,dim.Area$len[1]),
                           corrtc=as.numeric(rep(NA,dim.Area$len[1])),
                           pvaltc=as.numeric(rep(NA,dim.Area$len[1])),
                           illumtc=rep(NA,dim.Area$len[1]),
                           areapo=rep(NA,dim.Area$len[1]),
                           chrpo=rep(NA,dim.Area$len[1]),
                           genepo=rep(NA,dim.Area$len[1]),
                           corrpo=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpo=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpo=rep(NA,dim.Area$len[1])
                           )
     
cols.Corr <- c(4,10,16,22)
cols.Gene <- c(3,9,15,21)     
     
hold.Area.dat[,1:6] <- all.Area.dat[order(all.Area.dat[,cols.Corr[1]],decreasing=TRUE),c(1:6)]
hold.Area.dat[,7:12] <- all.Area.dat[order(all.Area.dat[,cols.Corr[2]],decreasing=TRUE),c(7:12)]
hold.Area.dat[,13:18] <- all.Area.dat[order(all.Area.dat[,cols.Corr[3]],decreasing=TRUE),c(13:18)]
hold.Area.dat[,19:24] <- all.Area.dat[order(all.Area.dat[,cols.Corr[4]],decreasing=TRUE),c(19:24)]

@


<<include=FALSE, echo=FALSE, results=tex>>=
# now for the 200 genes with the largest negative correlations in Prefrontal Cortex, find their ranks in the other three areas



rank.Stab.neg <- matrix(rep(0,4*cut.Part),ncol=4)

# First do negative correlations
for (h in 1:cut.Part) {
     
     rank.Stab.neg[h,1] <-(20000 - (cut.Part -h))
     
     if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumcb)) {
          rank.Stab.neg[h,2] <- which(as.character(hold.Area.dat$illumcb) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,2] <-  c(NA)  
          
     }    
     
     if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumtc)) {
          rank.Stab.neg[h,3] <- which(as.character(hold.Area.dat$illumtc) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,3] <-  c(NA)  
          
     }
     
    if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumpo)) {
          rank.Stab.neg[h,4] <- which(as.character(hold.Area.dat$illumpo) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,4] <-  c(NA)  
          
     }
     
}

colnames(rank.Stab.neg) <- c('rankpf','rankcb','ranktc','rankpo')
rank.Stab.neg <- data.frame(rank.Stab.neg)
rank.Stab.neg$illum <- hold.Area.dat$illumpf[(20000 - (cut.Part -1)):20000]
rank.Stab.neg$gene <- hold.Area.dat$genepf[(20000 - (cut.Part -1)):20000]
rank.Stab.neg <- rank.Stab.neg[,c(5,6,1:4)]

overlap.Area <- list()

# [[1]] pf vs cb
# [[2]] pf vs tc
# [[3]] pf vs po
# [[4]] cb vs tc
# [[5]] cb vs po
# [[6]] tc vs po

overlap.Area[[1]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$rankcb)
overlap.Area[[2]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$ranktc)
overlap.Area[[3]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$rankpo)
overlap.Area[[4]] <- intersect(rank.Stab.neg$rankcb,rank.Stab.neg$ranktc)
overlap.Area[[5]] <- intersect(rank.Stab.neg$rankcb,rank.Stab.neg$rankpo)
overlap.Area[[6]] <- intersect(rank.Stab.neg$ranktc,rank.Stab.neg$rankpo)

perc.Overlap <- data.frame(compare=(rep(NA,6)),num=c(rep(0,6)),percentage=c(rep(0,6)),
                           n.base=c(rep(0,6)),ofn=c(rep(NA,6)))
perc.Overlap$compare <- c('prefrontal cortex vs. cerebellum',
                         'prefrontal cortex vs. temporal cortex',
                         'prefrontal cortex vs. pons',
                         'cerebellum vs. temporal cortex',
                         'cerebellum vs. pons',
                         'temporal cortex vs. pons')

for (g in 1:6) {
     
    perc.Overlap$n.base[g]  <- cut.Part - length(which(is.na(rank.Stab.neg[,g])))
     perc.Overlap$num[g]  <- length(overlap.Area[[g]]) 
    perc.Overlap$percentage[g]  <- paste(round(100*(perc.Overlap$num[g])/(perc.Overlap$n.base[g]),0),'%',sep='')
}

perc.Overlap.neg <- perc.Overlap
perc.Overlap.neg$ofn <- paste(perc.Overlap$num,' (',perc.Overlap$n.base,')',sep='')

colnames(perc.Overlap.neg) <- c('Comparison','number shared','Percentage','base n',
                                'Shared Genes (N)')
overlap.Neg <- xtable(perc.Overlap.neg[,c(1,5,3)],
                         caption=c('Of the genes with the strongest negative correlations with COMT expression,\n the percentage of genes found in both areas'))

overlap.Neg


@

<<include=FALSE, echo=FALSE, results=tex>>=
# now for the 200 genes with the largest positive correlations in Prefrontal Cortex, find their ranks in the other three areas


#cut.Part <- c(200)
rank.Stab.pos <- matrix(rep(0,4*cut.Part),ncol=4)

# Now do positive correlations
for (h in 1:cut.Part) {
     
     rank.Stab.pos[h,1] <- h
     
     if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumcb)) {
          rank.Stab.pos[h,2] <- which(as.character(hold.Area.dat$illumcb) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.pos[h,2] <-  c(NA)  
          
     }    
     
     if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumtc)) {
          rank.Stab.pos[h,3] <- which(as.character(hold.Area.dat$illumtc) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.pos[h,3] <-  c(NA)  
          
     }
     
    if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumpo)) {
          rank.Stab.pos[h,4] <- which(as.character(hold.Area.dat$illumpo) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.pos[h,4] <-  c(NA)  
          
     }
     
}



colnames(rank.Stab.pos) <- c('rankpf','rankcb','ranktc','rankpo')
rank.Stab.pos <- data.frame(rank.Stab.pos)
rank.Stab.pos$illum <- hold.Area.dat$illumpf[1:cut.Part]
rank.Stab.pos$gene <- hold.Area.dat$genepf[1:cut.Part]
rank.Stab.pos <- rank.Stab.pos[,c(5,6,1:4)]

overlap.Area <- list()

# [[1]] pf vs cb
# [[2]] pf vs tc
# [[3]] pf vs po
# [[4]] cb vs tc
# [[5]] cb vs po
# [[6]] tc vs po

overlap.Area[[1]] <- intersect(rank.Stab.pos$rankpf,rank.Stab.pos$rankcb)
overlap.Area[[2]] <- intersect(rank.Stab.pos$rankpf,rank.Stab.pos$ranktc)
overlap.Area[[3]] <- intersect(rank.Stab.pos$rankpf,rank.Stab.pos$rankpo)
overlap.Area[[4]] <- intersect(rank.Stab.pos$rankcb,rank.Stab.pos$ranktc)
overlap.Area[[5]] <- intersect(rank.Stab.pos$rankcb,rank.Stab.pos$rankpo)
overlap.Area[[6]] <- intersect(rank.Stab.pos$ranktc,rank.Stab.pos$rankpo)


perc.Overlap <- data.frame(compare=(rep(NA,6)),num=c(rep(0,6)),percentage=c(rep(0,6)),
                           n.base=c(rep(0,6)),ofn=c(rep(NA,6)))
perc.Overlap$compare <- c('prefrontal cortex vs. cerebellum',
                         'prefrontal cortex vs. temporal cortex',
                         'prefrontal cortex vs. pons',
                         'cerebellum vs. temporal cortex',
                         'cerebellum vs. pons',
                         'temporal cortex vs. pons')

for (g in 1:6) {
     
    perc.Overlap$n.base[g]  <- cut.Part - length(which(is.na(rank.Stab.pos[,g])))
     perc.Overlap$num[g]  <- length(overlap.Area[[g]]) 
    perc.Overlap$percentage[g]  <- paste(round(100*(perc.Overlap$num[g])/(perc.Overlap$n.base[g]),0),'%',sep='')
}

perc.Overlap.pos <- perc.Overlap
perc.Overlap.pos$ofn <- paste(perc.Overlap$num,' (',perc.Overlap$n.base,')',sep='')

colnames(perc.Overlap.pos) <- c('Comparison','number shared','Percentage','base n',
                                'Shared Genes (N)')
overlap.Pos <- xtable(perc.Overlap.pos[,c(1,5,3)],
                         caption=c('Of the genes with the strongest positive correlations with COMT expression,\n the percentage of genes found in both areas'))

overlap.Pos


@


% {\bfseries {Using the hypergeometric distribution to test for randomness in the number of probes shared in common between the reference area and another area.}}\\
% 
% Testing for probe matches between a reference and a test brain area involves the {\bfseries {hypergeometric}} distribution.\\ The computation of probabilities when sampling without replacement is based on the following pdf:
% 
% \href{http://people.wku.edu/david.neal/109/Unit2/SamplingWO.pdf}{c('MATH 109 Sampling without Replacement)}
% 
% Here is the description of the calculation: \\
% 
% {\bfseries {Sampling Without Regard to Order}}\\
% Now  suppose  we  have  a  population  of N elements  that  are  divided  into  two  types: Type I  which has A elements,  and Type II which has B elements, where $A + B == N$.\\  
% 
% For  example,  a  standard  deck  of  $N == 52$  playing  cards  can  be  divided  in  many  ways. Type  I  could  be  Hearts  and  Type  II    could  be  All  Others.    Then  there  are   $A == 13$ Hearts and  $B == 39$ Others.\\
% 
% In analogy to the genes/probes problem, $N == 20,000$ probes,  $A == 50$ or 200, as in the top 50 or the top 200 most strongly positively/negatively {\textit {COMT}}-correlated probes. Thus B is either 19,950 ($A == 50 $) or B is 19,800 ( $A == 200$). 
% 
% There are two other parameters: $n == $the number of probes randomnly sampled without replacement, and  $k = $ the number of probes in the sample of size n that also are contained in A. The calculation for the probability that a sample of size n will contain k probes in common with the set in A is:\\
% $$
% p = \frac{\binom{A,k}*\binom{B,(n-k)}}{\binom{N,n}}
% $$


<<include=FALSE, echo=FALSE, results=tex>>=
# Conditional on the 50 probes with expression levels most strongly positively and negatively correlated with COMT expression, find the probability of n of 50 matching

# Sampling without replacement


     num.Probes <- length(unique(hold.Area.dat$illumpf))
     N <- num.Probes
     A <- cut.Part   # number of probes in the reference area that could be matched
     B <- N - A         # number of prtobes not in slected set in reference area
n <- A     # sample of 50 probes
# then k ranges from 0 to A matches

###*** Note ***#####
# The average NUMBER of matches to the top 50 probes expected with a sample of 50 randomly
# selected genes in another area will be n x A/N or 200(200/20000) = 0.125 <- This is not a proportion; it is the expected number of matches - much less than 1 probe should match by chance.

# prob.N will hold the discrete probability distribution for k matches from a sample size either of 50 or 200.

prob.N <- mpfr(matrix(rep(0,(A+1))),precBits=50)
for (k in 1:A) {
     
     prob.N[k+1] <- (chooseMpfr(A,k)*chooseMpfr(B,(n-k)))/chooseMpfr(N,n)
}


prob.N[1] <- 1.0 - sum(prob.N[2:(A+1)])


     prob.N.200 <- data.frame(n.match=seq(0,cut.Part,1),prob=as.numeric(log10(prob.N)))
     write.table(prob.N.200,file=paste('hypergeometric_probability_table_',cut.Part,'.csv',sep=''),sep=', ',row.names=FALSE)



@


<<include=FALSE, echo=FALSE>>=  # , fig=TRUE, pdf=TRUE
# For plotting purposes, the last probability in each frame is 0, so leave that out
# also because it is a discrete distribution, only plot every 5th or 10th point

     
# Using <<- instead of <- allows the variable to used globally
     # Do this when prob.N.200 is first set up in another program
#prob.N.200.plot <- prob.N.200[c(seq(1,200,10)),]
     # Call the hyperplot.R function to plot the hypergeometric distributions
loLim <- c(50)
hiLim <- c(200)
limitseq <- c(0,200,25)

# Using <<- instead of <- allows the variable to used globally
     # Do this when prob.N.200 is first set up in another program

#     p.plot <- hyper.plot(prob.N.50,prob.N.200,loLim,hiLim,limitseq,prog.Name)     



# file.eps <- c('hypergeometric_distributions_50_200.pdf')
#   postscript(file=file.eps,horiz=FALSE,onefile=FALSE,width=8.0,height=5.5,paper='letter')
# 
# p.plot

@

The hypergeometric distributions using the parameters described above are shown in the next figure.\\

%\includegraphics[width=0.5\textwidth]{hypergeometric_matching_genes_diagram.pdf}\\


<<include=FALSE, echo=FALSE, results=tex>>=
############## This needs to be changed to reflect the two prob.N as prob.N.50 and prob.N.200 and the fact that the probabilities are already represented as log10

genes.In.common <- cbind(perc.Overlap.pos[,c(1,5,3)],perc.Overlap.neg[,c(5,3)])



     genes.In.common$logp.valpos <- round(as.numeric(prob.N.200[(perc.Overlap.pos[,2]+1),2]),1)
     genes.In.common$logp.valneg <- round(as.numeric(prob.N.200[(perc.Overlap.neg[,2]+1),2]),1)

     
genes.In.common <- genes.In.common[,c(1:3,6,4,5,7)]

genes.In.common.tab <- xtable(genes.In.common,
                   caption = c(paste("Percentages of the ",cut.Part," Most Strongly Correlated Genes Shared in Common Between Two Brain Areas",sep="")))


genes.In.common.ltx <- latex(genes.In.common.tab,file='',
                   caption = c(paste("Percentages of the ",cut.Part," Most Strongly Correlated Genes Shared in Common Between Two Brain Areas",sep="")),
                     caption.loc = c('top'),
#                     colname = c('Name','URL'),
                     rowlabel = NULL,
                     colnamesTexCmd="bfseries",
                     booktabs=TRUE,
                     label=c('tab:sharedgenes'),
                     na.blank = TRUE,
                     vbar = FALSE,
                     longtable=TRUE,
                     table.env=TRUE,
                     center=c('center'),
                     continued=c('Genes Shared Across Areas Continued'),
                     first.hline.double = TRUE,
                     append=FALSE
                     )
                  
print(genes.In.common.ltx)

write.table(genes.In.common,paste('shared_perc_',cut.Part,'_posneg.csv',sep=', '),row.names = FALSE)

@


<<echo=FALSE, results=tex>>=
################################################
### Select the top 200 by p-value to determine which genes expression levels (by chromosome) are most highly correlated with COMT expression.
### Done separately for positive and negative correlations
### Inversely normalized by fitted number of probes from the regression on chr length, but weighted by proportion of each chromosome in the top 200. 
################################################

##### Positive correlations with COMT expression only #####################
num.Sel <- cut.Part
full.Count <- table(manhat.Posr.pf$CHR)
order.by.P.pos <- manhat.Posr.pf[order(manhat.Posr.pf$P), ]

order.by.P.pos$P <- -log10(order.by.P.pos$P)
colnames(order.by.P.pos)[3] <- c('-log10p')
xtable(order.by.P.pos[1:num.Sel,],caption=c(paste(cut.Part,' Genes with Strongest Positive Correlations with COMT in Prefrontal Cortex',sep='')))

############ End positive only ########################
  
##### Negative correlations with COMT expression only #####################
full.Count <- table(manhat.Negr.pf$CHR)
order.by.P.neg <- manhat.Negr.pf[order(manhat.Negr.pf$P), ]
order.by.P.neg$P <- -log10(order.by.P.neg$P)
colnames(order.by.P.neg)[3] <- c('-log10p')

xtable(order.by.P.neg[1:num.Sel,],caption=c(paste(cut.Part,' Genes with Strongest Negative Correlations with COMT in Prefrontal Cortex',sep='')))

############ End negative only ########################

@

{\bfseries {Gene ontology analysis}}\\

<<echo=FALSE, include=FALSE, results=tex>>=

if (!exists('ensembl')) {
 ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")   
}

normal.chroms <- c(1:22, "X", "Y", "M")

if (!exists('ah')) {
 ah <- AnnotationHub()   
}

if (!exists('orgs')) {
 orgs <- AnnotationHub::query(ah, "org.Hs.eg.db")   
}

if (!exists('gene.DB')) {
 gene.DB <- orgs[["AH57973"]]   
}

# columns(gene.DB)
# keytypes(gene.DB)




# input entrez ID output gene symbol
# temp.Gene <- c('COMT',   'PHGDH',  'DDR1',   'SCAMP2', 'ZFAND3', 'NECAP2', 'HDAC1',  'FTL', 'TST',    'CRYL1')
# 

topplusr.Data$GENE <- gsub(" ", "", topplusr.Data$GENE)
topminusr.Data$GENE <- gsub(" ", "", topminusr.Data$GENE)

twohundred_comt_plus <- na.omit(biomaRt::select(gene.DB,keys=as.character(topplusr.Data$GENE[2:51]),columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL')))

write.table(twohundred_comt_plus,file='twohundred_comt_plus_corr.csv',sep=', ',quote=FALSE)


twohundred_comt_minus <- na.omit(biomaRt::select(gene.DB,keys=as.character(topminusr.Data$GENE[2:51]),columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL')))

write.table(twohundred_comt_minus,file='twohundred_comt_minus_corr.csv',sep=', ',quote=FALSE)


     

     top200.Pos <- biomaRt::select(gene.DB,keys=order.by.P.pos$GENE[1:num.Sel],columns=c('GENENAME','SYMBOL','ENTREZID'),keytype=c('SYMBOL'))
     
#          top.Pos <- top200.Pos
     top.Pos <- twohundred_comt_plus
          
     top200.Neg <- biomaRt::select(gene.DB,keys=order.by.P.neg$GENE[1:num.Sel],columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL'))
     


#          top.Neg <- top200.Neg
          top.Neg <- twohundred_comt_minus


pos.Tab <- xtable(top.Pos,caption=c(paste('Top ',cut.Part,' Positively Correlated Genes with COMT in Prefrontal Cortex',sep='')))

pos.Tab

neg.Tab <- xtable(top.Neg,caption=c(paste('Top ',cut.Part,' Negatively Correlated Genes with COMT in Prefrontal Cortex',sep='')))

neg.Tab

@

<<include=FALSE, echo=FALSE, results=tex>>=
# Ontology

#org.Hs.egGO is an R object that provides
#mappings between entrez gene identifers and the GO
#identifers that they are directly associated with
entrez_object <- org.Hs.egGO    # 

# Get the entrez gene identifiers that are mapped to a GO ID
#mapped_genes <- mappedkeys(entrez_object)

# Instead, use the actual Illumina probes converted to ENTREZIDs in the data set
# Get the ENTREZ ID for all of the probes in the original data
universe.Probes <- data.frame(ENTREZID=na.omit(unlist(mget(x = prefront.Data$Record,envir=illuminaHumanv2ENTREZID))))

universe.Probes$ENTREZID <- as.character(universe.Probes$ENTREZID)

# universe.Probes$ENTREZID now holds all of the ENTREZIDs for all of the ILMN probes

# Convert to a list
#entrez_to_go <- as.list(entrez_object[mapped_genes])
entrez_to_go <- as.list(entrez_object[universe.Probes$ENTREZID])


#map GO terms to Entrez gene ids
go_object <- as.list(org.Hs.egGO2EG)


# axon_gene <- go_object['GO:0007411']
# length(unlist(axon_gene, use.names=F))
# 
# axon_gene <- unique(unlist(axon_gene, use.names=F))
# head(axon_gene)

my_genes_plus <- unique(top.Pos$ENTREZID)
my_genes_minus <- unique(top.Neg$ENTREZID)
#universe <- mapped_genes
universe <- universe.Probes$ENTREZID
length(universe)

params <- new('GOHyperGParams',
              geneIds=my_genes_plus,
              universeGeneIds=universe,
              ontology='BP',
              pvalueCutoff=0.001,
              conditional=F,
              testDirection='over',
              annotation="org.Hs.eg.db"
             )
hgOver.plus <- hyperGTest(params)
ontology.results.200Plus <- summary(hgOver.plus)

ontology.200.plusA <- xtable(ontology.results.200Plus[,1:6],
                            caption='Ontology analysis results with top 200 positive correlations (p less than .001)')

ontology.200.plusB <- xtable(data.frame(ontology.results.200Plus[,7]),
                            caption='Ontology analysis significantly enriched GO terms with top 200 positive correlations (p less than .001)')

# results_GO <- go_object[results$GOBPID]
# go_object['GO:0051589']


params <- new('GOHyperGParams',
              geneIds=my_genes_minus,
              universeGeneIds=universe,
              ontology='BP',
              pvalueCutoff=0.001,
              conditional=F,
              testDirection='over',
              annotation="org.Hs.eg.db"
             )
hgOver.minus <- hyperGTest(params)
ontology.results.200Minus <- summary(hgOver.minus)

ontology.200.minusA <- xtable(ontology.results.200Minus[,1:6],
                            caption='Ontology analysis results with top 200 positive correlations (p less than .001)')

ontology.200.minusB <- xtable(data.frame(ontology.results.200Minus[,7]),
                            caption='Ontology analysis significantly enriched GO terms with top 200 positive correlations (p less than .001)')


# results_GO <- go_object[results$GOBPID]
# intersect(my_genes_plus$ENTREZID,unlist(results_GO[[1]]))


@





{\bfseries {Mutual rank:}} co-expression Pearson correlation coefficient RANK with gene A as target and gene B as co-expressed, and vice versa. The two ranks are then geometrically averaged. Smaller MR scores mean stronger co-expression.\\

<<echo=FALSE, include=FALSE, results=tex>>=
print(xtable(coexpress.URL[1,],caption=c('The next co-expression analysis used the database at this URL to find the top 500 genes coexpressed with COMT. That list was then checked against the top 200 genes (+ and - separately) from the comt-prefrontal data to find agreement between the two lists.')))


### read the COMT coexpression data file 
hold.Matchpos <- matrix(c(rep(NA,cut.Part)),ncol=1)
hold.Matchneg <- matrix(c(rep(NA,cut.Part)),ncol=1)
hold.Chrompos <- matrix(c(rep(NA,cut.Part)),ncol=1)
hold.Chromneg <- matrix(c(rep(NA,cut.Part)),ncol=1)

wbhsa <- loadWorkbook('comt_coex_list_500_hsa.xlsx')
# wbhsa2 <- loadWorkbook('comt_coex_list_500_hsa2.xlsx')
# wbhsa3 <- loadWorkbook('comt_coex_list_500_hsa3.xlsx')

coexpress.Data <- data.frame(read.xlsx(wbhsa,         # now tell R to read that workbook and which sheet
                                  sheet = "coex500"))


coexpress.Data$Entrez.Gene.ID <- as.character(coexpress.Data$Entrez.Gene.ID)

for (ma in 1:num.Sel) {

  if (isTRUE(which(coexpress.Data$Entrez.Gene.ID == as.character(top.Pos$ENTREZID[ma])) != 0)) {
    hold.Matchpos[ma] <- coexpress.Data$Gene[which(coexpress.Data$Entrez.Gene.ID == as.character(top.Pos$ENTREZID[ma]))]
  } else {
    
  }
     
  
  if (isTRUE(which(coexpress.Data$Entrez.Gene.ID == as.character(top.Neg$ENTREZID[ma])) != 0)) {
    hold.Matchneg[ma] <- coexpress.Data$Gene[which(coexpress.Data$Entrez.Gene.ID == as.character(top.Neg$ENTREZID[ma]))]
  } else {
    
  } 
}


pos.Matches <- na.omit(hold.Matchpos)

neg.Matches <- na.omit(hold.Matchneg)

if (length(pos.Matches) > 0) {
my.symbols <- pos.Matches
my.regions <- getBM(c("hgnc_symbol", "chromosome_name", "start_position", "end_position", "band"),
                    filters = c("hgnc_symbol", "chromosome_name"),
                    values = list(hgnc_symbol=my.symbols, chromosome_name=normal.chroms),
                    mart = ensembl)
my.regions$chromosome_name

posmatch.DF <- data.frame(geneSymbol=pos.Matches,chromosome=my.regions$chromosome_name)


} else {posmatch.DF <- data.frame(geneSymbol=NA,chromosome=NA)
}

xtable(posmatch.DF,caption=c(paste('Genes matching the top ',cut.Part,' positively COMT - correlated genes in Prefrontal',sep='')))


if (length(neg.Matches) > 0) {
my.symbols <- neg.Matches
my.regions <- getBM(c("hgnc_symbol", "chromosome_name", "start_position", "end_position", "band"),
                    filters = c("hgnc_symbol", "chromosome_name"),
                    values = list(hgnc_symbol=my.symbols, chromosome_name=normal.chroms),
                    mart = ensembl)
my.regions$chromosome_name

negmatch.DF <- data.frame(geneSymbol=neg.Matches,chromosome=my.regions$chromosome_name)


} else {negmatch.DF <- data.frame(geneSymbol=NA,chromosome=NA)
}

xtable(negmatch.DF,caption=paste('Genes matching the top ',cut.Part,' negatively COMT - correlated genes in Prefrontal',sep=''))

@

% Genes from \Sexpr{print(coexpress.URL[1,])} that overlap with the 10 most highly positively correlated genes with COMT in Prefrontal Cortex:\\
% \Sexpr{pos.Matches[1:length(pos.Matches)]}\\
% 
% (Note: this database most likely only shows positively correlated coexpression genes.)\\
% Genes from \Sexpr{print(coexpress.URL[1,])} that overlap with the 10 most highly negatively correlated genes with COMT in Prefrontal Cortex:\\
% \Sexpr{neg.Matches[1:length(neg.Matches)]}\\


\end{document}


 
