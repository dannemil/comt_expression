% NEW based on COMT-MB data
<<include=FALSE, echo=FALSE, results=hide>>=
# Generate a uinique ID for this program by path and filename. This unique ID is attached to this file using a tag in the filesystem.
source('unique_id_generator.R')

fname <- c("/Volumes/Macintosh_HD_3/genetics/genenetwork2/comt_correlations_ontology _1.Rnw")

prog.Name <- unique.ID(fname)

prog.Name

@

This program has the unique ID: \Sexpr{prog.Name}.


\documentclass[11pt]{article}
\usepackage{graphicx, subfig}
\usepackage{float}
\pagenumbering{arabic}
\usepackage{enumerate}
\usepackage{Sweave}
\usepackage{booktabs}
\usepackage[table]{xcolor}
\usepackage{framed}
\usepackage{longtable}
\usepackage{tablefootnote}
\usepackage{amsmath}
\usepackage{hyperref}


\begin{document}
\SweaveOpts{concordance=TRUE}
\SweaveOpts{keep.source=TRUE} 


\hspace{-1.5em}Gene Network\\
COMT expression correlations Prefrontal cortext\\
Fall, 2017\\

<<echo=FALSE>>=
library(ggplot2,ggthemes)
library(ggExtra)
library(psych)
library(ggpubr)       ### Make sure this is installed
library(knitr)
library(Hmisc)
library(openxlsx)
library(xtable)
library(magrittr)
library(tables)
library(stargazer)
library(plyr)
library(rlist)
library(qqman)
library(manhattanly)
library(Cairo)
library(RColorBrewer)
library(HGNChelper)
library(tools)
library(scales)
library(devtools)

if (!exists("drveera/ggman")) {
  install_github("drveera/ggman")   
}


library(ggman)
library(dplyr)
library(biomaRt)
library(combinat)
library(Rmpfr)
library(stats)

source("https://bioconductor.org/biocLite.R")
if (!exists("GenomicFeatures")) {
  biocLite(c("GenomicFeatures"))   
}

if (!exists("AnnotationDbi")) {
  biocLite(c("AnnotationDbi"))   
}

if (!exists("org.Hs.eg.db")) {
  biocLite(c("org.Hs.eg.db"))   
}

library("AnnotationHub")
library("GenomicFeatures")
library("org.Hs.eg.db")

source("https://bioconductor.org/workflows.R")

if (!exists("annotation")) {
 workflowInstall("annotation")   
}

if (!exists("txdb")) {
 biocLite("TxDb.Hsapiens.UCSC.hg19.knownGene")
 library(TxDb.Hsapiens.UCSC.hg19.knownGene)
 txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene #shorthand (for convenience)    
}

if (!exists("GO.db")) {
biocLite("GO.db")
}

if (!exists("topGO")) {
biocLite("topGO")
}     

if (!exists("GOstats")) {
biocLite("GOstats")
} 
     
library("GO.db")
library("topGO")
library("GOstats")

if (!exists("illuminaHumanv2.db")) {
     biocLite (c( "beadarray" , "limma" , "GEOquery" , "illuminaHumanv2.db"))
}

library("illuminaHumanv2.db")
library("beadarray","limma","GEOquery")

options(scipen = 999, digits = 5, width = 60)
@

<<echo=FALSE, results=hide >>=
### to prepend filename strings to plots
#pre.Name <- c('comt_expression-') #pre-ppended to eps output files
# RColorBrewer palette
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
source('/Volumes/Macintosh_HD_3/genetics/genenetwork/histChrfunc.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork/onlycisChr.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork/hypergeom_plot.R')

samp.Size <- c(50,200)
cut.Part <- samp.Size[2]
@

<<echo=FALSE, include=FALSE, results=tex>>=
coexpress.URL <- data.frame(site=NA,addr=NA)
coexpress.URL[1,1:2] <- c('COXPRESdb','http://coxpresdb.jp/')
coexpress.URL[2,1:2] <- c('OMICtools','https://omictools.com/')
coexpress.URL[3,1:2] <- c('Coexpedia','http://www.coexpedia.org/search.php')
coexpress.URL[4,1:2] <- c('GeneFriends','http://www.genefriends.org/RNAseq/')

url.Tab <- xtable(coexpress.URL)
url.Table <- latex(url.Tab,file='',
                   caption = c("Gene Co-expression Databases"),
                   caption.loc = c('top'),
                     colname = c('Name','URL'),
                     rowlabel = c(''),
                     colnamesTexCmd="bfseries",
                     booktabs=TRUE,
                     label=c('tab:coexpressurls'),
                     na.blank = TRUE,
                     vbar = FALSE,
                     longtable=TRUE,
                     table.env=TRUE,
                     center=c('center'),
                     continued=c('Gene Co-expression Databases Continued'),
                     first.hline.double = TRUE,
                     append=FALSE
                     )
print(url.Table)


@


<<echo=FALSE>>=
### read the data file 

if (!exists('wb')) {
  wb <- loadWorkbook('comt_all_areas_correlation_results.xlsx')   
}

if (!exists('prefront.Data')) {
  prefront.Data <- data.frame(read.xlsx(wb,  # now tell R to read that workbook and which sheet
                                  sheet = "prefrontal"))

  chrom.Data <- data.frame(read.xlsx(wb,  # now tell R to read that workbook and which sheet
                         sheet = "chrom_length"))   
}


if (!exists('wpr')) {
  wpr <- loadWorkbook('mb_comt_top_pos_r_prefrontal.xlsx')   
}
if (!exists('topplusr.Data')) {
  topplusr.Data <- data.frame(read.xlsx(wpr,  # now tell R to read that workbook and which sheet
                                  sheet = "posr_prefront"))
}

if (!exists('wnr')) {
  wnr <- loadWorkbook('mb_comt_top_neg_r_prefrontal.xlsx')   
}
if (!exists('topplusr.Data')) {
  topminusr.Data <- data.frame(read.xlsx(wnr,  # now tell R to read that workbook and which sheet
                                  sheet = "negr_prefront"))
}


if (!exists('cbell.Data')) {

cbell.Data <- data.frame(read.xlsx(wb,         # now tell R to read that workbook and which sheet
                                  sheet = "cerebellum"))
}

if (!exists('tempor.Data')) {

tempor.Data <- data.frame(read.xlsx(wb,         # now tell R to read that workbook and which sheet
                                  sheet = "temporal"))
}


if (!exists('pons.Data')) {

pons.Data <- data.frame(read.xlsx(wb,         # now tell R to read that workbook and which sheet
                                  sheet = "pons"))
}

### Note to convert r correlations into p values use these transformations
### store the results in a column in the original data frame - without the print statements
# example: r = 0.809, n = 138
# r.test(n = , r12 = )
# out.t <- r.test(n = 138, r12 = 0.809)
# print(out.t$t,digits=10)
# [1] 16.05025766
# pval <- 2*pt(-abs(t),df=n-2)
# pval <- 2*pt(-abs(print(out.t$t,digits=20)),df=136)
# print(pval,digits=10)

@

<<echo=FALSE>>=
### Strip all characters after : in Location
prefront.Data$loc <- sub("\\::*\\s[0-9]*\\.[0-9]*","",prefront.Data$Location)
substring(prefront.Data$loc,1,3) <- "   "
prefront.Data$loc <- ordered(prefront.Data$loc)
### Get start locations from prefront.Data$Location
prefront.Data$bp <- as.numeric(sub('.*\\:', '', prefront.Data$Location))

########### Check for step that loses data when selecting specific chromosomes ##############
# prefront.Data$loc contains the chromosome number as a factor stripped from location
# prefront.Data$bp is the base pair location of the probe/gene within the chromosome
# head(prefront.Data$loc)
# head(prefront.Data$bp)


### Check and correct/update where possible gene symbols
### Need to remove '-' because R interprets it as math mode and halts when it doesn't find $
out.Symb <- checkGeneSymbols(prefront.Data$Symbol, unmapped.as.na=FALSE, hgnc.table=NULL)
prefront.Data$Symbol <-  out.Symb$Suggested.Symbol
prefront.Data$Symbol[which(prefront.Data$Symbol == '-')] <- c(".")

#### Clean illegal characters from the gene names: -
#grep('.*\\-',prefront.Data$Symbol)
prefront.Data$Symbol <- gsub("-", ".", prefront.Data$Symbol)

@

<<echo=FALSE>>=
### Strip all characters after : in Location
cbell.Data$loc <- sub("\\::*\\s[0-9]*\\.[0-9]*","",cbell.Data$Location)
substring(cbell.Data$loc,1,3) <- "   "
cbell.Data$loc <- ordered(cbell.Data$loc)
### Get start locations from cbell.Data$Location
cbell.Data$bp <- as.numeric(sub('.*\\:', '', cbell.Data$Location))


### Check and correct/update where possible gene symbols
### Need to remove '-' because R interprets it as math mode and halts when it doesn't find $
out.Symb <- checkGeneSymbols(cbell.Data$Symbol, unmapped.as.na=FALSE, hgnc.table=NULL)
cbell.Data$Symbol <-  out.Symb$Suggested.Symbol
cbell.Data$Symbol[which(cbell.Data$Symbol == '-')] <- c(".")

#### Clean illegal characters from the gene names: -
#grep('.*\\-',cbell.Data$Symbol)
cbell.Data$Symbol <- gsub("-", ".", cbell.Data$Symbol)

@

<<echo=FALSE, include=FALSE, results=hide>>=
########### Clean up cbell data ##############
# tempor.Data$loc contains the chromosome number as a factor stripped from location
# tempor.Data$bp is the base pair location of the probe/gene within the chromosome
# head(tempor.Data$loc)
# head(tempor.Data$bp)
### Strip all characters after : in Location
tempor.Data$loc <- sub("\\::*\\s[0-9]*\\.[0-9]*","",tempor.Data$Location)
substring(tempor.Data$loc,1,3) <- "   "
tempor.Data$loc <- ordered(tempor.Data$loc)
### Get start locations from tempor.Data$Location
tempor.Data$bp <- as.numeric(sub('.*\\:', '', tempor.Data$Location))


### Check and correct/update where possible gene symbols
### Need to remove '-' because R interprets it as math mode and halts when it doesn't find $
out.Symb <- checkGeneSymbols(tempor.Data$Symbol, unmapped.as.na=FALSE, hgnc.table=NULL)
tempor.Data$Symbol <-  out.Symb$Suggested.Symbol
tempor.Data$Symbol[which(tempor.Data$Symbol == '-')] <- c(".")

#### Clean illegal characters from the gene names: -
#grep('.*\\-',tempor.Data$Symbol)
tempor.Data$Symbol <- gsub("-", ".", tempor.Data$Symbol)

@

<<echo=FALSE, include=FALSE, results=hide>>=
########### Clean up cbell data ##############
# pons.Data$loc contains the chromosome number as a factor stripped from location
# pons.Data$bp is the base pair location of the probe/gene within the chromosome
# head(pons.Data$loc)
# head(pons.Data$bp)
pons.Data$loc <- sub("\\::*\\s[0-9]*\\.[0-9]*","",pons.Data$Location)
substring(pons.Data$loc,1,3) <- "   "
pons.Data$loc <- ordered(pons.Data$loc)
### Get start locations from pons.Data$Location
pons.Data$bp <- as.numeric(sub('.*\\:', '', pons.Data$Location))


### Check and correct/update where possible gene symbols
### Need to remove '-' because R interprets it as math mode and halts when it doesn't find $
out.Symb <- checkGeneSymbols(pons.Data$Symbol, unmapped.as.na=FALSE, hgnc.table=NULL)
pons.Data$Symbol <-  out.Symb$Suggested.Symbol
pons.Data$Symbol[which(pons.Data$Symbol == '-')] <- c(".")

#### Clean illegal characters from the gene names: -
#grep('.*\\-',pons.Data$Symbol)
pons.Data$Symbol <- gsub("-", ".", pons.Data$Symbol)

@


<<echo=FALSE>>=
### Function to take a vector of numbers, and turn it into a comma-separated string.

comma.Sep <- function(in.vec) {
  out.Sep <- c('')
    out.Sep <- c(paste(out.Sep,as.character(in.vec[1]),sep=''))
  
  if (length(in.vec) > 1) {
    
    for (q in 2:length(in.vec)) {
      out.Sep <- c(paste(out.Sep,', ',as.character(in.vec[q])))
    }

  } else {
    
  }
        
    return(out.Sep)
}

@



<<echo=FALSE, results=hide>>=
### Function to plot on equal-SD scaled square axes.
######################### Begin square.Axes function ###################################
square.Axes <- function(xvar,yvar,title.Text,xlabel.Text,ylabel.Text,corval) {
  
  dat <- data.frame(x = c(xvar), y = c(yvar))
  
  range.Lims.x <- c(mean(xvar) - 4*sd(xvar), mean(xvar) + 4*sd(xvar))
  range.Lims.y <- c(mean(yvar) - 4*sd(yvar), mean(yvar) + 4*sd(yvar))
  
  
  
  sq.Plt <-   ggplot(dat, aes(x=xvar,y=yvar)) +
    geom_point(color = "blue",size=1.0) + 
    geom_smooth(method=lm,   # Add linear regression line
                se=FALSE,
                color="yellow",
                size = 1)  +  # Don't add shaded confidence region
    #            theme(aspect.ratio=1) +
    # This adds  the little lines to each axis that represent the densities of the variables
    geom_rug() +    
    geom_abline(intercept = mean(yvar)  + (-sign(corval))*(mean(xvar)/sd(xvar))*sd(yvar),
                slope = sign(corval)*(sd(yvar)/sd(xvar)),
                linetype='dashed',
                size = 1) + 
    scale_y_continuous(name=ylabel.Text,
                       limits=range.Lims.y) +
    scale_x_continuous(name=xlabel.Text,
                       limits=range.Lims.x) +
    ggtitle(title.Text) + 
#    theme_minimal() + 
    theme_classic() + 
    theme(aspect.ratio=1) +
    theme(axis.line = element_line(colour = "grey80",size=1.0),
          panel.border = element_rect(colour = "grey80", fill=NA,
                                      size=2.5)) +
    theme(plot.title = element_text(color="black",
                                    face="bold",
                                    size=18,
                                    hjust=0.5)) +
    theme(axis.title = element_text(color="black",
                                    size=15)) +
    theme(axis.text.x = element_text(size=14),
          axis.text.y = element_text(size=14)) +
    geom_vline(xintercept = mean(xvar),
               col='red',
               size = 1) +
    geom_hline(yintercept = mean(yvar),
               col='red',
               size = 1) +
    annotate("text", x = mean(xvar)+3*sd(xvar),
             y = mean(yvar)+3.8*sd(yvar),
             label = c(paste('r = ',toString(corval),sep='')),
             color="black",
             size=5)
  
  return(sq.Plt) # This is what gets returned by the function. In this case it is an actual plot.
}                # <<<< This is actually the last stement in the function.
######
@


%%%%%%%%%%%%%%% Statistics

<<echo=FALSE, results=tex>>=
prefront.Meanposr <- data.frame(mean=NA,corr=NA,chr=NA,gene=NA,bp=NA,pval=NA,record=NA)
prefront.Meannegr <- data.frame(mean=NA,corr=NA,chr=NA,gene=NA,bp=NA,pval=NA,record=NA)
prefront.Meanbothr <- data.frame(mean=prefront.Data$Mean,corr=prefront.Data$Sample.r,chr=prefront.Data$loc,
                             gene=prefront.Data$Symbol,bp=prefront.Data$bp,pval=prefront.Data$Sample.p.r.,record=prefront.Data$Record)
prefront.Meanbothr$corsign <- as.factor(sign(prefront.Data$Sample.r))

# #####################################################################
# #  Run this code AFTER the rankings and comparisons have been made
# # All rows have an Illumina probe number, so don't necessarily need
# # Chr until later
# #####################################################################
# ############# The next set of code attempts to recover the chromosome numbers for all of the ############# rows in which chromosome is listed as Un or unknown
# 
# temp.Un <- subset(prefront.Meanbothr,prefront.Meanbothr$chr == '   Un')
# 
# # temp.Un.compl holds all of the data for which the probe chromosomes are known
# temp.Un.compl <- subset(prefront.Meanbothr,prefront.Meanbothr$chr != '   Un')
# 
# # add a column to temp.Un that holds the index of each 'Un' chromosome in the original prefront.Meanbothr data.frame
# 
# temp.Un$ind.Un <- as.numeric(row.names(temp.Un))
# 
# # Now use the gene symbol to look up the chromosome number
# # First need to get the EntrezIDs based on gene symbols
# 
# if (!exists('ensembl')) {
#  ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")   
# }
# 
# normal.chroms <- c(1:22, "X", "Y", "M")
# 
# if (!exists('ah')) {
#  ah <- AnnotationHub()   
# }
# 
# if (!exists('orgs')) {
#  orgs <- AnnotationHub::query(ah, "org.Hs.eg.db")   
# }
# 
# if (!exists('gene.DB')) {
#  gene.DB <- orgs[["AH57973"]]   
# }
# 
# # columns(gene.DB)
# # keytypes(gene.DB)
# 
# # input gene symbol output EntrezID
# # temp.Gene <- c('COMT',   'PHGDH',  'DDR1',   'SCAMP2', 'ZFAND3', 'NECAP2', 'HDAC1',  'FTL', 'TST',    'CRYL1')
# # Eliminate duplicate gene symbols
# temp.Un <- temp.Un[which(!duplicated(temp.Un$gene)),]
# 
# temp.Un.entrez <- unique(biomaRt::select(gene.DB,keys=as.character(temp.Un$gene),columns=c('GENENAME','SYMBOL','ENTREZID','MAP'),keytype=c('SYMBOL')))
# 
# temp.Un.entrez <- temp.Un.entrez[!is.na(temp.Un.entrez$MAP),]
# 
# temp.Un.entrez <- temp.Un.entrez[!duplicated(temp.Un.entrez$ENTREZID),]
# 
# common.Genes <- intersect(temp.Un.entrez$SYMBOL,temp.Un$gene)
# 
# common.Genes.ind <- as.numeric(c(0,length(common.Genes)))
# 
# # common.Genes.ind holds the indices in temp.Un for which the gene symbols in common.Genes match
# 
# for (i in 1:length(common.Genes)) {
#      
#      common.Genes.ind[i] <- which(common.Genes[i] == temp.Un$gene)
#      
# }
# 
# # Now temp.Un.final holds only those rows for which the chromosome was originally unknown ad now for which the rows contain either no duplicate genes or no NAs in the row
# temp.Un.final <- temp.Un[common.Genes.ind,]
# 
# # need to add ENTREZID column to temp.Un.final
# 
# temp.Un.final$ENTREZID <- temp.Un.entrez$ENTREZID
# 
# # Now temp.Un.final$ENTREZID can be used to look up the chromosome numberm of the probes for which it was originally unknown 
# 
#  temp.Chr.Un <- select(txdb, keys = as.character(temp.Un.final$ENTREZID), columns=c("TXCHROM"), keytype="GENEID")
#  
#  temp.Chr.Un <- temp.Chr.Un[which(!duplicated(temp.Chr.Un$GENEID)),]
#  
#  temp.Chr.Un$TXCHROM <- gsub("chr", "", temp.Chr.Un$TXCHROM)
# 
# temp.Un.final$chr <- temp.Chr.Un$TXCHROM
# 
# temp.Un.final <- temp.Un.final[!is.na(temp.Un.final$chr),]
# 
# # strip last two columns from temp.Un.final
# temp.Un.final <- temp.Un.final[,1:8]
# 
# temp.Un.final$chr <- ordered(temp.Un.final$chr)
# 
# # Now recombine the original data set for which chromosome numbers were know with this subset for which unknown chromosome numbers could be recovered
# # Need to make sure that temp.Un.compl has not been sorted on any dimension.
# # It would be prefront.Meanbothr that could have been sorted because the chr recovery code
# # used a subset of that data -- It has nopt been sorted in any way.
# # Overwrite prefront.Meanbothr
# 
# if (!exists("prefront.Meanbothr")) {
#      prefront.Meanbothr <- rbind(temp.Un.compl,temp.Un.final)
# }
# 
# prefront.Meanbothr$chr <- ordered(gsub("   ", "", as.character(prefront.Meanbothr$chr)))
# 
# 
# # order the chromosomes by magnitude of correlation
# prefront.Meanbothr <- prefront.Meanbothr[order(prefront.Meanbothr$corr,decreasing=TRUE),]
# 
# 
# ####### Note: this was only done for the prefrontal data     
# 
# ######### End of Unknown chromosome recovery code #######################



# Table of frequencies of pos and neg correlated genes per chromosome


df2 <- data.frame(table(prefront.Meanbothr$chr,prefront.Meanbothr$corsign))
df2 <- data.frame(df2,chr=rep(c(1,10,11,12,13,14,15,16,17,18,19,2,20,21,22,3,4,5,6,7,8,9,23,24,25),2))
colnames(df2) <- c('origchr','corsign','freq','chr')
df2$chr <- as.numeric(df2$chr)
dfsort <-df2[order(df2$corsign,df2$chr), ]


### First column is redundant
dfsort <- dfsort[,2:4]
dfsort <- dfsort[,c(3,1,2)]
dfsort$chr <- ordered(dfsort$chr)

posrmeans.pf <- prefront.Meanbothr$mean[which(prefront.Meanbothr$corr > 0)]
negrmeans.pf <- prefront.Meanbothr$mean[which(prefront.Meanbothr$corr < 0)]
posrcorrs.pf <- prefront.Meanbothr$corr[which(prefront.Meanbothr$corr > 0)]
negrcorrs.pf <- prefront.Meanbothr$corr[which(prefront.Meanbothr$corr < 0)]
posrchr.pf <- as.factor(prefront.Meanbothr$chr[which(prefront.Meanbothr$corr > 0)])
negrchr.pf <- as.factor(prefront.Meanbothr$chr[which(prefront.Meanbothr$corr < 0)])
posgene.pf <- prefront.Meanbothr$gene[which(prefront.Meanbothr$corr > 0)]
neggene.pf <- prefront.Meanbothr$gene[which(prefront.Meanbothr$corr < 0)]
posbp.pf <- prefront.Meanbothr$bp[which(prefront.Meanbothr$corr > 0)]
negbp.pf <- prefront.Meanbothr$bp[which(prefront.Meanbothr$corr < 0)]
pospval.pf <- prefront.Meanbothr$pval[which(prefront.Meanbothr$corr > 0)]
negpval.pf <- prefront.Meanbothr$pval[which(prefront.Meanbothr$corr < 0)]
posrecord.pf <- prefront.Meanbothr$record[which(prefront.Meanbothr$corr > 0)]
negrecord.pf <- prefront.Meanbothr$record[which(prefront.Meanbothr$corr < 0)]
poscorsign.pf <- prefront.Meanbothr$corsign[which(prefront.Meanbothr$corr > 0)]
negcorsign.pf <- prefront.Meanbothr$corsign[which(prefront.Meanbothr$corr < 0)]


prefront.Meanposr <- data.frame(mean=posrmeans.pf,corr=posrcorrs.pf,chr=posrchr.pf,gene=posgene.pf,bp=posbp.pf,pval=pospval.pf,record=posrecord.pf,corsign=poscorsign.pf)
prefront.Meannegr <- data.frame(mean=negrmeans.pf,corr=negrcorrs.pf,chr=negrchr.pf,gene=neggene.pf,bp=negbp.pf,pval=negpval.pf,record=negrecord.pf,corsign=negcorsign.pf)
prefront.Meanposr$chr <- as.character(prefront.Meanposr$chr)
prefront.Meannegr$chr <- as.character(prefront.Meannegr$chr)


#### Replace Chr 'X' with 23
# prefront.Meanposr$chr[which(prefront.Meanposr$chr == 'X')] <- as.factor(c('23'))
# prefront.Meannegr$chr[which(prefront.Meannegr$chr == 'X')] <- as.factor(c('23'))
# 
# #### Replace Chr 'Y' with 24
# prefront.Meanposr$chr[which(prefront.Meanposr$chr == 'Y')] <- as.factor(c('   24'))
# prefront.Meannegr$chr[which(prefront.Meannegr$chr == 'Y')] <- as.factor(c('   24'))

### Positive r only
manhat.Posr.pf <- data.frame(CHR=as.integer(prefront.Meanposr$chr), 
                          BP=prefront.Meanposr$bp,P=prefront.Meanposr$pval,
                          GENE=prefront.Meanposr$gene,
                          CORR=prefront.Meanposr$corr,
                          MEAN=prefront.Meanposr$mean
                          )
manhat.Posr.pf$CHR <- as.integer(as.character(manhat.Posr.pf$CHR))
manhat.Posr.pf$GENE <- as.character(manhat.Posr.pf$GENE)
# Save data including COMT for later analysis
manhat.Posr.pf.withCOMT <- manhat.Posr.pf
#### Exclude COMT because p = 0.000
manhat.Posr.pf <- manhat.Posr.pf[2:dim(manhat.Posr.pf)[1],]


### Negative r only
manhat.Negr.pf <- data.frame(CHR=as.integer(prefront.Meannegr$chr), 
                          BP=prefront.Meannegr$bp,P=prefront.Meannegr$pval,
                          GENE=prefront.Meannegr$gene,
                          CORR=prefront.Meannegr$corr,
                          MEAN=prefront.Meannegr$mean
                          )
manhat.Negr.pf$CHR <- as.integer(as.character(manhat.Negr.pf$CHR))
manhat.Negr.pf$GENE <- as.character(manhat.Negr.pf$GENE)


# Reverse order in columns so that the most negative correlations are at the bottom\

manhat.Negr.pf <- manhat.Negr.pf[c(dim(manhat.Negr.pf)[1]:1),]

@

<<echo=FALSE, include=FALSE, results=hide>>=
### Create a data.frame with all areas, but only those variables necessary to find the top N genes averaged across all four areas. Use Alexander's (1990) method for averaging correlations.

### The relevant variables are:
#### area: prefront, cbell, tempcort, pons
#### Chr number
#### Gene Symbol
#### Correlation of expression with COMT expressiomn in that area
#### P-value of correlation

# dimensions of data sets
dim.Area <- data.frame(area=c('prefront', 'cbell','tempor','pons'),
                       len=rep(0,4), wid=rep(0,4))
# prefrontal
dim.Area$len[1] <- dim(prefront.Meanbothr)[1]
dim.Area$wid[1] <- dim(prefront.Meanbothr)[2]

#cerebellum
dim.Area$len[2] <- dim(cbell.Data)[1]
dim.Area$wid[2] <- dim(cbell.Data)[2]

#temporal cortex
dim.Area$len[3] <- dim(tempor.Data)[1]
dim.Area$wid[3] <- dim(tempor.Data)[2]

#pons
dim.Area$len[4] <- dim(pons.Data)[1]
dim.Area$wid[4] <- dim(pons.Data)[2]

@

<<include=FALSE,echo=FALSE,results=hide>>=

all.Area.dat <- data.frame(areapf=rep(NA,dim.Area$len[1]),
                           chrpf=rep(NA,dim.Area$len[1]),
                           genepf=rep(NA,dim.Area$len[1]),
                           corrpf=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpf=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpf=rep(NA,dim.Area$len[1]),
                           areacb=rep(NA,dim.Area$len[1]),
                           chrcb=rep(NA,dim.Area$len[1]),
                           genecb=rep(NA,dim.Area$len[1]),
                           corrcb=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalcb=as.numeric(rep(NA,dim.Area$len[1])),
                           illumcb=rep(NA,dim.Area$len[1]),
                           areatc=rep(NA,dim.Area$len[1]),
                           chrtc=rep(NA,dim.Area$len[1]),
                           genetc=rep(NA,dim.Area$len[1]),
                           corrtc=as.numeric(rep(NA,dim.Area$len[1])),
                           pvaltc=as.numeric(rep(NA,dim.Area$len[1])),
                           illumtc=rep(NA,dim.Area$len[1]),
                           areapo=rep(NA,dim.Area$len[1]),
                           chrpo=rep(NA,dim.Area$len[1]),
                           genepo=rep(NA,dim.Area$len[1]),
                           corrpo=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpo=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpo=rep(NA,dim.Area$len[1])
                           )




prefront.Ess <- data.frame(area=rep('prefront',dim.Area$len[1]),
                      loc=prefront.Meanbothr$chr,
                      Symbol=prefront.Meanbothr$gene,
                      Sample.r=prefront.Meanbothr$corr,
                      Sample.p.r=prefront.Meanbothr$pval,
                      Record=prefront.Meanbothr$record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(prefront.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
prefront.Ess <- prefront.Ess[c(sort.Ind$ix),]


cbell.Ess <- data.frame(area=rep('cbell',dim.Area$len[1]),
                      loc=cbell.Data$loc,
                      Symbol=cbell.Data$Symbol,
                      Sample.r=cbell.Data$Sample.r,
                      Sample.p.r=cbell.Data$Sample.p.r.,
                      Record=cbell.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(cbell.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
cbell.Ess <- cbell.Ess[c(sort.Ind$ix),]


tempor.Ess <- data.frame(area=rep('tempor',dim.Area$len[1]),
                      loc=tempor.Data$loc,
                      Symbol=tempor.Data$Symbol,
                      Sample.r=tempor.Data$Sample.r,
                      Sample.p.r=tempor.Data$Sample.p.r.,
                      Record=tempor.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(tempor.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
tempor.Ess <- tempor.Ess[c(sort.Ind$ix),]


pons.Ess <- data.frame(area=rep('pons',dim.Area$len[1]),
                      loc=pons.Data$loc,
                      Symbol=pons.Data$Symbol,
                      Sample.r=pons.Data$Sample.r,
                      Sample.p.r=pons.Data$Sample.p.r.,
                      Record=pons.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(pons.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
pons.Ess <- pons.Ess[c(sort.Ind$ix),]

all.Area.dat[,1:6] <- prefront.Ess
all.Area.dat[,7:12] <- cbell.Ess
all.Area.dat[,13:18] <- tempor.Ess
all.Area.dat[,19:24] <- pons.Ess

cols.Corr <- c(4,10,16,22)
cols.Gene <- c(3,9,15,21)

ind.Ill <- matrix(rep(NA,4*dim.Area$len[1]),ncol=4)
for (i in 1:dim.Area$len[1]) {
     
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumcb)) {
               ind.Ill[i,2] <- which(as.character(all.Area.dat$illumcb)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,2] <- c(NA)
     }         
               
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumtc)) {            ind.Ill[i,3] <- which(as.character(all.Area.dat$illumtc)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,3] <- c(NA)
     }         
               
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumpo)) {
          ind.Ill[i,4] <- which(as.character(all.Area.dat$illumpo)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,4] <- c(NA)
     } 
          
          }

ind.Ill[,1] <- seq(1,dim.Area$len[1],1)     

#### ******* In all.Area.dat, each areas columns, are sorted separately by area on the correlation. ind.Ill shows where each probe is (index) by area


# This orders the data independently in each brain area by a particular variable
# all.Area.dat[,1:6] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[1]]),decreasing=FALSE),c(1:6)]
# all.Area.dat[,7:12] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[2]]),decreasing=FALSE),c(7:12)]
# all.Area.dat[,13:18] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[3]]),decreasing=FALSE),c(13:18)]
# all.Area.dat[,19:24] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[4]]),decreasing=FALSE),c(19:24)]

@

<<include=FALSE, echo=FALSE, results=tex>>=
# Calculate average correlation with COMT expression of each probe's expression
# Use Alexander (1990) to average correlations
# ind.Ill holds the indices for cerebellum, temporal cortex and pons of each probe on prefrontal cortex.

hold.Corrs <- data.frame(illum=rep(NA,dim.Area$len[1]),
                         gene=rep(NA,dim.Area$len[1]),
                         corpf=rep(0,dim.Area$len[1]),
                         corcb=rep(0,dim.Area$len[1]),
                         cortc=rep(0,dim.Area$len[1]),
                         corpo=rep(0,dim.Area$len[1])
                         )

##### ***** The next code sorts hold.Corrs by the sorted correlations in the prefrontal cortex
##### ***** In other words, the correlations are no longer sorted separately by area, but ###### instead the probeID order in prefrontal cortex after having been sorted by pf
##### correlation determines the correlations shown in that row in the other three areas
# For example, just making up a scenario, whatever probeID has the second strongest expression correlation with COMT in prefrontal cortex might have a correlation of r=.65 in the cerebellum. That is the correlation that would show up in the second row for the cerebellum

hold.Corrs$illum <- all.Area.dat$illumpf
hold.Corrs$gene <- all.Area.dat$genepf
hold.Corrs$corpf <- all.Area.dat$corrpf
hold.Corrs$corcb <- all.Area.dat$corrcb[c(ind.Ill[,2])]
hold.Corrs$cortc <- all.Area.dat$corrtc[c(ind.Ill[,3])]
hold.Corrs$corpo <- all.Area.dat$corrpo[c(ind.Ill[,4])]

# average these four correlations and put them into a new column
# Use Alexander (1990) to average

ki <- c(4)
n.subj <- c(144,144,144,144)

# Calculate in parts then put together

sum.corr <- matrix(rep(0,dim.Area$len[1]),ncol=1)
for (l in 1:dim.Area$len[1]) {
     
     sum.corr[l] <-sum((((n.subj[1:4] - 1))/(sum(n.subj) - ki))*(hold.Corrs[l,3:6] + (hold.Corrs[l,3:6]*(1 - hold.Corrs[l,3:6]^2))/(2*(n.subj[1:4] - 3))))
     
hold.Corrs$avgCorr[l] <- sum.corr[l]
}

@

<<include=FALSE, echo=FALSE, results=tex>>=

## Leave columns sorted by correlation in prefrontal cortex

top50_pos_ordered_by_pf_corr <- xtable(hold.Corrs[1:50,],
                           caption=c('Correlations of expression with COMT in each brain area for the 50 probes that show the strongest positive correlations in prefrontal cortex'))


write.table(hold.Corrs[1:50,],file='top50_pos_ordered_by_pf_corr.csv',sep=', ',row.names = FALSE,
            quote=FALSE)
write.table(hold.Corrs[1:50,1:3],file='top50_pos_corr_prefront.csv',sep=', ',row.names = FALSE,
            quote=FALSE)



top50_neg_ordered_by_pf_corr <- xtable(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-50),],
                           caption=c('Correlations of expression with COMT in each brain area for the 50 probes that show the strongest negative correlations in prefrontal cortexn'))

# Note that these are written in reverse order because they are negative: 20,000:19950
write.table(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-50),],file='top50_neg_ordered_by_pf_corr.csv',sep=', ',row.names = FALSE,quote=FALSE)
write.table(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-50),1:3],file='top50_neg_corr_prefront.csv',sep=', ',row.names = FALSE,quote=FALSE)


@



<<include=FALSE, echo=FALSE, results=tex>>=
# Tally the chromosome numbers of the top 50 + and top 50 - in each brain area separately
# Are (+) correlated genes more likely to be on the same chromosome than (-) correlated genes?
# Do this both for the top 50 as well as for all 20000 probes.
# Use the data.frame dfsort
# colnames(dfsort)
#[1] "chr"     "corsign" "freq"
# dfsort is already in tabular form

corsign.By.chr <- dfsort
corsign.By.chr$pm <- factor(rep(c('minus','plus'),each=24))
corsign.By.chr <- corsign.By.chr[,c(1,4,3)]

colnames(corsign.By.chr) <- c('chr','corsign','count')

xtabs.ChrCorsign <- xtabs(count ~ chr + corsign,data=corsign.By.chr)

chisq.ChrCorsign.out <- chisq.test(xtabs.ChrCorsign)
print(chisq.ChrCorsign.out)

@

The chi-square test of independence shows that the number of genes showing positive versus negative correlations with COMT is not independent of Chromosome number in prefrontal cortex.\\

Next, use the binomial distribution to determine if the distribution on Chr 22 where COMT is differs from the distribution on all other chromosomes.\\

<<include=FALSE, echo=FALSE, results=tex>>=
# First get the numbers of plus and minus correlations aggregated across all chromosomes except Chr 22.
# Get total probes/genes on Chr 22

pm.Sans22 <- c(rep(0,2))
pm.Sans22[1] <- sum(xtabs.ChrCorsign[,1]) - xtabs.ChrCorsign[22,1]
pm.Sans22[2] <- sum(xtabs.ChrCorsign[,2]) - xtabs.ChrCorsign[22,2]

counts.22 <- sum(xtabs.ChrCorsign[22,])
counts.Sans22 <- sum(pm.Sans22)

obs.Minus.22 <- xtabs.ChrCorsign[22,1]

p.minus.22 <- obs.Minus.22/counts.22


# probability of negative correlations across all chromosomes except Chr 22
p.minus <- pm.Sans22[1]/counts.Sans22

# get the binomial distribution with p = p.minus and the sample size of the number of probes on Chr 22
d.minus <- dbinom(seq(0,counts.22,1),counts.22,p.minus)

d.minus <- data.frame(num.minus = seq(0,counts.22,1),prob=d.minus)

# Now get the probability of xtabs.ChrCorsign[22,1] minuses or fewer given counts.22 probes. In this case
# p(k <= 286 minuses) with Binomial(N=19171, p = 0.63888)

cumul.d.minus <- sum(d.minus[1:(obs.Minus.22 + 1),2])

binom.test(obs.Minus.22, counts.22, p = p.minus,
           alternative = c("less"),
           conf.level = 0.95)

binom.test(obs.Minus.22, counts.22, p = p.minus,
           alternative = c("two.sided"),
           conf.level = 0.95)


# The proportion of negatively COMT-correlated genes in prefrontal cortex, 0.54806, is significantly lower than the proportion aggregated across all the other chromosomes, 0.63888.
@

The proportion genes with negative correlations mwith MB-COMT on Chr 22, \Sexpr{p.minus.22}, is signficantly lower that the proportion aggregated across all of the other chromosomes, \Sexpr{p.minus}.\\ 

<<include=FALSE, echo=FALSE, fig=TRUE, pdf=TRUE>>=
gold.R <- c(1.61803398875)

vcut <- data.frame(x1=(obs.Minus.22 + 0.5), x2=(obs.Minus.22 + 0.5), y1=-0.00075, y2=0.02)
p.low.d.minus <- subset(d.minus,d.minus$num.minus < (obs.Minus.22 + 1))

minus.plot <- ggplot() +
          
          geom_point(data=d.minus, aes(x=num.minus,y=prob,group=1),
                     size=0.6,color='blue',shape=1) +
     
          geom_point(data=p.low.d.minus, aes(x=num.minus,y=prob,group=1),
                     size=0.6,color='red',shape=1) +
     
          geom_segment(data=vcut, aes(x=x1,xend=x2,y=y1,yend=y2), color='red',size=0.5)  +
          
          scale_y_continuous(breaks = seq(0,0.05,0.01),
                             labels = comma(seq(0,0.05,0.01), digits = 2)) +
          
          scale_x_continuous(name='Number of Negative Correlations (k)',
                             limits=c(0,round((counts.22 + 5),0)),
                             breaks=seq(0,round((counts.22 + 5),0),50)) +
          
          theme_classic() +
          
          
          ggtitle('Probability of Negative Correlations Based on All Chromosomes Except Chr 22' ) +
          
          ylab('Probability density') + 
          theme(aspect.ratio=1/gold.R) + 
          theme(plot.title = element_text(color="black",
                                          size=8.5,
                                          hjust=0.5)) +
          theme(axis.title = element_text(color="black",
                                          size=10,
                                          vjust=1
          )) +

               theme(axis.text.x = element_text(size=8),
                axis.text.y = element_text(size=8)) +
          
          annotate("text", x = (obs.Minus.22 - 65),
                   y = 0.005,
                   label = c(paste('p(k < ',(obs.Minus.22 + 1),') = ',
                                   round(cumul.d.minus,8),sep='')),
                   color="black",
                   size=3.0)    +
     
          annotate("text", x = 0.10*(round((counts.22 + 5),0)),
                   y = 1.10*max(d.minus$prob),
                   label = c(paste('unique ID: ',prog.Name,sep='')),
                   parse=FALSE,
                   color="gray20",
                   size=1.5) 

file1.pdf <- c('p_binomial_mb_comt.pdf')
   ggsave(file1.pdf, plot = minus.plot, width = 8, height = 5.5)

minus.plot

@

%\includegraphics[width=0.5\textwidth]{p_binomial_comt_s.eps}\\

<<include=FALSE, echo=FALSE, results=tex>>=
#Get the mean and sd of the top 50 positives and negatives in each area

mean.sd.By.areaPos <- psych::describe(all.Area.dat[2:51,cols.Corr])
mean.sd.By.areaNeg <- psych::describe(all.Area.dat[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]- cut.Part),cols.Corr])


@





<<include=FALSE, echo=FALSE, results=TEX>>= 
# Test the hypothesis that the rank order of the most negatively correlated genes changes more across brain area than do the rank orders of the most highly positively correlated genes.

# Rank the genes on their correlations separately by area, then compare the ranks of specific genes across areas to determine if there are greater differences among negatively correlated genes than among positively correlated genes.

### Do this with the all.Area.dat which has the strongest correlations in each brain area separately. Have to use ind.Ill to find out what those probes are in each area.

hold.Area.dat <- data.frame(areapf=rep(NA,dim.Area$len[1]),
                           chrpf=rep(NA,dim.Area$len[1]),
                           genepf=rep(NA,dim.Area$len[1]),
                           corrpf=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpf=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpf=rep(NA,dim.Area$len[1]),
                           areacb=rep(NA,dim.Area$len[1]),
                           chrcb=rep(NA,dim.Area$len[1]),
                           genecb=rep(NA,dim.Area$len[1]),
                           corrcb=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalcb=as.numeric(rep(NA,dim.Area$len[1])),
                           illumcb=rep(NA,dim.Area$len[1]),
                           areatc=rep(NA,dim.Area$len[1]),
                           chrtc=rep(NA,dim.Area$len[1]),
                           genetc=rep(NA,dim.Area$len[1]),
                           corrtc=as.numeric(rep(NA,dim.Area$len[1])),
                           pvaltc=as.numeric(rep(NA,dim.Area$len[1])),
                           illumtc=rep(NA,dim.Area$len[1]),
                           areapo=rep(NA,dim.Area$len[1]),
                           chrpo=rep(NA,dim.Area$len[1]),
                           genepo=rep(NA,dim.Area$len[1]),
                           corrpo=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpo=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpo=rep(NA,dim.Area$len[1])
                           )
     
cols.Corr <- c(4,10,16,22)
cols.Gene <- c(3,9,15,21)     
     
hold.Area.dat[,1:6] <- all.Area.dat[order(all.Area.dat[,cols.Corr[1]],decreasing=TRUE),c(1:6)]
hold.Area.dat[,7:12] <- all.Area.dat[order(all.Area.dat[,cols.Corr[2]],decreasing=TRUE),c(7:12)]
hold.Area.dat[,13:18] <- all.Area.dat[order(all.Area.dat[,cols.Corr[3]],decreasing=TRUE),c(13:18)]
hold.Area.dat[,19:24] <- all.Area.dat[order(all.Area.dat[,cols.Corr[4]],decreasing=TRUE),c(19:24)]

@


<<include=FALSE, echo=FALSE, results=tex>>=
# now for the 50 genes with the largest negative correlations in Prefrontal Cortex, find their ranks in the other three areas



rank.Stab.neg <- matrix(rep(0,4*cut.Part),ncol=4)

# First do negative correlations
for (h in 1:cut.Part) {
     
     rank.Stab.neg[h,1] <-(20000 - (cut.Part -h))
     
     if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumcb)) {
          rank.Stab.neg[h,2] <- which(as.character(hold.Area.dat$illumcb) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,2] <-  c(NA)  
          
     }    
     
     if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumtc)) {
          rank.Stab.neg[h,3] <- which(as.character(hold.Area.dat$illumtc) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,3] <-  c(NA)  
          
     }
     
    if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumpo)) {
          rank.Stab.neg[h,4] <- which(as.character(hold.Area.dat$illumpo) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,4] <-  c(NA)  
          
     }
     
}

colnames(rank.Stab.neg) <- c('rankpf','rankcb','ranktc','rankpo')
rank.Stab.neg <- data.frame(rank.Stab.neg)
rank.Stab.neg$illum <- hold.Area.dat$illumpf[(20000 - (cut.Part -1)):20000]
rank.Stab.neg$gene <- hold.Area.dat$genepf[(20000 - (cut.Part -1)):20000]
rank.Stab.neg <- rank.Stab.neg[,c(5,6,1:4)]

overlap.Area <- list()

# [[1]] pf vs cb
# [[2]] pf vs tc
# [[3]] pf vs po
# [[4]] cb vs tc
# [[5]] cb vs po
# [[6]] tc vs po

overlap.Area[[1]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$rankcb)
overlap.Area[[2]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$ranktc)
overlap.Area[[3]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$rankpo)
overlap.Area[[4]] <- intersect(rank.Stab.neg$rankcb,rank.Stab.neg$ranktc)
overlap.Area[[5]] <- intersect(rank.Stab.neg$rankcb,rank.Stab.neg$rankpo)
overlap.Area[[6]] <- intersect(rank.Stab.neg$ranktc,rank.Stab.neg$rankpo)

perc.Overlap <- data.frame(compare=(rep(NA,6)),num=c(rep(0,6)),percentage=c(rep(0,6)),
                           n.base=c(rep(0,6)),ofn=c(rep(NA,6)))
perc.Overlap$compare <- c('prefrontal cortex vs. cerebellum',
                         'prefrontal cortex vs. temporal cortex',
                         'prefrontal cortex vs. pons',
                         'cerebellum vs. temporal cortex',
                         'cerebellum vs. pons',
                         'temporal cortex vs. pons')

for (g in 1:6) {
     
    perc.Overlap$n.base[g]  <- cut.Part - length(which(is.na(rank.Stab.neg[,g])))
     perc.Overlap$num[g]  <- length(overlap.Area[[g]]) 
    perc.Overlap$percentage[g]  <- paste(round(100*(perc.Overlap$num[g])/(perc.Overlap$n.base[g]),0),'%',sep='')
}

perc.Overlap.neg <- perc.Overlap
perc.Overlap.neg$ofn <- paste(perc.Overlap$num,' (',perc.Overlap$n.base,')',sep='')

colnames(perc.Overlap.neg) <- c('Comparison','number shared','Percentage','base n',
                                'Shared Genes (N)')
overlap.Neg <- xtable(perc.Overlap.neg[,c(1,5,3)],
                         caption=c('Of the genes with the strongest negative correlations with COMT expression,\n the percentage of genes found in both areas'))

overlap.Neg


@

<<include=FALSE, echo=FALSE, results=tex>>=
# now for the 50 genes with the largest positive correlations in Prefrontal Cortex, find their ranks in the other three areas


#cut.Part <- c(200)
rank.Stab.pos <- matrix(rep(0,4*cut.Part),ncol=4)

# Now do positive correlations
for (h in 1:cut.Part) {
     
     rank.Stab.pos[h,1] <- h
     
     if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumcb)) {
          rank.Stab.pos[h,2] <- which(as.character(hold.Area.dat$illumcb) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.pos[h,2] <-  c(NA)  
          
     }    
     
     if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumtc)) {
          rank.Stab.pos[h,3] <- which(as.character(hold.Area.dat$illumtc) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.pos[h,3] <-  c(NA)  
          
     }
     
    if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumpo)) {
          rank.Stab.pos[h,4] <- which(as.character(hold.Area.dat$illumpo) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.pos[h,4] <-  c(NA)  
          
     }
     
}



colnames(rank.Stab.pos) <- c('rankpf','rankcb','ranktc','rankpo')
rank.Stab.pos <- data.frame(rank.Stab.pos)
rank.Stab.pos$illum <- hold.Area.dat$illumpf[1:cut.Part]
rank.Stab.pos$gene <- hold.Area.dat$genepf[1:cut.Part]
rank.Stab.pos <- rank.Stab.pos[,c(5,6,1:4)]

overlap.Area <- list()

# [[1]] pf vs cb
# [[2]] pf vs tc
# [[3]] pf vs po
# [[4]] cb vs tc
# [[5]] cb vs po
# [[6]] tc vs po

overlap.Area[[1]] <- intersect(rank.Stab.pos$rankpf,rank.Stab.pos$rankcb)
overlap.Area[[2]] <- intersect(rank.Stab.pos$rankpf,rank.Stab.pos$ranktc)
overlap.Area[[3]] <- intersect(rank.Stab.pos$rankpf,rank.Stab.pos$rankpo)
overlap.Area[[4]] <- intersect(rank.Stab.pos$rankcb,rank.Stab.pos$ranktc)
overlap.Area[[5]] <- intersect(rank.Stab.pos$rankcb,rank.Stab.pos$rankpo)
overlap.Area[[6]] <- intersect(rank.Stab.pos$ranktc,rank.Stab.pos$rankpo)


perc.Overlap <- data.frame(compare=(rep(NA,6)),num=c(rep(0,6)),percentage=c(rep(0,6)),
                           n.base=c(rep(0,6)),ofn=c(rep(NA,6)))
perc.Overlap$compare <- c('prefrontal cortex vs. cerebellum',
                         'prefrontal cortex vs. temporal cortex',
                         'prefrontal cortex vs. pons',
                         'cerebellum vs. temporal cortex',
                         'cerebellum vs. pons',
                         'temporal cortex vs. pons')

for (g in 1:6) {
     
    perc.Overlap$n.base[g]  <- cut.Part - length(which(is.na(rank.Stab.pos[,g])))
     perc.Overlap$num[g]  <- length(overlap.Area[[g]]) 
    perc.Overlap$percentage[g]  <- paste(round(100*(perc.Overlap$num[g])/(perc.Overlap$n.base[g]),0),'%',sep='')
}

perc.Overlap.pos <- perc.Overlap
perc.Overlap.pos$ofn <- paste(perc.Overlap$num,' (',perc.Overlap$n.base,')',sep='')

colnames(perc.Overlap.pos) <- c('Comparison','number shared','Percentage','base n',
                                'Shared Genes (N)')
overlap.Pos <- xtable(perc.Overlap.pos[,c(1,5,3)],
                         caption=c('Of the genes with the strongest positive correlations with COMT expression,\n the percentage of genes found in both areas'))

overlap.Pos


@


% {\bfseries {Using the hypergeometric distribution to test for randomness in the number of probes shared in common between the reference area and another area.}}\\
% 
% Testing for probe matches between a reference and a test brain area involves the {\bfseries {hypergeometric}} distribution.\\ The computation of probabilities when sampling without replacement is based on the following pdf:
% 
% \href{http://people.wku.edu/david.neal/109/Unit2/SamplingWO.pdf}{c('MATH 109 Sampling without Replacement)}
% 
% Here is the description of the calculation: \\
% 
% {\bfseries {Sampling Without Regard to Order}}\\
% Now  suppose  we  have  a  population  of N elements  that  are  divided  into  two  types: Type I  which has A elements,  and Type II which has B elements, where $A + B == N$.\\  
% 
% For  example,  a  standard  deck  of  $N == 52$  playing  cards  can  be  divided  in  many  ways. Type  I  could  be  “Hearts”  and  Type  II    could  be  “All  Others.”    Then  there  are   $A == 13$ Hearts and  $B == 39$ Others.\\
% 
% In analogy to the genes/probes problem, $N == 20,000$ probes,  $A == 50$ or 200, as in the top 50 or the top 200 most strongly positively/negatively {\textit {COMT}}-correlated probes. Thus B is either 19,950 ($A == 50 $) or B is 19,800 ( $A == 200$). 
% 
% There are two other parameters: $n == $the number of probes randomnly sampled without replacement, and  $k = $ the number of probes in the sample of size n that also are contained in A. The calculation for the probability that a sample of size n will contain k probes in common with the set in A is:\\
% $$
% p = \frac{\binom{A,k}*\binom{B,(n-k)}}{\binom{N,n}}
% $$


<<include=FALSE, echo=FALSE, results=tex>>=
# Conditional on the 50 probes with expression levels most strongly positively and negatively correlated with COMT expression, find the probability of n of 50 matching

# Sampling without replacement


     num.Probes <- length(unique(hold.Area.dat$illumpf))
     N <- num.Probes
     A <- cut.Part   # number of probes in the reference area that could be matched
     B <- N - A         # number of prtobes not in slected set in reference area
n <- A     # sample of 50 probes
# then k ranges from 0 to A matches

###*** Note ***#####
# The average NUMBER of matches to the top 50 probes expected with a sample of 50 randomly
# selected genes in another area will be n x A/N or 50(50/20000) = 0.125 <- This is not a proportion; it is the expected number of matches - much less than 1 probe should match by chance.

# prob.N will hold the discrete probability distribution for k matches from a sample size either of 50 or 200.

prob.N <- mpfr(matrix(rep(0,(A+1))),precBits=50)
for (k in 1:A) {
     
     prob.N[k+1] <- (chooseMpfr(A,k)*chooseMpfr(B,(n-k)))/chooseMpfr(N,n)
}


prob.N[1] <- 1.0 - sum(prob.N[2:(A+1)])


     prob.N.50 <- data.frame(n.match=seq(0,cut.Part,1),prob=as.numeric(log10(prob.N)))
     write.table(prob.N.50,file='hypergeometric_probability_table_50.csv',sep=', ',row.names=FALSE)



@


<<include=FALSE, echo=FALSE>>=  # , fig=TRUE, pdf=TRUE
# For plotting purposes, the last probability in each frame is 0, so leave that out
# also because it is a discrete distribution, only plot every 5th or 10th point

     
# Using <<- instead of <- allows the variable to used globally
     # Do this when prob.N.200 is first set up in another program
#prob.N.200.plot <- prob.N.200[c(seq(1,200,10)),]
     # Call the hyperplot.R function to plot the hypergeometric distributions
loLim <- c(50)
hiLim <- c(200)
limitseq <- c(0,200,25)

# Using <<- instead of <- allows the variable to used globally
     # Do this when prob.N.200 is first set up in another program

#     p.plot <- hyper.plot(prob.N.50,prob.N.200,loLim,hiLim,limitseq,prog.Name)     



# file.eps <- c('hypergeometric_distributions_50_200.pdf')
#   postscript(file=file.eps,horiz=FALSE,onefile=FALSE,width=8.0,height=5.5,paper='letter')
# 
# p.plot

@

The hypergeometric distributions using the parameters described above are shown in the next figure.\\

%\includegraphics[width=0.5\textwidth]{hypergeometric_matching_genes_diagram.pdf}\\


<<include=FALSE, echo=FALSE, results=tex>>=
############## This needs to be changed to reflect the two prob.N as prob.N.50 and prob.N.200 and the fact that the probabilities are already represented as log10

genes.In.common <- cbind(perc.Overlap.pos[,c(1,5,3)],perc.Overlap.neg[,c(5,3)])



     genes.In.common$logp.valpos <- round(as.numeric(prob.N.50[(perc.Overlap.pos[,2]+1),2]),1)
     genes.In.common$logp.valneg <- round(as.numeric(prob.N.50[(perc.Overlap.neg[,2]+1),2]),1)

     
genes.In.common <- genes.In.common[,c(1:3,6,4,5,7)]

genes.In.common.tab <- xtable(genes.In.common,
                   caption = c(paste("Percentages of the ",cut.Part," Most Strongly Correlated Genes Shared in Common Between Two Brain Areas",sep="")))


genes.In.common.ltx <- latex(genes.In.common.tab,file='',
                   caption = c(paste("Percentages of the ",cut.Part," Most Strongly Correlated Genes Shared in Common Between Two Brain Areas",sep="")),
                     caption.loc = c('top'),
#                     colname = c('Name','URL'),
                     rowlabel = NULL,
                     colnamesTexCmd="bfseries",
                     booktabs=TRUE,
                     label=c('tab:sharedgenes'),
                     na.blank = TRUE,
                     vbar = FALSE,
                     longtable=TRUE,
                     table.env=TRUE,
                     center=c('center'),
                     continued=c('Genes Shared Across Areas Continued'),
                     first.hline.double = TRUE,
                     append=FALSE
                     )
                  
print(genes.In.common.ltx)

write.table(genes.In.common,paste('shared_perc_',cut.Part,'_posneg.csv',sep=', '),row.names = FALSE)

@


<<echo=FALSE, results=tex>>=
################################################
### Select the top 50 by p-value to determine which genes expression levels (by chromosome) are most highly correlated with COMT expression.
### Done separately for positive and negative correlations
### Inversely normalized by fitted number of probes from the regression on chr length, but weighted by proportion of each chromosome in the top 50. 
################################################

##### Positive correlations with COMT expression only #####################
num.Sel <- cut.Part
full.Count <- table(manhat.Posr.pf$CHR)
order.by.P.pos <- manhat.Posr.pf[order(manhat.Posr.pf$P), ]

order.by.P.pos$P <- -log10(order.by.P.pos$P)
colnames(order.by.P.pos)[3] <- c('-log10p')
xtable(order.by.P.pos[1:num.Sel,],caption=c(paste(cut.Part,' Genes with Strongest Positive Correlations with COMT in Prefrontal Cortex',sep='')))

############ End positive only ########################
  
##### Negative correlations with COMT expression only #####################
full.Count <- table(manhat.Negr.pf$CHR)
order.by.P.neg <- manhat.Negr.pf[order(manhat.Negr.pf$P), ]
order.by.P.neg$P <- -log10(order.by.P.neg$P)
colnames(order.by.P.neg)[3] <- c('-log10p')

xtable(order.by.P.neg[1:num.Sel,],caption=c(paste(cut.Part,' Genes with Strongest Negative Correlations with COMT in Prefrontal Cortex',sep='')))

############ End negative only ########################

@

{\bfseries {Gene ontology analysis}}\\

<<echo=FALSE, include=FALSE, results=tex>>=

if (!exists('ensembl')) {
 ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")   
}

normal.chroms <- c(1:22, "X", "Y", "M")

if (!exists('ah')) {
 ah <- AnnotationHub()   
}

if (!exists('orgs')) {
 orgs <- AnnotationHub::query(ah, "org.Hs.eg.db")   
}

if (!exists('gene.DB')) {
 gene.DB <- orgs[["AH57973"]]   
}

# columns(gene.DB)
# keytypes(gene.DB)




# input entrez ID output gene symbol
# temp.Gene <- c('COMT',   'PHGDH',  'DDR1',   'SCAMP2', 'ZFAND3', 'NECAP2', 'HDAC1',  'FTL', 'TST',    'CRYL1')
# 

topplusr.Data$GENE <- gsub(" ", "", topplusr.Data$GENE)

   fifty_comt_plus <- na.omit(biomaRt::select(gene.DB,keys=as.character(topplusr.Data$GENE[2:51]),columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL')))

write.table(fifty_comt_plus,file='fifty_comt_plus_corr.csv',sep=', ',quote=FALSE)


fifty_comt_minus <- na.omit(biomaRt::select(gene.DB,keys=as.character(topminusr.Data$GENE[2:51]),columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL')))

write.table(fifty_comt_minus,file='fifty_comt_minus_corr.csv',sep=', ',quote=FALSE)


     

     top50.Pos <- biomaRt::select(gene.DB,keys=order.by.P.pos$GENE[1:num.Sel],columns=c('GENENAME','SYMBOL','ENTREZID'),keytype=c('SYMBOL'))
     
          top.Pos <- top50.Pos
          
     top50.Neg <- biomaRt::select(gene.DB,keys=order.by.P.neg$GENE[1:num.Sel],columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL'))
     
          top.Neg <- top50.Neg
fifty_comt_minus <- na.omit(biomaRt::select(gene.DB,keys=as.character(prefront.Meanbothr$gene[19951:20000]),columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL')))

write.table(fifty_comt_minus,file='fifty_comt_minus_corr.csv',sep=', ',quote=FALSE)

pos.Tab <- xtable(top.Pos,caption=c(paste('Top ',cut.Part,' Positively Correlated Genes with COMT in Prefrontal Cortex',sep='')))

pos.Tab

neg.Tab <- xtable(top.Neg,caption=c(paste('Top ',cut.Part,' Negatively Correlated Genes with COMT in Prefrontal Cortex',sep='')))

neg.Tab

@

<<include=FALSE, echo=FALSE, results=tex>>=
# Ontology

#org.Hs.egGO is an R object that provides
#mappings between entrez gene identifers and the GO
#identifers that they are directly associated with
entrez_object <- org.Hs.egGO    # 

# Get the entrez gene identifiers that are mapped to a GO ID
#mapped_genes <- mappedkeys(entrez_object)

# Instead, use the actual Illumina probes converted to ENTREZIDs in the data set
# Get the ENTREZ ID for all of the probes in the original data
universe.Probes <- data.frame(ENTREZID=na.omit(unlist(mget(x = prefront.Data$Record,envir=illuminaHumanv2ENTREZID))))

universe.Probes$ENTREZID <- as.character(universe.Probes$ENTREZID)

# universe.Probes$ENTREZID now holds all of the ENTREZIDs for all of the ILMN probes

# Convert to a list
#entrez_to_go <- as.list(entrez_object[mapped_genes])
entrez_to_go <- as.list(entrez_object[universe.Probes$ENTREZID])


#map GO terms to Entrez gene ids
go_object <- as.list(org.Hs.egGO2EG)


# axon_gene <- go_object['GO:0007411']
# length(unlist(axon_gene, use.names=F))
# 
# axon_gene <- unique(unlist(axon_gene, use.names=F))
# head(axon_gene)

my_genes_plus <- unique(fifty_comt_plus$ENTREZID)
my_genes_minus <- unique(fifty_comt_minus$ENTREZID)
#universe <- mapped_genes
universe <- universe.Probes$ENTREZID
length(universe)

params <- new('GOHyperGParams',
              geneIds=my_genes_plus,
              universeGeneIds=universe,
              ontology='BP',
              pvalueCutoff=0.001,
              conditional=F,
              testDirection='over',
              annotation="org.Hs.eg.db"
             )
hgOver.plus <- hyperGTest(params)
ontology.results.50Plus <- summary(hgOver.plus)

ontology.50.plusA <- xtable(ontology.results.50Plus[,1:6],
                            caption='Ontology analysis results with top 50 positive correlations (p less than .001)')

ontology.50.plusB <- xtable(data.frame(ontology.results.50Plus[,7]),
                            caption='Ontology analysis significantly enriched GO terms with top 50 positive correlations (p less than .001)')

# results_GO <- go_object[results$GOBPID]
# go_object['GO:0051589']


params <- new('GOHyperGParams',
              geneIds=my_genes_minus,
              universeGeneIds=universe,
              ontology='BP',
              pvalueCutoff=0.001,
              conditional=F,
              testDirection='over',
              annotation="org.Hs.eg.db"
             )
hgOver.minus <- hyperGTest(params)
ontology.results.50Minus <- summary(hgOver.minus)

ontology.50.minusA <- xtable(ontology.results.50Minus[,1:6],
                            caption='Ontology analysis results with top 50 positive correlations (p less than .001)')

ontology.50.minusB <- xtable(data.frame(ontology.results.50Minus[,7]),
                            caption='Ontology analysis significantly enriched GO terms with top 50 positive correlations (p less than .001)')


# results_GO <- go_object[results$GOBPID]
# intersect(my_genes_plus$ENTREZID,unlist(results_GO[[1]]))


@





{\bfseries {Mutual rank:}} co-expression Pearson correlation coefficient RANK with gene A as target and gene B as co-expressed, and vice versa. The two ranks are then geometrically averaged. Smaller MR scores mean stronger co-expression.\\

<<echo=FALSE, include=FALSE, results=tex>>=
print(xtable(coexpress.URL[1,],caption=c('The next co-expression analysis used the database at this URL to find the top 500 genes coexpressed with COMT. That list was then checked against the top 50 genes (+ and - separately) from the comt-prefrontal data to find agreement between the two lists.')))


### read the COMT coexpression data file 
hold.Matchpos <- matrix(c(rep(NA,cut.Part)),ncol=1)
hold.Matchneg <- matrix(c(rep(NA,cut.Part)),ncol=1)
hold.Chrompos <- matrix(c(rep(NA,cut.Part)),ncol=1)
hold.Chromneg <- matrix(c(rep(NA,cut.Part)),ncol=1)

wbhsa <- loadWorkbook('comt_coex_list_500_hsa.xlsx')
# wbhsa2 <- loadWorkbook('comt_coex_list_500_hsa2.xlsx')
# wbhsa3 <- loadWorkbook('comt_coex_list_500_hsa3.xlsx')

coexpress.Data <- data.frame(read.xlsx(wbhsa,         # now tell R to read that workbook and which sheet
                                  sheet = "coex500"))


coexpress.Data$Entrez.Gene.ID <- as.character(coexpress.Data$Entrez.Gene.ID)

for (ma in 1:num.Sel) {

  if (isTRUE(which(coexpress.Data$Entrez.Gene.ID == as.character(top.Pos$ENTREZID[ma])) != 0)) {
    hold.Matchpos[ma] <- coexpress.Data$Gene[which(coexpress.Data$Entrez.Gene.ID == as.character(top.Pos$ENTREZID[ma]))]
  } else {
    
  }
     
  
  if (isTRUE(which(coexpress.Data$Entrez.Gene.ID == as.character(top.Neg$ENTREZID[ma])) != 0)) {
    hold.Matchneg[ma] <- coexpress.Data$Gene[which(coexpress.Data$Entrez.Gene.ID == as.character(top.Neg$ENTREZID[ma]))]
  } else {
    
  } 
}


pos.Matches <- na.omit(hold.Matchpos)

neg.Matches <- na.omit(hold.Matchneg)

if (length(pos.Matches) > 0) {
my.symbols <- pos.Matches
my.regions <- getBM(c("hgnc_symbol", "chromosome_name", "start_position", "end_position", "band"),
                    filters = c("hgnc_symbol", "chromosome_name"),
                    values = list(hgnc_symbol=my.symbols, chromosome_name=normal.chroms),
                    mart = ensembl)
my.regions$chromosome_name

posmatch.DF <- data.frame(geneSymbol=pos.Matches,chromosome=my.regions$chromosome_name)


} else {posmatch.DF <- data.frame(geneSymbol=NA,chromosome=NA)
}

xtable(posmatch.DF,caption=c(paste('Genes matching the top ',cut.Part,' positively COMT - correlated genes in Prefrontal',sep='')))


if (length(neg.Matches) > 0) {
my.symbols <- neg.Matches
my.regions <- getBM(c("hgnc_symbol", "chromosome_name", "start_position", "end_position", "band"),
                    filters = c("hgnc_symbol", "chromosome_name"),
                    values = list(hgnc_symbol=my.symbols, chromosome_name=normal.chroms),
                    mart = ensembl)
my.regions$chromosome_name

negmatch.DF <- data.frame(geneSymbol=neg.Matches,chromosome=my.regions$chromosome_name)


} else {negmatch.DF <- data.frame(geneSymbol=NA,chromosome=NA)
}

xtable(negmatch.DF,caption=paste('Genes matching the top ',cut.Part,' negatively COMT - correlated genes in Prefrontal',sep=''))

@

% Genes from \Sexpr{print(coexpress.URL[1,])} that overlap with the 10 most highly positively correlated genes with COMT in Prefrontal Cortex:\\
% \Sexpr{pos.Matches[1:length(pos.Matches)]}\\
% 
% (Note: this database most likely only shows positively correlated coexpression genes.)\\
% Genes from \Sexpr{print(coexpress.URL[1,])} that overlap with the 10 most highly negatively correlated genes with COMT in Prefrontal Cortex:\\
% \Sexpr{neg.Matches[1:length(neg.Matches)]}\\


\end{document}


 
