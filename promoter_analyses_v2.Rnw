% NEW based on MB-COMT data

\documentclass[11pt]{article}
\usepackage{graphicx, subfig}
\usepackage{float}
\pagenumbering{arabic}
\usepackage{enumerate}
\usepackage{Sweave}
\usepackage{booktabs}
\usepackage[table]{xcolor}
\usepackage{framed}
\usepackage{longtable}
\usepackage{tablefootnote}
\usepackage{amsmath}
\usepackage{hyperref}
\graphicspath{/Volumes/Macintosh_HD_3/genetics/genenetwork2/new_plots/}


\begin{document}
\SweaveOpts{concordance=TRUE}
\SweaveOpts{keep.source=TRUE} 

\hspace{-1.5em}Gene Network\\
COMT expression correlations in Four Brain Areas\\
Fall, 2017\\


<<echo=FALSE>>=
### chunk.Status determines whether the c ode in a particular chunk shpul;d be executed or not.
### It mostly applies to chunks generating tables and figures that have alreacdy been generated.

chunk.Status <- FALSE

library(SOAR)
library(ggplot2,ggthemes)
library(ggExtra)
library(psych)
library(knitr)
library(Hmisc)
library(openxlsx)
#library(xlsx)
library(xtable)
library(magrittr)
library(tables)
library(plyr)
library(rlist)
# library(qqman)
# library(manhattanly)
library(Cairo)
library(RColorBrewer)
library(HGNChelper)
library(tools)
library(scales)
library(devtools)
library(utils)
# library(ggman)
library(dplyr)
library(biomaRt)
library(combinat)
library(Rmpfr)
library(stats)
library(stringr)
library(mvtnorm)
library(miscFuncs)
library(reporttools)
library(glm2)
library(reshape2)
library(plotly)
library(gmp)
library(R.utils)
library(curl)
library(igraph)
library(data.tree)
library(gmodels)
library(digest)
library(seqinr)
library(tidyverse)
library(HDMD)
library(seqLogo)
library(PropCIs)
library(data.table)
library(GlobalOptions)
library(arrayhelpers)
library(ggseqlogo)
library(vcd)
library(matrixStats)
library(rJava)
library(corrplot)
library(survC1)
library(ontologyIndex)
library(ontologyPlot)



### to prepend filename strings to plots
#pre.Name <- c('comt_expression-') #pre-ppended to eps output files

setwd('/Volumes/Macintosh_HD_3/genetics/genenetwork2/')

# new plots directory

new_plots <- '/Volumes/Macintosh_HD_3/genetics/genenetwork2/new_plots/'

# RColorBrewer palette
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

options(scipen = 999, digits = 5, width = 60, knitr.table.format = "latex")
opts_chunk$set(include=FALSE,
               echo=FALSE,
               message=FALSE,
               warning=FALSE)

area.abbrv <- c('pf',
     'cb',
     'tm',
     'po'
)
################ READ THIS LIST OF TO-BE SOURCED FUNCTIONS AND PROGRAMS IN #################

fileConn<-file('sourced_functions_programs.txt')
     sourced.Funcs <- 
          data.frame(rfunc=readLines(con=fileConn),stringsAsFactors = FALSE)

     temp.Funcs <- str_replace(sourced.Funcs$rfunc,',','.R')
          sourced.Funcs <- data.frame(rfunc=as.character(temp.Funcs),stringsAsFactors = FALSE)
     temp2.Funcs <- paste(work.path,sourced.Funcs$rfunc,sep='') 
          sourced.Funcs <- data.frame(rfunc=as.character(temp2.Funcs),stringsAsFactors = FALSE)
close(fileConn)

source(sourced.Funcs$rfunc[1:length(sourced.Funcs)])
#############################################################################################

# Read in the mapping between Chromosome names ordered by text (e.g., 1, 10, 11, 12...2, 20...) and ordered by number (e.g., 1, 2, 3, 4 ..., 22, X, Y)

wbchr <- loadWorkbook('order_Chr_by_num.xlsx')   

# now tell R to read that workbook and which sheet
  order.Chr.by.num <- data.frame(read.xlsx(wbchr,sheet = "chr_map"))


stand.Col.names <- c('Prefrontal',
                     'Cerebellum',
                     'Temporal',
                     'Pons')
stand.Col.names.aug <- c(paste(stand.Col.names[1],' Cortex',sep=''),
                         paste(stand.Col.names[2],'',sep=''),
                         paste(stand.Col.names[3],' Cortex',sep=''),
                         paste(stand.Col.names[4],'',sep=''))

gold.R <- c(1.61803398875)
@




<<include=FALSE, echo=FALSE, results=hide>>=
# Generate a unique ID for this program by path and filename. This unique ID is attached to this file using a tag in the filesystem.
fname <- csf()   # function to get current path including file name

          prog.Name <- unique.ID(fname)

          prog.Name   # unique ID based on hash of file name

# Write out the file_name, unique ID and date/time to '.Rscriptnames'

          rec.script(eval(fname),eval(prog.Name))
@

This program has the unique ID: \Sexpr{prog.Name}.

<<include=FALSE,echo=FALSE,results=hide>>=

# myBioCLite() # This function updates only the packages that need to be updated
source("https://bioconductor.org/biocLite.R")
          
biocLite('enrichR')
library('enrichR')
dbs.Enrichr <- listEnrichrDbs()
          
biocLite('topGO')
library('topGO')

biocLite('AnnotationHub')
library('AnnotationHub')

biocLite('GOsummaries')
library('GOsummaries')

biocLite('clusterProfiler')
library('clusterProfiler')


  biocLite(c("GenomicFeatures"))
  biocLite(c("AnnotationDbi"))
  biocLite(c("org.Hs.eg.db"))

library("AnnotationHub")
library("GenomicFeatures")
library("org.Hs.eg.db")

biocLite(c('hgu95av2.db'))
library('hgu95av2.db')

source("https://bioconductor.org/workflows.R")

 workflowInstall("annotation")

 biocLite("TxDb.Hsapiens.UCSC.hg19.knownGene")
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene #shorthand (for convenience) 

library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(BSgenome.Hsapiens.UCSC.hg19)


biocLite("GO.db")
biocLite("topGO")
biocLite("GOstats")

     
library("GO.db")
library("topGO")
library("GOstats")

biocLite('annotate')
library('annotate')

biocLite('motifRG','MotifDb')
library('motifRG')
library('MotifDb')

biocLite('PWMEnrich')
library('PWMEnrich')
biocLite('PWMEnrich.Hsapiens.background')
library('PWMEnrich.Hsapiens.background')

biocLite('RcisTarget')
library('RcisTarget')

biocLite("RDAVIDWebService")
library("RDAVIDWebService")

biocLite('GOSemSim')
library('GOSemSim')

biocLite('RamiGO')
library('RamiGO')
@



{\textit {COMT}} catalyzes degradation of catecholamines including dopamine, norepinephrine and epinephrine.\\ 
<<echo=FALSE, include=FALSE, results=tex>>=
coexpress.URL <- data.frame(site=NA,addr=NA)
coexpress.URL[1,1:2] <- c('COXPRESdb','http://coxpresdb.jp/')
coexpress.URL[2,1:2] <- c('OMICtools','https://omictools.com/')
coexpress.URL[3,1:2] <- c('Coexpedia','http://www.coexpedia.org/search.php')
coexpress.URL[4,1:2] <- c('GeneFriends','http://www.genefriends.org/RNAseq/')
coexpress.URL[5,1:2] <- c('Illumina Probes','http://www.genomequebec.mcgill.ca/compgen/integratedvervetgenomics/transcriptome/Illumina/allprobes.html')
coexpress.URL[6,1:2] <- c('Gibbs Expression Data','https://www.ncbi.nlm.nih.gov/geo/query')
coexpress.URL[7,1:2] <- c('Train Online','https://www.ebi.ac.uk/training/online/course/arrayexpressdiscoverfunctionalgenomicsdataqui/references')
coexpress.URL[8,1:2] <- c('Enrichr','http://amp.pharm.mssm.edu/Enrichr/enrich')

url.Tab <- xtable(coexpress.URL)
url.Table <- latex(url.Tab,file='',
                   caption = c("Gene Coexpression Databases"),
                   caption.loc = c('top'),
                     colname = c('Name','URL'),
                     rowlabel = c(''),
                     colnamesTexCmd="bfseries",
                     booktabs=TRUE,
                     label=c('tabcoexpressurls'),
                     na.blank = TRUE,
                     vbar = FALSE,
                     longtable=TRUE,
                     table.env=TRUE,
                     center=c('center'),
                     continued=c('Gene Coexpression Databases Continued'),
                     first.hline.double = TRUE,
                     append=FALSE
                     )

@


\Sexpr{url.Table}




<<echo=FALSE, results=tex>>=
entrez_object <- org.Hs.egGO    

ensembl <- useMart("ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl")
#ensembl = useEnsembl(biomart="ensembl",dataset = "hsapiens_gene_ensembl")

normal.chroms <- c(1:22, "X", "Y", "M")

 ah <- AnnotationHub()

 orgs <- AnnotationHub::query(ah, "org.Hs.eg.db")


# columns(gene.DB)
# keytypes(gene.DB)

@



<<echo=FALSE,include=FALSE,results=hide>>=
### read the data file 

fname <- c('comt_correlations_20000_all_areas_augmentedNew.xlsx')

if (file.exists(fname))   {
     wball <- loadWorkbook(fname)   

# now tell R to read that workbook and which sheet
  prefront.Data <- data.frame(read.xlsx(wball,sheet = "prefrontal"))
  
  cbell.Data <- data.frame(read.xlsx(wball,sheet = "cerebellum"))

  tempor.Data <- data.frame(read.xlsx(wball,sheet = "temporal"))

  pons.Data <- data.frame(read.xlsx(wball,sheet = "pons"))
  
   Store(prefront.Data,
        cbell.Data,
        tempor.Data,
        pons.Data)


# create a list with these data frames to be used when the same operation is applied to all area
  
major.Area <- list(pf=prefront.Data,
                   cb=cbell.Data,
                   tm=tempor.Data,
                   po=pons.Data)

} else {
     print(paste('The data file ',fname,' does not exist',sep=''))
}

################# Top 500 by area strongly COMT correlated genes (pval ranked) #################
### read the data file 
 
 
fname <- c('top_500_pval_ranked.xlsx')

if (file.exists(fname))   {
     wbtop <- loadWorkbook(fname) 

  # now tell R to read that workbook and which sheet
  top500.prefront.Data <- data.frame(read.xlsx(wbtop,sheet = "prefrontal"))
  
  top500.cbell.Data <- data.frame(read.xlsx(wbtop,sheet = "cerebellum"))

  top500.tempor.Data <- data.frame(read.xlsx(wbtop,sheet = "temporal"))

  top500.pons.Data <- data.frame(read.xlsx(wbtop,sheet = "pons"))
  
   Store(top500.prefront.Data,
        top500.cbell.Data,
        top500.tempor.Data,
        top500.pons.Data)

# create a list with these data frames to be used when the same operation is applied to all area
  
hold.Lowest.pvals <- list(pf=top500.prefront.Data,
                         cb=top500.cbell.Data,
                         tm=top500.tempor.Data,
                         po=top500.pons.Data)

hold.Lowest.pvals.pos <- list(pf=top500.prefront.Data[top500.prefront.Data$corsign == 1,],
                              cb=top500.cbell.Data[top500.cbell.Data$corsign == 1,],
                              tm=top500.tempor.Data[top500.tempor.Data$corsign == 1,],
                              po=top500.pons.Data[top500.pons.Data$corsign == 1,])

hold.Lowest.pvals.neg <- list(pf=top500.prefront.Data[top500.prefront.Data$corsign == -1,],
                              cb=top500.cbell.Data[top500.cbell.Data$corsign == -1,],
                              tm=top500.tempor.Data[top500.tempor.Data$corsign == -1,],
                              po=top500.pons.Data[top500.pons.Data$corsign == -1,])

hold.Lowest.pvals.sign <- list(pos=hold.Lowest.pvals.pos,
                               neg=hold.Lowest.pvals.neg)
} else {
     print(paste('The data file ',fname,' does not exist',sep=''))
}
                              
     

################################################################################################

################# Unique by area strongly COMT correlated genes ######################

 fname <- c('unique_genes_full_data.xlsx')

if (file.exists(fname))   {
     wbuniq <- loadWorkbook(fname) 

# now tell R to read that workbook and which sheet
  unique.prefront.Data <- data.frame(read.xlsx(wbuniq,sheet = "prefrontal"))
  
  unique.cbell.Data <- data.frame(read.xlsx(wbuniq,sheet = "cerebellum"))

  unique.tempor.Data <- data.frame(read.xlsx(wbuniq,sheet = "temporal"))

  unique.pons.Data <- data.frame(read.xlsx(wbuniq,sheet = "pons"))
  
  Store(unique.prefront.Data,
        unique.cbell.Data,
        unique.tempor.Data,
        unique.pons.Data)


# create a list with these data frames to be used when the same operation is applied to all area
  
unique.full.data.all <- list(pf=unique.prefront.Data,
                   cb=unique.cbell.Data,
                   tm=unique.tempor.Data,
                   po=unique.pons.Data)
} else {
     print(paste('The data file ',fname,' does not exist',sep=''))
}


# read in data that has only one probe per gene
 
 fname <- c('gene_as_unit_data.xlsx')

if (file.exists(fname))   {
     wbgene <- loadWorkbook(fname)  

# now tell R to read that workbook and which sheet
  gene.prefront.Data <- data.frame(read.xlsx(wbgene,sheet = "prefrontal"))
  
  gene.cbell.Data <- data.frame(read.xlsx(wbgene,sheet = "cerebellum"))

  gene.tempor.Data <- data.frame(read.xlsx(wbgene,sheet = "temporal"))

  gene.pons.Data <- data.frame(read.xlsx(wbgene,sheet = "pons"))
  
  # reorder data in each area by pval
  
  gene.prefront.Data <- gene.prefront.Data[order(gene.prefront.Data$Sample.p.r.,decreasing=FALSE), ]
  gene.cbell.Data <- gene.cbell.Data[order(gene.cbell.Data$Sample.p.r.,decreasing=FALSE), ]
  gene.tempor.Data <- gene.tempor.Data[order(gene.tempor.Data$Sample.p.r.,decreasing=FALSE), ]
  gene.pons.Data <- gene.pons.Data[order(gene.pons.Data$Sample.p.r.,decreasing=FALSE), ]
  
  Store(gene.prefront.Data,
        gene.cbell.Data,
        gene.tempor.Data,
        gene.pons.Data)


# create a list with these data frames to be used when the same operation is applied to all area
  
gene.Major <- list(pf=gene.prefront.Data,
                   cb=gene.cbell.Data,
                   tm=gene.tempor.Data,
                   po=gene.pons.Data)
} else {
     print(paste('The data file ',fname,' does not exist',sep=''))
}

################# END Already processed data ####################### 

### Read in putative transcription factors based on motifRG analysis of positively vs. negatively correlated genes in Prefrontal Cortex

fname <- c('tfs_pf_motifRG.xlsx')

if (file.exists(fname))   {
     wbtf <- loadWorkbook(fname) 
  
# now tell R to read that workbook and which sheet
  tfs.PvN.pf <- data.frame(read.xlsx(wbtf,sheet = "hs_only"))

  } else {
     print(paste('The data file ',fname,' does not exist',sep=''))
}

@  

<<gene.databases>>=
yy <- hgu95av2CHRLENGTHS
chrom.Data <- data.frame(chrom=chrom.Names,
                         chrom.Length=yy[chrom.Names]
)


@


<<include=FALSE, echo=FALSE, results=tex >>=

#  read.fasta
seq.fasta <- list()
seq.pos.fasta <- list()
seq.neg.fasta <- list()



for (im in ib)   {

seq.fasta[[im]] <- readDNAStringSet(paste('fasta_500_promoter_seq_',area.abbrv[im],
                                         '_final.fa',sep=''), format="fasta",
               nrec=-1L, skip=0L, seek.first.rec=FALSE, use.names=TRUE)

seq.pos.fasta[[im]] <- readDNAStringSet(paste('fasta_500_promoter_seq_',area.abbrv[im],
                                         '_pos.fa',sep=''), format="fasta",
               nrec=-1L, skip=0L, seek.first.rec=FALSE, use.names=TRUE)


seq.neg.fasta[[im]] <- readDNAStringSet(paste('fasta_500_promoter_seq_',area.abbrv[im],
                                         '_neg.fa',sep=''), format="fasta",
               nrec=-1L, skip=0L, seek.first.rec=FALSE, use.names=TRUE)

# seq.neg.fasta.entrez[[im]] <- read.fasta(file=paste('fasta_500_promoter_seq_',area.abbrv[im],
#                                          '_neg.fa',sep=''),seqtype='DNA',
#                             forceDNAtolower=FALSE,seqonly=FALSE,strip.desc=FALSE,
#                             as.string=TRUE)
}

@

proms.all<- seq.fasta
proms.pos <- seq.pos.fasta
proms.neg <- seq.neg.fasta


<<write.fasta.nolinefeeds>>=

# write out promoter sequences in fasta format with no line breaks

# for (im in ib)     {
# 
# 
# writeXStringSet(seq.fasta[[im]], 
#                 paste("fasta_500_promoter_seq_",
#                       area.abbrv[im],"_final.fa",sep=''), append=FALSE,
#                 compress=FALSE, compression_level=NA, format="fasta",width=2000)
# 
# writeXStringSet(seq.pos.fasta[[im]], paste("fasta_500_promoter_seq_",
#                       area.abbrv[im],"_pos.fa",sep=''), append=FALSE,
#                 compress=FALSE, compression_level=NA, format="fasta",width=2000)
# 
# writeXStringSet(seq.neg.fasta[[im]], paste("fasta_500_promoter_seq_",
#                       area.abbrv[im],"_neg.fa",sep=''), append=FALSE,
#                 compress=FALSE, compression_level=NA, format="fasta",width=2000)
#      
# }

@

<<>>=

fasta.by.lett <- list(pf=matrix(rep(NA,nchar(seq.fasta[[1]][1])*length(seq.fasta[[1]])),ncol=nchar(seq.fasta[[1]][1])),
                      cb=matrix(rep(NA,nchar(seq.fasta[[2]][1])*length(seq.fasta[[2]])),ncol=nchar(seq.fasta[[2]][1])),
                      tm=matrix(rep(NA,nchar(seq.fasta[[3]][1])*length(seq.fasta[[3]])),ncol=nchar(seq.fasta[[3]][1])),
                      po=matrix(rep(NA,nchar(seq.fasta[[4]][1])*length(seq.fasta[[4]])),ncol=nchar(seq.fasta[[4]][1]))
)

sseqa <- c(-40,10)
sseq1 <- c(sseqa[1]:sseqa[2])
sseq2 <- sseq1 + (-sseq1[1] + 1)
sseq <-   1000 + sseq1
locr <- 1000 + sseqa
locrange <- c(locr[1]:locr[2])
#### All COMT genes
subseq <- locrange     ######### <<<<< Note
fasta.by.lett_all.genes <- list(pf=matrix(rep(NA,length(subseq)*length(proms.all[[1]])),ncol=length(subseq)),
                      cb=matrix(rep(NA,length(subseq)*length(proms.all[[2]])),ncol=length(subseq)),
                      tm=matrix(rep(NA,length(subseq)*length(proms.all[[3]])),ncol=length(subseq)),
                      po=matrix(rep(NA,length(subseq)*length(proms.all[[4]])),ncol=length(subseq))
)


for (im in ib)    {
     
# For the all genes set only split from -40 to +10 (960 to 1010)     
     for (gh in 1:length(proms.all[[im]]))   {
          
          cat(paste('area: ',im,', genes: ',gh,' \n',sep=''))
     
          fasta.by.lett_all.genes[[im]][gh] <- strsplit(substring(as.character(proms.all[[im]][gh]),locr[1],locr[2]),NULL)
          
     }
     
}


#### Positive by letter
subseq <- locrange
fasta.by.lett.pos <- list(pf=matrix(rep(NA,length(subseq)*length(proms.pos[[1]])),ncol=length(subseq)),
                      cb=matrix(rep(NA,length(subseq)*length(proms.pos[[2]])),ncol=length(subseq)),
                      tm=matrix(rep(NA,length(subseq)*length(proms.pos[[3]])),ncol=length(subseq)),
                      po=matrix(rep(NA,length(subseq)*length(proms.pos[[4]])),ncol=length(subseq))
)


for (im in ib)    {
     
# For positively COMT-correlated genes set only split from -40 to +10 (960 to 1010)     
     for (gh in 1:length(proms.pos[[im]]))   {
          
          cat(paste('area: ',im,', genes: ',gh,' \n',sep=''))
     
          fasta.by.lett.pos[[im]][gh] <- strsplit(substring(as.character(proms.pos[[im]][gh]),locr[1],locr[2]),NULL)
          
     }
     
}

#### Negative by letter
subseq <- locrange
fasta.by.lett.neg <- list(pf=matrix(rep(NA,length(subseq)*length(proms.neg[[1]])),ncol=length(subseq)),
                      cb=matrix(rep(NA,length(subseq)*length(proms.neg[[2]])),ncol=length(subseq)),
                      tm=matrix(rep(NA,length(subseq)*length(proms.neg[[3]])),ncol=length(subseq)),
                      po=matrix(rep(NA,length(subseq)*length(proms.neg[[4]])),ncol=length(subseq))
)


for (im in ib)    {
     

# For negatively COMT-correlated genes set only split from -40 to +10 (960 to 1010)     
     for (gh in 1:length(proms.neg[[im]]))   {
          
          cat(paste('area: ',im,', genes: ',gh,' \n',sep=''))
     
          fasta.by.lett.neg[[im]][gh] <- strsplit(substring(as.character(proms.neg[[im]][gh]),locr[1],locr[2]),NULL)
          
     }
     
}


############## positive tally for pwm ##########
pos_genes.lett.freq <- list()
colnames(pos_genes.lett.freq) <- DNA_BASES
lc <- length(subseq)

for (im in ib)    {
     
     lett.tab <- matrix(rep(NA,4*length(seq.pos.fasta[[im]])),ncol=4)
     temp.lett.by.locs <- matrix(rep(NA,length(subseq)*length(seq.pos.fasta[[im]])),
                                 ncol=length(subseq))
     
     for (lc in subseq)    {
          
          for (ng in 1:length(seq.pos.fasta[[im]])) {
          
               temp.lett.by.locs[ng,] <- unlist(fasta.by.lett.pos[[im]][ng])
               
               hold.N <- c()
               
                    hold.N <- which(temp.lett.by.locs[ng,] == 'N')
                    
                    if (length(hold.N) > 0)  {
                         
                         temp.lett.by.locs[ng,c(hold.N)] <- NA
                         
                    }  else {
                         
                    }
                         
          } 
          
          lett.tab[(lc - (subseq[1] - 1)),] <- table(temp.lett.by.locs[,(lc - (subseq[1] - 1))])
     }
          
          pos_genes.lett.freq[[im]] <- t(lett.tab[1:length(subseq),])/length(seq.pos.fasta[[im]])
          
          colnames(pos_genes.lett.freq[[im]]) <- c(paste('locus_',(-40:10),sep=''))

}  # end area loop         

pwm_pos_comt_genes <- list()
pwm_pos_comt_genes_ATvCG <- list()

for (im in ib)   {
                    
          write.table(pos_genes.lett.freq[[im]], file = paste('pos_genes_PWM_minus40_plus10_',stand.Col.names[im],'.csv',sep=''))

pwm_pos_comt_genes[[im]] <- as.data.frame(t(pos_genes.lett.freq[[im]]))
colnames(pwm_pos_comt_genes[[im]]) <- DNA_BASES
          pwm_pos_comt_genes[[im]]$site <- c(-40:10)
          
pwm_pos_comt_genes_ATvCG[[im]]   <- data.frame(site=pwm_pos_comt_genes[[im]][,5],
                              AT=(pwm_pos_comt_genes[[im]][,1] + pwm_pos_comt_genes[[im]][,4]),
                              CG=(pwm_pos_comt_genes[[im]][,2] + pwm_pos_comt_genes[[im]][,3]))
          
}

############## negative ##########
neg_genes.lett.freq <- list()
colnames(neg_genes.lett.freq) <- DNA_BASES
lc <- length(subseq)

for (im in ib)    {
     
     lett.tab <- matrix(rep(NA,4*length(seq.neg.fasta[[im]])),ncol=4)
     temp.lett.by.locs <- matrix(rep(NA,length(subseq)*length(seq.neg.fasta[[im]])),
                                 ncol=length(subseq))
     
     for (lc in subseq)    {
          
          for (ng in 1:length(seq.neg.fasta[[im]])) {
          
               temp.lett.by.locs[ng,] <- unlist(fasta.by.lett.neg[[im]][ng])
               
               hold.N <- c()
               
                    hold.N <- which(temp.lett.by.locs[ng,] == 'N')
                    
                    if (length(hold.N) > 0)  {
                         
                         temp.lett.by.locs[ng,c(hold.N)] <- NA
                         
                    }  else {
                         
                    }
                         
          } 
          
          lett.tab[(lc - (subseq[1] - 1)),] <- table(temp.lett.by.locs[,(lc - (subseq[1] - 1))])
     }
          
          neg_genes.lett.freq[[im]] <- t(lett.tab[1:length(subseq),])/length(seq.neg.fasta[[im]])
          
          colnames(neg_genes.lett.freq[[im]]) <- c(paste('locus_',(-40:10),sep=''))

} #end area loop


pwm_neg_comt_genes <- list()
pwm_neg_comt_genes_ATvCG <- list()

for (im in ib)    {                
          write.table(neg_genes.lett.freq[[im]], file = paste('neg_genes_PWM_minus40_plus10_',stand.Col.names[im],'.csv',sep=''))

pwm_neg_comt_genes[[im]] <- as.data.frame(t(neg_genes.lett.freq[[im]]))
colnames(pwm_neg_comt_genes[[im]]) <- DNA_BASES
          pwm_neg_comt_genes[[im]]$site <- c(-40:10)
          
pwm_neg_comt_genes_ATvCG[[im]]   <- data.frame(site=pwm_neg_comt_genes[[im]][,5],
                              AT=(pwm_neg_comt_genes[[im]][,1] + pwm_neg_comt_genes[[im]][,4]),
                              CG=(pwm_neg_comt_genes[[im]][,2] + pwm_neg_comt_genes[[im]][,3]))
          
}          


#### All genes  (~16,000) over range from -40 to + 10 TSS
all_genes.lett.freq <- list()
colnames(all_genes.lett.freq) <- DNA_BASES
lc <- length(subseq)

for (im in ib)    {
     
     lett.tab <- matrix(rep(NA,4*length(proms.all[[im]])),ncol=4)
     temp.lett.by.locs <- matrix(rep(NA,length(subseq)*length(proms.all[[im]])),
                                 ncol=length(subseq))
     
     for (lc in subseq)    {
          
          for (ng in 1:length(proms.all[[im]])) {
          
               temp.lett.by.locs[ng,] <- unlist(fasta.by.lett_all.genes[[im]][ng])
               
               hold.N <- c()
               
                    hold.N <- which(temp.lett.by.locs[ng,] == 'N')
                    
                    if (length(hold.N) > 0)  {
                         
                         temp.lett.by.locs[ng,c(hold.N)] <- NA
                         
                    }  else {
                         
                    }
                         
          } 
          
          lett.tab[(lc - (subseq[1] - 1)),] <- table(temp.lett.by.locs[,(lc - (subseq[1] - 1))])
     }
          
          all_genes.lett.freq[[im]] <- t(lett.tab[1:length(subseq),])/length(proms.all[[im]])
          
          colnames(all_genes.lett.freq[[im]]) <- c(paste('locus_',(-40:10),sep=''))
 
} #end area loop

pwm_all_comt_genes <- list()
pwm_all_comt_genes_ATvCG <- list()

for (im in ib)              {     
          write.table(all_genes.lett.freq[[im]], file = paste('all_genes_PWM_minus40_plus10_',stand.Col.names[im],'.csv',sep=''))

pwm_all_comt_genes[[im]] <- as.data.frame(t(all_genes.lett.freq[[im]]))
colnames(pwm_all_comt_genes[[im]]) <- DNA_BASES
          pwm_all_comt_genes[[im]]$site <- c(-40:10)

pwm_all_comt_genes_ATvCG[[im]]   <- data.frame(site=pwm_all_comt_genes[[im]][,5],
                              AT=(pwm_all_comt_genes[[im]][,1] + pwm_all_comt_genes[[im]][,4]),
                              CG=(pwm_all_comt_genes[[im]][,2] + pwm_all_comt_genes[[im]][,3]))

}


##### All genes used in the COMT project

# long form to plot the background PWM

all.genes.PWM.near.TSS <- lapply(pwm_all_comt_genes[ib], function(x,ib) data.frame(x[,1:4]), ib )

all.PWM.long <- lapply(all.genes.PWM.near.TSS[ib], function(x,ib) stack(x), ib)

all.PWM.long.temp <- rbind(all.PWM.long[[1]],
                  all.PWM.long[[2]],
                  all.PWM.long[[3]],
                  all.PWM.long[[4]])

     all.PWM.long.temp$loci <- as.integer(c(rep(c(-40:10),16)))
     all.PWM.long.temp$area <- c(rep(stand.Col.names.aug, each=4*length(sseq)))


     colnames(all.PWM.long.temp) <- c('PWM','Nucleotide','Locus','Brain_Area')

     
all.area.PWM.bground <- all.PWM.long.temp

### AT v CG ##########
# long form to plot the background PWM

all.PWM.long.ATvCG <- list()
all.genes.PWM.near.TSS.ATvCG <- list()
all.PWM.long.temp.ATvCG <- list()
all.area.PWM.bground.ATvCG <- list()

all.genes.PWM.near.TSS.ATvCG <- lapply(pwm_all_comt_genes_ATvCG[ib], function(x,ib) data.frame(x[,2:3]), ib )

all.PWM.long.ATvCG <- lapply(all.genes.PWM.near.TSS.ATvCG[ib], function(x,ib) stack(x), ib)

all.PWM.long.temp.ATvCG <- rbind(all.PWM.long.ATvCG[[1]],
                  all.PWM.long.ATvCG[[2]],
                  all.PWM.long.ATvCG[[3]],
                  all.PWM.long.ATvCG[[4]])

     all.PWM.long.temp.ATvCG$loci <- as.integer(c(rep(c(-40:10),4)))
     all.PWM.long.temp.ATvCG$area <- c(rep(stand.Col.names.aug, each=length(sseq)))


     colnames(all.PWM.long.temp.ATvCG) <- c('PWM','NucleotidePair','Locus','Brain_Area')

     
all.area.PWM.bground.ATvCG <- all.PWM.long.temp.ATvCG


# #### all: try with pwm_all_comt_genes
# all.genes.PWM.near.TSS <- lapply(all_genes.lett.freq[ib], function(x,ib) data.frame(x), ib )
# 
# all.PWM.long <- lapply(all.genes.PWM.near.TSS[ib], function(x,ib) stack(x), ib)
# 
# for (im in ib)    {
#      
#      all.PWM.long[[im]]$loci <- as.integer(c(rep(-40:10,each=4)))
#      all.PWM.long[[im]]$ntide <- c(rep(c('A','C','G','T'),length(subseq)))
# 
# }
# 
# all.area.PWM.bground <- rbind(all.PWM.long[[1]],
#                               all.PWM.long[[2]],
#                             all.PWM.long[[3]],
#                             all.PWM.long[[4]])
# all.area.PWM.bground$area <- c(rep(stand.Col.names.aug[1:4],each=204))
# 

######### positive
# long form 

pos.genes.PWM.near.TSS <- lapply(pwm_pos_comt_genes[ib], function(x,ib) data.frame(x[,1:4]), ib )

pos.PWM.long <- lapply(pos.genes.PWM.near.TSS[ib], function(x,ib) stack(x), ib)

pos.PWM.long.temp <- rbind(pos.PWM.long[[1]],
                  pos.PWM.long[[2]],
                  pos.PWM.long[[3]],
                  pos.PWM.long[[4]])

     pos.PWM.long.temp$loci <- as.integer(c(rep(c(-40:10),16)))
     pos.PWM.long.temp$area <- c(rep(stand.Col.names.aug, each=4*length(sseq)))


     colnames(pos.PWM.long.temp) <- c('PWM','Nucleotide','Locus','Brain_Area')

     
pos.area.PWM.bground <- pos.PWM.long.temp

######### negative
# long form

neg.genes.PWM.near.TSS <- lapply(pwm_neg_comt_genes[ib], function(x,ib) data.frame(x[,1:4]), ib )

neg.PWM.long <- lapply(neg.genes.PWM.near.TSS[ib], function(x,ib) stack(x), ib)

neg.PWM.long.temp <- rbind(neg.PWM.long[[1]],
                  neg.PWM.long[[2]],
                  neg.PWM.long[[3]],
                  neg.PWM.long[[4]])

     neg.PWM.long.temp$loci <- as.integer(c(rep(c(-40:10),16)))
     neg.PWM.long.temp$area <- c(rep(stand.Col.names.aug, each=4*length(sseq)))


     colnames(neg.PWM.long.temp) <- c('PWM','Nucleotide','Locus','Brain_Area')

     
neg.area.PWM.bground <- neg.PWM.long.temp


long.area <- matrix(c(1,204,
                      205,408,
                      409,612,
                      613,816), ncol=2,byrow=TRUE)



lcoord <- c(1)   # 1 = pf, 2 - cb, etc.   brain area index

params.plot <- data.frame(titlen=c("15998 Genes",
                                   "Positively COMT-correlated genes",
                                   "Negatively COMT-correlated genes"),
                         fnamesa=c(paste("pwm_all_genes_",area.abbrv[lcoord],sep=''),
                                  paste("pwm_pos_genes_",area.abbrv[lcoord],sep=''),
                                  paste("pwm_neg_genes_",area.abbrv[lcoord],sep='')),
                         fnamesb=c(paste("pwm_all_genes_by_ntide_",area.abbrv[lcoord],sep=''),
                                  paste("pwm_pos_genes_by_ntide_",area.abbrv[lcoord],sep=''),
                                  paste("pwm_neg_genes_by_ntide_",area.abbrv[lcoord],sep=''))
                          )

plot.dir <- c('/Volumes/Macintosh_HD_3/genetics/genenetwork2/new_plots/')
plotn <- list()

all.area.PWM.bground$Nucleotide <- factor(all.area.PWM.bground$Nucleotide, levels = c("C","G",
                                                                            "A","T"))

pos.area.PWM.bground$Nucleotide <- factor(pos.area.PWM.bground$Nucleotide, levels = c("C","G",
                                                                            "A","T"))

neg.area.PWM.bground$Nucleotide <- factor(neg.area.PWM.bground$Nucleotide, levels = c("C","G",
                                                                            "A","T"))


for (ik in 1:3)    {
pj <- ik   # 1 = all, 2 = pos, 3 = neg
### All nucleotides on one plot

if (pj == 1)  {
     datset <- all.area.PWM.bground

} else if (pj == 2)  {
     datset <- pos.area.PWM.bground
     
} else if (pj == 3) {
     datset <- neg.area.PWM.bground
     
} else {
     
}
plotn[[pj]] <- ggplot(data=datset[long.area[lcoord,1]:long.area[lcoord,2],], aes(x=Locus,y=PWM,color=Nucleotide)) +     
          geom_line(size=0.75) +
          theme_classic() +
          labs(title='Site-specific nucleotide proportions (TSS = 0)',
               x = 'Position',
               y = 'Proportion',
               subtitle=c(paste(stand.Col.names[lcoord],": ",
                                params.plot$titlen[pj],sep=''))) +
     theme(plot.title = element_text(hjust = 0.5)) +
     theme(plot.subtitle = element_text(hjust = 0.5)) +
     scale_x_continuous(breaks=c(-40,-30,-20,-10,0,10),
                        labels=c('-40','-30','-20','-10','TSS','+10')) +
     geom_vline(aes(xintercept = 0),linetype='dotted',size=0.6) 
     # annotate("text", x = c(-26), y = c(0.23), 
     #          label = c('TATA Box'),
     #           size = 3,
     #           color='black')
plotn[[pj]]

ggsave(c(paste(plot.dir,params.plot$fnamesa[pj],'.pdf',sep='')), 
       plot = plotn[[pj]], device = 'pdf', path = NULL,
       scale = 1, width = 7, height = 5, units = c("in"),
       dpi = 300, limitsize = TRUE)
}

### By nucleotide
plotb <- list()

lcoord <- c(4)   # 1 = pf, 2 - cb, etc.

params.plot <- data.frame(titlen=c("15998 Genes",
                                   "Positively COMT-correlated genes",
                                   "Negatively COMT-correlated genes"),
                         fnamesa=c(paste("pwm_all_genes_",area.abbrv[lcoord],sep=''),
                                  paste("pwm_pos_genes_",area.abbrv[lcoord],sep=''),
                                  paste("pwm_neg_genes_",area.abbrv[lcoord],sep='')),
                         fnamesb=c(paste("pwm_all_genes_by_ntide_",area.abbrv[lcoord],sep=''),
                                  paste("pwm_pos_genes_by_ntide_",area.abbrv[lcoord],sep=''),
                                  paste("pwm_neg_genes_by_ntide_",area.abbrv[lcoord],sep=''))
                          )
for (ik in 1:3)    {
pj <- ik 
if (pj == 1)  {
     datset <- all.area.PWM.bground

} else if (pj == 2)  {
     datset <- pos.area.PWM.bground
     
} else if (pj == 3) {
     datset <- neg.area.PWM.bground
     
} else {
 
}

plotb[[pj]] <- ggplot(data=datset[long.area[lcoord,1]:long.area[lcoord,2],], aes(x=Locus,y=PWM,color=Nucleotide)) +
          facet_wrap(~ntide, ncol = 1,strip.position="right") +
          geom_point() + #size=0.75,color='red') +
          stat_smooth(position='identity',span=c(0.25),n=c(5))  +
          theme_classic() +
          theme(strip.background = element_rect(colour = 'black', fill = 'gray90', size = 0.5)) +
          labs(title='Site-specific nucleotide proportions (TSS = 0)',
               x = 'Position',
               y = 'Proportion',
               subtitle=c(paste(stand.Col.names[lcoord],": ",
                                params.plot$titlen[pj],sep=''))) +
     theme(plot.title = element_text(hjust = 0.5)) +
     theme(plot.subtitle = element_text(hjust = 0.5)) +
     scale_x_continuous(breaks=c(-40,-30,-20,-10,0,10),
                        labels=c('-40','-30','-20','-10','TSS','+10')) +
     scale_y_continuous(limits=c(0.05,0.5),expand=c(0,0)) +
     geom_vline(aes(xintercept = 0),linetype='dotted',size=0.6) +
     geom_hline(aes(yintercept = 0.05),size=0.6)
     
plotb[[pj]]

ggsave(c(paste(plot.dir,params.plot$fnamesb[pj],'.pdf',sep='')), 
       plot = plotb[[pj]], device = 'pdf', path = NULL,
       scale = 1, width = 7, height = 5, units = c("in"),
       dpi = 300, limitsize = TRUE)
}

#### plot AT v CG content
plot.ATvCG <- ggplot(data=all.area.PWM.bground.ATvCG, aes(x=Locus,y=PWM,color=NucleotidePair)) +     
          geom_line(size=0.75) +
          theme_classic() +
          labs(title='Site-specific AT vs CG content proportions',
               x = 'Position',
               y = 'Proportion'
               ) +
     theme(plot.title = element_text(hjust = 0.5)) +
     theme(plot.subtitle = element_text(hjust = 0.5)) +
     scale_x_continuous(breaks=c(-40,-30,-20,-10,0,10),
                        labels=c('-40','-30','-20','-10','+1','+10')) +
     scale_y_continuous(limits=c(0.0,1.0),
                        breaks=c(seq(0,1,.2))) +
     geom_vline(aes(xintercept = 0),linetype='dotted',size=0.6) 
     # annotate("text", x = c(-26), y = c(0.23), 
     #          label = c('TATA Box'),
     #           size = 3,
     #           color='black')
plot.ATvCG

ggsave(c(paste(new_plots,'all_genes_ATvCG.pdf',sep='')), 
       plot = plot.ATvCG, device = 'pdf', path = NULL,
       scale = 1, width = 7, height = 5, units = c("in"),
       dpi = 300, limitsize = TRUE)


@

<<maxPercent.letter.locus>>=

### All COMT genes

# 1 = A, 2 = C, 3 = G, 4 = T
pwmDNA.all <- lapply(DNA_BASES[ib], function(x,ib) subset(all.area.PWM.bground,all.area.PWM.bground$Nucleotide == x),ib)

pwmDNA.all <- lapply(pwmDNA.all[ib], function(x,ib) x[order(x$PWM,decreasing=TRUE),],ib)

pwm.max.all <- lapply(pwmDNA.all[ib], function(x,ib)  x[1:20,][order(x[1:20,]$Brain_Area),], ib)

pwm.max.all.tab  <- lapply(pwm.max.all[ib], function(x,ib)  print.xtable(xtable(x,
                           caption=c('Maximum percentage DNA nucleotides by locus \n relative to the TSS and by brain area'),digits=4)),ib)

## Positively COMT-correlated genes

pwmDNA.pos <- lapply(DNA_BASES[ib], function(x,ib) subset(pos.area.PWM.bground,pos.area.PWM.bground$Nucleotide == x),ib)

pwmDNA.pos <- lapply(pwmDNA.pos[ib], function(x,ib) x[order(x$PWM,decreasing=TRUE),],ib)

sf <- c(1:4)

pwmDNApos.fin <- list()
for (im in ib)  {
     
     pwm.max.pos.temp <- list()
     for (ih in sf)    {
          
          pwm.max.pos.temp[[ih]] <- subset(pwmDNA.pos[[im]],pwmDNA.pos[[im]]$Brain_Area == stand.Col.names.aug[ih])[1:10,]
}
     pwmDNApos.fin[[im]] <- pwm.max.pos.temp
}

max.PC.pos <- list()

for (im in ib)      {


     max.PC.pos[[im]] <- data.frame(Nucleotide=pwmDNApos.fin[[im]][[1]][,2],
                          PfCtx=pwmDNApos.fin[[im]][[1]][,3],
                          Cerrb=pwmDNApos.fin[[im]][[2]][,3],
                          TmCtx=pwmDNApos.fin[[im]][[3]][,3],
                          Pons=pwmDNApos.fin[[im]][[4]][,3])
     
     }

max.PC.pos.long.T <- stack(max.PC.pos[[4]][,2:5])
max.PC.pos.long.G <- stack(max.PC.pos[[3]][,2:5])
max.PC.pos.long.C <- stack(max.PC.pos[[2]][,2:5])
max.PC.pos.long.A <- stack(max.PC.pos[[1]][,2:5])
colnames(max.PC.pos.long.A) <- c('locus','BrainArea')
colnames(max.PC.pos.long.C) <- c('locus','BrainArea')
colnames(max.PC.pos.long.G) <- c('locus','BrainArea')
colnames(max.PC.pos.long.T) <- c('locus','BrainArea')

max.PC.pos.long.T$line <- c(rep(16.5,40))
max.PC.pos.long.G$line <- c(rep(14.0,40))
max.PC.pos.long.C$line <- c(rep(11.5,40))
max.PC.pos.long.A$line <- c(rep(9.0,40))

max.PC.pos.pf <- rbind(max.PC.pos.long.A[1:10,],
               max.PC.pos.long.C[1:10,],
               max.PC.pos.long.G[1:10,],
               max.PC.pos.long.T[1:10,])
max.PC.pos.pf$line <- c(rep(9.0,40))
max.PC.pos.pf$Nucleotide <- c(rep(DNA_BASES,each=10))

max.PC.pos.cb <- rbind(max.PC.pos.long.A[11:20,],
               max.PC.pos.long.C[11:20,],
               max.PC.pos.long.G[11:20,],
               max.PC.pos.long.T[11:20,])
max.PC.pos.cb$line <- c(rep(11.5,40))
max.PC.pos.cb$Nucleotide <- c(rep(DNA_BASES,each=10))

max.PC.pos.tm <- rbind(max.PC.pos.long.A[21:30,],
               max.PC.pos.long.C[21:30,],
               max.PC.pos.long.G[21:30,],
               max.PC.pos.long.T[21:30,])
max.PC.pos.tm$line <- c(rep(14.0,40))
max.PC.pos.tm$Nucleotide <- c(rep(DNA_BASES,each=10))

max.PC.pos.po <- rbind(max.PC.pos.long.A[31:40,],
               max.PC.pos.long.C[31:40,],
               max.PC.pos.long.G[31:40,],
               max.PC.pos.long.T[31:40,])
max.PC.pos.po$line <- c(rep(16.0,40))
max.PC.pos.po$Nucleotide <- c(rep(DNA_BASES,each=10))


max.PC.pos <- rbind(max.PC.pos.pf,
                    max.PC.pos.cb,
                    max.PC.pos.tm,
                    max.PC.pos.po)



## Negatively COMT-correlated genes

pwmDNA.neg <- lapply(DNA_BASES[ib], function(x,ib) subset(neg.area.PWM.bground,neg.area.PWM.bground$Nucleotide == x),ib)

pwmDNA.neg <- lapply(pwmDNA.neg[ib], function(x,ib) x[order(x$PWM,decreasing=TRUE),],ib)

sf <- c(1:4)

pwmDNAneg.fin <- list()
for (im in ib)  {
     
     pwm.max.neg.temp <- list()
     for (ih in sf)    {
          
          pwm.max.neg.temp[[ih]] <- subset(pwmDNA.neg[[im]],pwmDNA.neg[[im]]$Brain_Area == stand.Col.names.aug[ih])[1:10,]
}
     pwmDNAneg.fin[[im]] <- pwm.max.neg.temp
}

max.PC.neg <- list()

for (im in ib)      {


     max.PC.neg[[im]] <- data.frame(Nucleotide=pwmDNAneg.fin[[im]][[1]][,2],
                          PfCtx=pwmDNAneg.fin[[im]][[1]][,3],
                          Cerrb=pwmDNAneg.fin[[im]][[2]][,3],
                          TmCtx=pwmDNAneg.fin[[im]][[3]][,3],
                          Pons=pwmDNAneg.fin[[im]][[4]][,3])
     
     }

max.PC.neg.long.T <- stack(max.PC.neg[[4]][,2:5])
max.PC.neg.long.G <- stack(max.PC.neg[[3]][,2:5])
max.PC.neg.long.C <- stack(max.PC.neg[[2]][,2:5])
max.PC.neg.long.A <- stack(max.PC.neg[[1]][,2:5])
colnames(max.PC.neg.long.A) <- c('locus','BrainArea')
colnames(max.PC.neg.long.C) <- c('locus','BrainArea')
colnames(max.PC.neg.long.G) <- c('locus','BrainArea')
colnames(max.PC.neg.long.T) <- c('locus','BrainArea')

max.PC.neg.long.T$line <- c(rep(16.5,40))
max.PC.neg.long.G$line <- c(rep(14.0,40))
max.PC.neg.long.C$line <- c(rep(11.5,40))
max.PC.neg.long.A$line <- c(rep(9.0,40))

max.PC.neg.pf <- rbind(max.PC.neg.long.A[1:10,],
               max.PC.neg.long.C[1:10,],
               max.PC.neg.long.G[1:10,],
               max.PC.neg.long.T[1:10,])
max.PC.neg.pf$line <- c(rep(9.0,40))
max.PC.neg.pf$Nucleotide <- c(rep(DNA_BASES,each=10))

max.PC.neg.cb <- rbind(max.PC.neg.long.A[11:20,],
               max.PC.neg.long.C[11:20,],
               max.PC.neg.long.G[11:20,],
               max.PC.neg.long.T[11:20,])
max.PC.neg.cb$line <- c(rep(11.5,40))
max.PC.neg.cb$Nucleotide <- c(rep(DNA_BASES,each=10))

max.PC.neg.tm <- rbind(max.PC.neg.long.A[21:30,],
               max.PC.neg.long.C[21:30,],
               max.PC.neg.long.G[21:30,],
               max.PC.neg.long.T[21:30,])
max.PC.neg.tm$line <- c(rep(14.0,40))
max.PC.neg.tm$Nucleotide <- c(rep(DNA_BASES,each=10))

max.PC.neg.po <- rbind(max.PC.neg.long.A[31:40,],
               max.PC.neg.long.C[31:40,],
               max.PC.neg.long.G[31:40,],
               max.PC.neg.long.T[31:40,])
max.PC.neg.po$line <- c(rep(16.0,40))
max.PC.neg.po$Nucleotide <- c(rep(DNA_BASES,each=10))


max.PC.neg <- rbind(max.PC.neg.pf,
                    max.PC.neg.cb,
                    max.PC.neg.tm,
                    max.PC.neg.po)



library(extrafont)
library(ggthemes)
library(scales)


###### To plot the highest 10 nucleotide percentages at their corresponding loci with all brain areas on same plot, but either positive or negative subset 
wh.data <- list(max.PC.neg,
                 max.PC.pos)

dat.set <- data.frame(wh.data[[2]])

#subs.area.lett <- subset(dat.set$BrainArea,dat.set$BrainArea == stand.Col.names.aug[1] & dat.set$BrainArea == 'A')

lett.plt <- ggplot(data=dat.set, aes(x=locus,y=line,
                                             shape=Nucleotide,
                                             color=Nucleotide)) +
     geom_jitter(height=0.5,width=0.15,size=c(4.0), show.legend=FALSE)  +
     theme_tufte() +
     theme(panel.grid.major = element_blank(),
           panel.grid.minor = element_blank(),
           legend.text = element_blank()
           ) +
     theme(legend.position="none") +
     theme(title =element_text(size=9))   +
     theme(plot.title = element_text(hjust = 0.5))   +
     guides(fill=FALSE) +
     scale_shape_manual(values=LETTERS[c(1,3,7,20)],
                        guide=FALSE) +
#     scale_colour_manual(values = cbbPalette[c(3,4,6,7)]) +
     scale_color_brewer(palette="Set1")   +
     scale_y_continuous(limits=c(8.0,18.0),labels=c(),breaks=NULL) +
     scale_x_continuous(breaks=c(seq(-40,10,5)),
                        labels=c('-40','','-30','','-20','','-10','','TSS','','10'))  +
     theme(axis.line = element_line(color="gray75", size = 0.5))   +
     theme(axis.title = element_text(size = 11))   +
     xlab(label = c('Locus ref: TSS'))   +
     geom_hline(yintercept = c(9.0,11.5,14.0,16.5),size=0.5,color='gray80') +
     geom_vline(xintercept = c(0,0,0,0),size=c(0.25),color='black',linetype='dotted')  +
     geom_vline(xintercept = c(1,1,1,1),size=c(0.25),color='black',linetype='dotted')  +
     ylab(c())   +
     theme(plot.margin=unit(c(1,2,1,2),"cm"), axis.text.y=element_text(size=10)) +
     annotate("text", x = c(-37,-39,-37,-41), y = c(c(9.0,11.5,14.0,16.5) + 0.9), 
              label = stand.Col.names.aug,
              size = 3.5,
              color='black') +
     annotate("text", x = c(1), y = c(17.5), 
              label = c('+1'),
              size = 3.0,
              color='black') +
     ggtitle("Loci of highest 10 nucleotide percentages within TSS range of -40 to +10 \n for each nucleotide by brain area for genes with expression positively \n correlated with COMT-expression")

lett.plt

ggsave(c(paste(plot.dir,'loci_highest_10_ntide_pos.pdf',sep='')), 
       plot = lett.plt, device = 'pdf', path = NULL,
       scale = 1, width = 7, height = 5, units = c("in"),
       dpi = 300, limitsize = TRUE)
########## end plotting within positive or negative subsets

###### To plot the highest 10 nucleotide percentages at their corresponding loci within  a brain areas on same plot for both positive and negative subsets on same graph 
wh.data.temp <- rbind(max.PC.neg[121:160,],
                    max.PC.pos[121:160,])
wh.data.temp$Valence <- c(rep(c('NegativeSubset',
                              'PositiveSubset'),each=40))
wh.data.temp$line <- c(rep(c(11.5,9.0),each=40))

dat.set <- wh.data.temp


lett.plt <- ggplot(data=dat.set, aes(x=locus,y=line,
                                             shape=Nucleotide,
                                             color=Nucleotide)) +
     geom_jitter(height=0.5,width=0.15,size=c(4.0), show.legend=FALSE)  +
     theme_tufte() +
     theme(panel.grid.major = element_blank(),
           panel.grid.minor = element_blank(),
           legend.text = element_blank()
           ) +
     theme(legend.position="none") +
     theme(title =element_text(size=9))   +
     theme(plot.title = element_text(hjust = 0.5))   +
     guides(fill=FALSE) +
     scale_shape_manual(values=LETTERS[c(1,3,7,20)],
                        guide=FALSE) +
#     scale_colour_manual(values = cbbPalette[c(3,4,6,7)]) +
     scale_color_brewer(palette="Set1")   +
     scale_y_continuous(limits=c(8.0,14.0),labels=c(),breaks=NULL,expand = c(0, 0)) +
     scale_x_continuous(breaks=c(seq(-40,10,5)),
                        labels=c('-40','','-30','','-20','','-10','','TSS','','10'))  +
     theme(axis.line = element_line(color="gray75", size = 0.5))   +
     theme(axis.title = element_text(size = 11))   +
     xlab(label = c('Locus ref: TSS'))   +
     geom_hline(yintercept = c(9.0,11.5),size=0.3,color='gray80') +
     geom_segment(aes(x = 0, xend = 0, y = 8.0 , yend = 12.5),
                  color='black',linetype='dotted',size=0.25) +
     geom_segment(aes(x = 1, xend = 1, y = 8.0 , yend = 12.5),
                  color='black',linetype='dotted',size=0.25) +
#     geom_vline(xintercept = c(1,1),size=c(0.25),color='black',linetype='dotted')  +
     ylab(c())   +
     theme(plot.margin=unit(c(1,2,1,2),"cm"), axis.text.y=element_text(size=10)) +
     annotate("text", x = c(-37,-37), y = c(c(9.0,11.5) + 0.9), 
              label = c('Positive Subset','Negative Subset'),
              size = 3.5,
              color='black') +
     annotate("text", x = c(1.2), y = c(12.6), 
              label = c('+1'),
              size = 3.0,
              color='black') +
     annotate("text", x = c(-15), y = c(13.9), 
              label = c('Loci of highest 10 nucleotide percentages within TSS range'),
              size = 3.5,
              color='black') +
     annotate("text", x = c(-15), y = c(13.6), 
              label = expression(paste("-40 to +10 for each nucleotide for genes in ", bold("Pons"),sep="")),
              size = 3.5,
              color='black') +
     annotate("text", x = c(-15), y = c(13.3), 
              label = expression(paste(" with expression positively or negatively correlated with ", italic("COMT"),"-expression",sep="")),
              size = 3.5,
              color='black')

lett.plt

ggsave(c(paste(plot.dir,'loci_highest_10_ntide_posVneg_po.pdf',sep='')), 
       plot = lett.plt, device = 'pdf', path = NULL,
       scale = 1, width = 7, height = 5, units = c("in"),
       dpi = 300, limitsize = TRUE)
########## end plotting within brain areas


# Initiator element consensus sequence (found in absense of TATA box)
# Y Y A N W Y Y

# [C/T]   [C/T]     A    [A/C/G/T]      [A/T]     [C/T]     [C/T]
#   -2   -1         +1        +2          +3        +4       +5
#  999   1000     1001       1002        1003      1004     1005

# or
# B       B         C         A         B         W
#[C/G/T]   [A/T]     C          A        [C/G/T]   [A/T] 
# -3      -2        -1        +1        +2        +3
# 998     999      1000      1001      1002      1003
                     

# Symbol[2] 	Description 	                    Bases represented 	     Complement
# A 	               Adenine 	                         A 		          1 	     T
# C 	               Cytosine 		                    C 		          "	     G
# G 	               Guanine 			               G 		          "         C
# T 	               Thymine 				          T 	               "         A
# U 	               Uracil 			          	U 	               "         A

# W 	               Weak 	                         A 	T 	          2 	     W
# S 	               Strong 	                    	C 	G 	          "	     S
# M 	               aMino 	                         A 	C 	          "		K
# K 	               Keto 			               G 	T              "    	M
# R 	               puRine 	                         A 	G 	          "	     Y
# Y 	               pYrimidine 		               C 	T 	          "         R

# B {A} 	          not A (B comes after A) 		     C 	G 	T 	     3 	     V
# D {C} 	          not C (D comes after C) 	          A 	G 	T         " 	     H
# H {G} 	          not G (H comes after G) 	          A 	C 	T 	     "         D
# V {T} 	          not T (V comes after T and U) 	A 	C 	G 		"         B
# N 	               any Nucleotide (not a gap) 	     A 	C 	G 	T 	4 	     N
# Z 	               Zero 					                         0 	     Z

@

\includegraphics{Core_promoter_elements}

<<initiator.element>>=
# Y-Y-A-N-W-Y-Y
# [C/T]   [C/T]     A    [A/C/G/T]      [A/T]     [C/T]     [C/T]
#  999    1000     1001       1002       1003      1004     1005    for prom.all, prom.pos etc
#  39      40      41          42         43        44       45     in fasta.by.lett series

# or
# B-W-C-A-B-W
# [C/G/T]   [A/T]     C          A        [C/G/T]   [A/T]
# 998        999     1000      1001         1002     1003
#  38        39       40        41           42       43

# or simply YR
# [C/T]   [A/G]
#   1000  1001
#  40      41

#### fasta.by.lett_all.genes[[1]][[1]][1:10] only has the 51 letters from -40 to +10 for all genes in the COMT project in pf

#### proms.all[[1]] has the COMT genes as fasta formatted 1600-character entries.


motif.Inr <- c('[CGT][AT]CA[CGT][AT]',
               '[CT][CT]A[ACGT][AT][CT][CT]',
               '[C/T][A/G]'
               )
loc.lims.t <- c(-107,50)
loc.lims <- 1000 + loc.lims.t

motif.hits.loci.all <- list()
num.Inr.all <- matrix(rep(NA,16),ncol=4)
for (im in ib)   {
     
     num.Inr.all[im,4] <- c(dim(proms.all[[im]])[1])
     at.least <- matrix(rep(NA,3*dim(proms.all[[im]])[1]),ncol=3)
     loc.hits <- list()
     
     for (ai in 1:3)      {
               
          loc.hits.temp <- c(0)
     
          grep.temp <- c(NA)
          
          for (kh in 1:dim(proms.all[[im]])[1])     {
          
               cat(paste('brain area ',im,' gene ',kh,' \n',sep=''))
          
               grep.temp <- gregexpr(motif.Inr[ai],substr(proms.all[[im]][kh],loc.lims[1],loc.lims[2]))

          if (grep.temp[[1]][1] > 0) {
               
               at.least[kh,ai] <- c(1) # this gene (kh) has at least one hit for this motif (ai)
               loc.hits.temp <- c(loc.hits.temp,
                                 grep.temp[[1]][1:length(grep.temp[[1]])])
          
          }  else {
               
               at.least[kh,ai] <- c(0) 
     
          }
     
               # check the reverse complement
               # has.init.elem.rc <- sum(grepl('[CGT][AT]CA[CGT][AT]',substr(reverseComplement(DNAStringSet(proms.all[[im]][kh])),900,1050)))

     }    # number of genes loop kh
     
          loc.hits[[ai]] <- loc.hits.temp[2:length(loc.hits.temp)] + (loc.lims.t[1] -1)
     
}  # motif type loop ai
     
     motif.hits.loci.all[[im]] <- loc.hits
     num.Inr.all[im,1] <- sum(at.least[,1])
     num.Inr.all[im,2] <- sum(at.least[,2])
     num.Inr.all[im,3] <- sum(at.least[,3])

}


for (im in ib)    {
     for (jy in 1:3)    {
     
          motif.hits.loci.all[[im]][[jy]] <- subset(motif.hits.loci.all[[im]][[jy]],
                                        motif.hits.loci.all[[im]][[jy]] >= -100)

     }
}


####### run to here ^^^^^

num.Inr.all.pc <- matrix(rep(NA,7*4),ncol=7)
num.Inr.all.pc[,c(1,3,5,7)] <- num.Inr.all[,c(1,2,3,4)]
num.Inr.all.pc[,c(2,4,6)] <- round(100*num.Inr.all.pc[,c(1,3,5)]/num.Inr.all.pc[,7],1)

num.Inr.all.f <- data.frame(motif1=c(paste(num.Inr.all.pc[,1],
                         ' (',round(num.Inr.all.pc[,2],3),') ',sep='')),
                         motif2=c(paste(num.Inr.all.pc[,3],
                         ' (',round(num.Inr.all.pc[,4],3),') ',sep='')),
                         motif3=c(paste(num.Inr.all.pc[,5],
                         ' (',round(num.Inr.all.pc[,6],3),') ',sep='')),
                         Genes=num.Inr.all.pc[,7])


colnames(num.Inr.all.f) <- c(expon("Inr1","a"),
#                           'Inr2\\$^b\\$',
                            expon("Inr2","b"),
                            expon("Inr3","c"),
                           'Number of Genes')
row.names(num.Inr.all.f) <- stand.Col.names.aug



num.Inr.all.tab <- xtable(num.Inr.all.f,
                                caption=c(paste("Number (percentage) of all ",italic("COMT"),"\\den correlated genes in each brain area having at least one instance of each of three different consensus intiator element (Inr) sequences in the region from -100 to + 50 nucleotides relative to the transcription start site TSS (adjacent to +1)",sep="")))

print(num.Inr.all.tab,type='latex',sanitize.text.function = function(x) {x})

@

<<Inr.plots>>=

Inr.hits.motif1.long <- data.frame(loci=c(unlist(motif.hits.loci.all[[1]][[1]])),
                             motif=c(rep(expression(paste('B-W-C-',underline(A),'-B-W',sep="")),length(unlist(motif.hits.loci.all[[1]][[1]])))
                                     ))
Inr.hits.motif2.long <- data.frame(loci=c(unlist(motif.hits.loci.all[[1]][[2]])),
                             motif=c(rep('Y-Y-A-N-W-Y-Y',length(unlist(motif.hits.loci.all[[1]][[2]])))
                                     ))
Inr.hits.motif3.long <- data.frame(loci=c(unlist(motif.hits.loci.all[[1]][[3]])),
                             motif=c(rep('Y-R',length(unlist(motif.hits.loci.all[[1]][[3]])))
                                     ))



Inr.hits.motif.long <- rbind(Inr.hits.motif1.long,
                         Inr.hits.motif2.long,
                         Inr.hits.motif3.long)


Inr.hits.motif.long$motif <- factor(Inr.hits.motif.long$motif, 
                         levels = c(expression(paste('B-W-C-',underline(A),'-B-W',sep="")),
                                         "Y-Y-A-N-W-Y-Y",
                                               "Y-R"))

                                           
Inrmotifs.plt <- ggplot(data=Inr.hits.motif.long, aes(loci,color=motif)) +
     geom_bar(stat="count") +
     facet_wrap(~ motif,nrow=3,scales="free_y")   +
     theme_minimal() +
     theme(panel.grid.major = element_blank(),
           panel.grid.minor = element_blank()
           ) +
     theme(title =element_text(size=8))   +
     labs(title="Positions of Three Different Inr Consensus Sequence \n Promoter Motifs Across All COMT-Correlated Genes") +
     theme(plot.title = element_text(hjust = 0.5))   +
      theme(panel.grid.major = element_blank(),
           panel.grid.minor = element_blank(),
           legend.text = element_blank()
           ) +
     theme(legend.position="none") +
     guides(fill=FALSE)   +
     scale_color_brewer(palette="Set1")   +
#     scale_y_continuous(limits=c(0,100),breaks=c(seq(0,100,20)),expand=c(0.01,0)) +
     scale_x_continuous(breaks=c(seq(-100,50,25)),
                        labels=c(as.character(c(seq(-100,-25,25))),'+1',as.character(seq(25,50,25))))  +
     theme(axis.title = element_text(size = 11))   +
     theme(axis.line = element_line(color="gray75", size = 0.5))   +
     xlab(label = c('Position'))   +
     geom_vline(xintercept = c(0),size=c(0.5),color='red',linetype='dashed')  +
     ylab(label=c('Frequency'))   
Inrmotifs.plt


ggsave("/Volumes/Macintosh_HD_3/genetics/genenetwork2/new_plots/Inr_motif_positions_all_COMT_genes.pdf",plot=Inrmotifs.plt,device="pdf",
       scale=2,
       dpi=300,
       width=6.0,
       height=3.0,
       units=c('in')
)

@



<<TATA.all>>=
# 'TATA[TA]A[TA][ACGT]'

motif.Inr <- c('TATA[TA]A[TA][ACGT]'
               )
loc.lims.t <- c(-250,150)
loc.lims <- 1000 + loc.lims.t

motif.hits.loci.all <- list()
num.Inr.all <- matrix(rep(NA,8),ncol=2)
for (im in ib)   {
     
     num.Inr.all[im,2] <- c(dim(proms.all[[im]])[1])
     at.least <- matrix(rep(NA,dim(proms.all[[im]])[1]),ncol=1)
     loc.hits <- list()
     
     for (ai in 1:1)      {
               
          loc.hits.temp <- c(0)
     
          grep.temp <- c(NA)
          
          for (kh in 1:dim(proms.all[[im]])[1])     {
          
               cat(paste('brain area ',im,' gene ',kh,' \n',sep=''))
          
               grep.temp <- gregexpr(motif.Inr[ai],substr(proms.all[[im]][kh],loc.lims[1],loc.lims[2]))

          if (grep.temp[[1]][1] > 0) {
               
               at.least[kh,ai] <- c(1) # this gene (kh) has at least one hit for this motif (ai)
               loc.hits.temp <- c(loc.hits.temp,
                                 grep.temp[[1]][1:length(grep.temp[[1]])])
          
          }  else {
               
               at.least[kh,ai] <- c(0) 
     
          }
     
               # check the reverse complement
               # substr(reverseComplement(DNAStringSet(proms.all[[im]][kh])),900,1050)))

     }    # number of genes loop kh
     
          loc.hits[[ai]] <- loc.hits.temp[2:length(loc.hits.temp)] + (loc.lims.t[1] -1)
     
}  # motif type loop ai
     
     motif.hits.loci.all[[im]] <- loc.hits
     num.Inr.all[im,1] <- sum(at.least[,1])

}

num.Inr.all.int <- matrix(rep(NA,4*3),ncol=3)
num.Inr.all.int[,3] <- num.Inr.all[,2]
num.Inr.all.int[,1] <- num.Inr.all[,1]
num.Inr.all.int[,2] <- round(100*num.Inr.all.int[,1]/num.Inr.all.int[,3],1)
num.Inr.all.pc <- matrix(rep(NA,2*4),ncol=2)

num.Inr.all.pc[,2] <- num.Inr.all.int[,3]
num.Inr.all.pc[,1] <- c(paste(num.Inr.all.int[,1],' (',round(num.Inr.all.int[,2],3),') ',sep=''))

colnames(num.Inr.all.pc) <- c(expon("TATA8","a"),
                           'Number of Genes')
row.names(num.Inr.all.pc) <- stand.Col.names.aug

num.Inr.all.tab <- xtable(num.Inr.all.pc,
                                caption=c(paste("Number (percentage) of the allitive subset of the most highly ",italic("COMT"),"\\den correlated genes in each brain area having at least one instance of the TATA8 motif in the region from -250 to +150 nucleotides relative to the transcription start site TSS (adjacent to +1)",sep="")))

print(num.Inr.all.tab,type='latex',sanitize.text.function = function(x) {x})

tata.hits.loci.all.long <- data.frame(loci=c(unlist(motif.hits.loci.all[[1]]),
                             unlist(motif.hits.loci.all[[2]]),
                             unlist(motif.hits.loci.all[[3]]),
                             unlist(motif.hits.loci.all[[4]])),
                             area=c(rep('pf',length(unlist(motif.hits.loci.all[[1]]))),
                                     rep('cb',length(unlist(motif.hits.loci.all[[2]]))),
                                     rep('tm',length(unlist(motif.hits.loci.all[[3]]))),
                                     rep('po',length(unlist(motif.hits.loci.all[[4]])))
                                     ))

tata.hits.loci.all.long$area <- factor(tata.hits.loci.all.long$area, levels = c("pf","cb",
                                                                            "tm","po"))
                                           
tata_all.plt <- ggplot(data=tata.hits.loci.all.long[1:length(unlist(motif.hits.loci.all[[1]])),], aes(loci[1:length(unlist(motif.hits.loci.all[[1]]))])) +
     geom_histogram(binwidth=2,color='blue') +
     theme_tufte() +
     theme(panel.grid.major = element_blank(),
           panel.grid.minor = element_blank()
           ) +
     theme(title =element_text(size=9))   +
     labs(title="Positions of TATA Consensus Sequence Promoter Motifs Across All COMT-Correlated Genes") +
     theme(plot.title = element_text(hjust = 0.5))   +
     scale_color_brewer(palette="Set1")   +
     scale_y_continuous(limits=c(0,100),breaks=c(seq(0,100,20)),expand=c(0.01,0)) +
     scale_x_continuous(breaks=c(-250,-200,-150,-100,-50,-30,0,50,100,150),
                        labels=c(as.character(seq(-250,-50,50)),'-30','+1',as.character(seq(50,150,50))))  +
     theme(axis.title = element_text(size = 11))   +
     theme(axis.line = element_line(color="gray75", size = 0.5))   +
     xlab(label = c('Position'))   +
     geom_vline(xintercept = c(-30),size=c(0.5),color='red',linetype='dashed')  +
     ylab(label=c('Frequency'))  + 
     annotate("text", x = c(-180), y = c(80),
              label = c('TATA consensus sequence: T-A-T-A-W-A-W-N'),
              size = 2.5,
              color='black') +
          
     annotate("text", x = c(-185), y = c(75),
              label = c('Example TATA sequence T-A-T-A-A-A-T-C'),
              size = 2.5,
              color='black') 
tata_all.plt

ggsave("/Volumes/Macintosh_HD_3/genetics/genenetwork2/new_plots/TATA_motif_positions_all_COMT_genes.pdf",plot=tata_all.plt,device="pdf",
       scale=2,
       dpi=300,
       width=6.0,
       height=3.0,
       units=c('in')
)




@

<<TATA.pos>>=
# 'TATA[TA]A[TA][ACGT]'

motif.Inr <- c('TATA[TA]A[TA][ACGT]'
               )
loc.lims.t <- c(-250,150)
loc.lims <- 1000 + loc.lims.t

motif.hits.loci <- list()
num.Inr.pos <- matrix(rep(NA,8),ncol=2)
for (im in ib)   {
     
     num.Inr.pos[im,2] <- c(dim(proms.pos[[im]])[1])
     at.least <- matrix(rep(NA,dim(proms.pos[[im]])[1]),ncol=1)
     loc.hits <- list()
     
     for (ai in 1:1)      {
               
          loc.hits.temp <- c(0)
     
          grep.temp <- c(NA)
          
          for (kh in 1:dim(proms.pos[[im]])[1])     {
          
               cat(paste('brain area ',im,' gene ',kh,' \n',sep=''))
          
               grep.temp <- gregexpr(motif.Inr[ai],substr(proms.pos[[im]][kh],loc.lims[1],loc.lims[2]))

          if (grep.temp[[1]][1] > 0) {
               
               at.least[kh,ai] <- c(1) # this gene (kh) has at least one hit for this motif (ai)
               loc.hits.temp <- c(loc.hits.temp,
                                 grep.temp[[1]][1:length(grep.temp[[1]])])
          
          }  else {
               
               at.least[kh,ai] <- c(0) 
     
          }
     
               # check the reverse complement
               # substr(reverseComplement(DNAStringSet(proms.pos[[im]][kh])),900,1050)))

     }    # number of genes loop kh
     
          loc.hits[[ai]] <- loc.hits.temp[2:length(loc.hits.temp)] + (loc.lims.t[1] -1)
     
}  # motif type loop ai
     
     motif.hits.loci[[im]] <- loc.hits
     num.Inr.pos[im,1] <- sum(at.least[,1])

} #brain area loop

num.Inr.pos.int <- matrix(rep(NA,4*3),ncol=3)
num.Inr.pos.int[,3] <- num.Inr.pos[,2]
num.Inr.pos.int[,1] <- num.Inr.pos[,1]
num.Inr.pos.int[,2] <- round(100*num.Inr.pos.int[,1]/num.Inr.pos.int[,3],1)
num.Inr.pos.pc <- matrix(rep(NA,2*4),ncol=2)

num.Inr.pos.pc[,2] <- num.Inr.pos.int[,3]
num.Inr.pos.pc[,1] <- c(paste(num.Inr.pos.int[,1],' (',round(num.Inr.pos.int[,2],3),') ',sep=''))

colnames(num.Inr.pos.pc) <- c(expon("TATA8","a"),
                           'Number of Genes')
row.names(num.Inr.pos.pc) <- stand.Col.names.aug

num.Inr.pos.tab <- xtable(num.Inr.pos.pc,
                                caption=c(paste("Number (percentage) of the positive subset of the most highly ",italic("COMT"),"\\den correlated genes in each brain area having at least one instance of the TATA8 motif in the region from -250 to +150 nucleotides relative to the transcription start site TSS (adjacent to +1)",sep="")))

print(num.Inr.pos.tab,type='latex',sanitize.text.function = function(x) {x})

@

<<TATA.neg>>=
# 'TATA[TA]A[TA][ACGT]'

motif.Inr <- c('TATA[TA]A[TA][ACGT]'
               )
loc.lims.t <- c(-250,150)
loc.lims <- 1000 + loc.lims.t

motif.hits.loci <- list()
num.Inr.neg <- matrix(rep(NA,8),ncol=2)
for (im in ib)   {
     
     num.Inr.neg[im,2] <- c(dim(proms.neg[[im]])[1])
     at.least <- matrix(rep(NA,dim(proms.neg[[im]])[1]),ncol=1)
     loc.hits <- list()
     
     for (ai in 1:1)      {
               
          loc.hits.temp <- c(0)
     
          grep.temp <- c(NA)
          
          for (kh in 1:dim(proms.neg[[im]])[1])     {
          
               cat(paste('brain area ',im,' gene ',kh,' \n',sep=''))
          
               grep.temp <- gregexpr(motif.Inr[ai],substr(proms.neg[[im]][kh],loc.lims[1],loc.lims[2]))

          if (grep.temp[[1]][1] > 0) {
               
               at.least[kh,ai] <- c(1) # this gene (kh) has at least one hit for this motif (ai)
               loc.hits.temp <- c(loc.hits.temp,
                                 grep.temp[[1]][1:length(grep.temp[[1]])])
          
          }  else {
               
               at.least[kh,ai] <- c(0) 
     
          }
     
               # check the reverse complement
               # substr(reverseComplement(DNAStringSet(proms.neg[[im]][kh])),900,1050)))

     }    # number of genes loop kh
     
          loc.hits[[ai]] <- loc.hits.temp[2:length(loc.hits.temp)] + (loc.lims.t[1] -1)
     
}  # motif type loop ai
     
     motif.hits.loci[[im]] <- loc.hits
     num.Inr.neg[im,1] <- sum(at.least[,1])

}

num.Inr.neg.int <- matrix(rep(NA,4*3),ncol=3)
num.Inr.neg.int[,3] <- num.Inr.neg[,2]
num.Inr.neg.int[,1] <- num.Inr.neg[,1]
num.Inr.neg.int[,2] <- round(100*num.Inr.neg.int[,1]/num.Inr.neg.int[,3],1)
num.Inr.neg.pc <- matrix(rep(NA,2*4),ncol=2)

num.Inr.neg.pc[,2] <- num.Inr.neg.int[,3]
num.Inr.neg.pc[,1] <- c(paste(num.Inr.neg.int[,1],' (',round(num.Inr.neg.int[,2],3),') ',sep=''))

colnames(num.Inr.neg.pc) <- c(expon("TATA8","a"),
                           'Number of Genes')
row.names(num.Inr.neg.pc) <- stand.Col.names.aug

num.Inr.neg.tab <- xtable(num.Inr.neg.pc,
                                caption=c(paste("Number (percentage) of the negitive subset of the most highly ",italic("COMT"),"\\den correlated genes in each brain area having at least one instance of the TATA8 motif in the region from -250 to +150 nucleotides relative to the transcription start site TSS (adjacent to +1)",sep="")))

print(num.Inr.neg.tab,type='latex',sanitize.text.function = function(x) {x})

@

<<summary.TATA>>=
num.Inr.tata.summ <- matrix(rep(NA,4*6),ncol=6)

num.Inr.tata.summ[,1:2] <- num.Inr.neg.pc[,1:2]
num.Inr.tata.summ[,3:4] <- num.Inr.pos.pc[,1:2]
num.Inr.tata.summ[,5:6] <- num.Inr.all.pc[,1:2]

colnames(num.Inr.tata.summ) <- c('Negative','Number of Genes',
                              'Positive','Number of Genes',
                              paste('All ',italic("COMT"),' Genes',sep=''),'Number of Genes')
     
row.names(num.Inr.tata.summ) <- stand.Col.names.aug

num.Inr.tata.summ.tab <- xtable(num.Inr.tata.summ,
                                caption=c(paste("Number (percentage) of the negative subset, positive subset, and all of the ",italic("COMT"),"\\den correlated genes in each brain area having at least one instance of the TATA8 ",expon('motif','a')," in the region from -250 to +150 nucleotides relative to the transcription start site TSS (adjacent to +1)",sep="")))

print(num.Inr.tata.summ.tab,type='latex',sanitize.text.function = function(x) {x})


# hypergeomteric tests pos, neg from all

hyperg.neg <- phyper(num.Inr.neg.int[,1],num.Inr.all.int[,1],(num.Inr.all.int[,3]-num.Inr.all.int[,1]),num.Inr.neg.int[,3],lower.tail=TRUE,log.p=FALSE)
hyperg.pos <- phyper(num.Inr.pos.int[,1],num.Inr.all.int[,1],(num.Inr.all.int[,3]-num.Inr.all.int[,1]),num.Inr.pos.int[,3],lower.tail=TRUE,log.p=FALSE)


num.Inr.tata.hyperg <- matrix(rep(NA,4*8),ncol=8)

num.Inr.tata.hyperg[,1:2] <- num.Inr.neg.pc[,1:2]
num.Inr.tata.hyperg[,3] <- round(hyperg.neg,3)
num.Inr.tata.hyperg[,4:5] <- num.Inr.pos.pc[,1:2]
num.Inr.tata.hyperg[,6] <- round(hyperg.pos,3)
num.Inr.tata.hyperg[,7:8] <- num.Inr.all.pc[,1:2]

colnames(num.Inr.tata.hyperg) <- c('Negative','Number of Genes','p-value',
                              'Positive','Number of Genes','p-value',
                              paste('All ',italic("COMT"),' Genes',sep=''),'Number of Genes')
     
row.names(num.Inr.tata.hyperg) <- stand.Col.names.aug

num.Inr.tata.hyperg.tab <- xtable(num.Inr.tata.hyperg,
                                caption=c(paste("Number (percentage) of the negative subset, positive subset, and all of the ",italic("COMT"),"\\den correlated genes in each brain area having at least one instance of the TATA8 ",expon('motif','a')," in the region from -250 to +150 nucleotides relative to the transcription start site TSS (adjacent to +1). The p-values are derived from hypergeometric tests on the negative and positive subsets given the statistics for all the genes shown in the same rows of the last two columns.",sep="")))

print(num.Inr.tata.hyperg.tab,type='latex',sanitize.text.function = function(x) {x})

@




<<Inr.positive>>=

#### proms.pos[[1]] has the COMT genes as fasta formatted 1600-character entries.
# check region from -100 to + 50
# 1 = [CGT][AT]CA[CGT][AT]
# 2 = [CT][CT]A[ACGT][AT][CT][CT]
# 3 = [C/T][A/G]
num.Inr.pos <- matrix(rep(NA,4*7),ncol=7)

for (im in ib)   {
     
     num.Inr.pos[im,7] <- dim(proms.pos[[im]])[1]
     init.elem.pos.temp <- matrix(rep(NA,3*dim(proms.pos[[im]])[1]),ncol=3)
     
     for (kh in 1:dim(proms.pos[[im]])[1])     {

          cat(paste('brain area ',im,' gene ',kh,' \n',sep=''))
          
               if (gregexpr('[CGT][AT]CA[CGT][AT]',substr(proms.pos[[im]][kh],900,1050))[[1]][1] > 0)   {
                    init.elem.pos.temp[kh,1] <- c(1)
               } else {
                    init.elem.pos.temp[kh,1] <- c(0)
               }
          
               if (gregexpr('[CT][CT]A[ACGT][AT][CT][CT]',substr(proms.pos[[im]][kh],900,1050))[[1]][1] > 0)   {
                    init.elem.pos.temp[kh,2] <- c(1)
               } else {
                    init.elem.pos.temp[kh,2] <- c(0)
               }
          
               if (gregexpr('[C/T][A/G]',substr(proms.pos[[im]][kh],900,1050))[[1]][1] > 0)   {

                    init.elem.pos.temp[kh,3] <- c(1)
               } else {
                    init.elem.pos.temp[kh,3] <- c(0)
               }
               
               # check the reverse complement
               # has.init.elem.rc <- sum(grepl('[CGT][AT]CA[CGT][AT]',substr(reverseComplement(DNAStringSet(proms.pos[[im]][kh])),900,1050)))

     }

     
#    init.elem.pos[im]  <- sum(init.elem.pos.temp)
    num.Inr.pos[im,1] <- sum(init.elem.pos.temp[,1])
    num.Inr.pos[im,3] <- sum(init.elem.pos.temp[,2])
    num.Inr.pos[im,5] <- sum(init.elem.pos.temp[,3])
}


####### run to here ^^^^^

num.Inr.pos.pc <- matrix(rep(NA,4*4),ncol=4)
num.Inr.pos[,c(2,4,6)] <- round(100*num.Inr.pos[,c(1,3,5)]/num.Inr.pos[,7],1)
num.Inr.pos.pc[,4] <- num.Inr.pos[,7] 

num.Inr.pos.pc[,1] <- c(paste(num.Inr.pos[,1],' (',round(num.Inr.pos[,2],3),') ',sep=''))
num.Inr.pos.pc[,2] <- c(paste(num.Inr.pos[,3],' (',round(num.Inr.pos[,4],3),') ',sep=''))
num.Inr.pos.pc[,3] <- c(paste(num.Inr.pos[,5],' (',round(num.Inr.pos[,6],3),') ',sep=''))


colnames(num.Inr.pos.pc) <- c(expon("Inr1","a"),
#                           'Inr2\\$^b\\$',
                            expon("Inr2","b"),
                            expon("Inr3","c"),
                           'Number of Genes')
row.names(num.Inr.pos.pc) <- stand.Col.names.aug



num.Inr.pos.tab <- xtable(num.Inr.pos.pc,
                                caption=c(paste("Number (percentage) of the positive subset of the most highly ",italic("COMT"),"\\den correlated genes in each brain area having at least one instance of each of three different consensus intiator element (Inr) sequences in the region from -100 to + 50 nucleotides relative to the transcription start site TSS (adjacent to +1)",sep="")))

print(num.Inr.pos.tab,type='latex',sanitize.text.function = function(x) {x})


@

<<Inr.negative>>=
# check region from -100 to + 50
# 1 = [CGT][AT]CA[CGT][AT]
# 2 = [CT][CT]A[ACGT][AT][CT][CT]
# 3 = [C/T][A/G]
num.Inr.neg <- matrix(rep(NA,4*7),ncol=7)

for (im in ib)   {
     
     num.Inr.neg[im,7] <- dim(proms.neg[[im]])[1]
     init.elem.neg.temp <- matrix(rep(NA,3*dim(proms.neg[[im]])[1]),ncol=3)
     
     for (kh in 1:dim(proms.neg[[im]])[1])     {

          cat(paste('brain area ',im,' gene ',kh,' \n',sep=''))
          
               if (gregexpr('[CGT][AT]CA[CGT][AT]',substr(proms.neg[[im]][kh],900,1050))[[1]][1] > 0)   {
                    init.elem.neg.temp[kh,1] <- c(1)
               } else {
                    init.elem.neg.temp[kh,1] <- c(0)
               }
          
               if (gregexpr('[CT][CT]A[ACGT][AT][CT][CT]',substr(proms.neg[[im]][kh],900,1050))[[1]][1] > 0)   {
                    init.elem.neg.temp[kh,2] <- c(1)
               } else {
                    init.elem.neg.temp[kh,2] <- c(0)
               }
          
               if (gregexpr('[C/T][A/G]',substr(proms.neg[[im]][kh],900,1050))[[1]][1] > 0)   {

                    init.elem.neg.temp[kh,3] <- c(1)
               } else {
                    init.elem.neg.temp[kh,3] <- c(0)
               }
               
               # check the reverse complement
               # has.init.elem.rc <- sum(grepl('[CGT][AT]CA[CGT][AT]',substr(reverseComplement(DNAStringSet(proms.neg[[im]][kh])),900,1050)))

     }

     
#    init.elem.neg[im]  <- sum(init.elem.neg.temp)
    num.Inr.neg[im,1] <- sum(init.elem.neg.temp[,1])
    num.Inr.neg[im,3] <- sum(init.elem.neg.temp[,2])
    num.Inr.neg[im,5] <- sum(init.elem.neg.temp[,3])
}


####### run to here ^^^^^

num.Inr.neg.pc <- matrix(rep(NA,4*4),ncol=4)
num.Inr.neg[,c(2,4,6)] <- round(100*num.Inr.neg[,c(1,3,5)]/num.Inr.neg[,7],1)
num.Inr.neg.pc[,4] <- num.Inr.neg[,7] 

num.Inr.neg.pc[,1] <- c(paste(num.Inr.neg[,1],' (',round(num.Inr.neg[,2],3),') ',sep=''))
num.Inr.neg.pc[,2] <- c(paste(num.Inr.neg[,3],' (',round(num.Inr.neg[,4],3),') ',sep=''))
num.Inr.neg.pc[,3] <- c(paste(num.Inr.neg[,5],' (',round(num.Inr.neg[,6],3),') ',sep=''))


colnames(num.Inr.neg.pc) <- c(expon("Inr1","a"),
#                           'Inr2\\$^b\\$',
                            expon("Inr2","b"),
                            expon("Inr3","c"),
                           'Number of Genes')
row.names(num.Inr.neg.pc) <- stand.Col.names.aug



num.Inr.neg.tab <- xtable(num.Inr.neg.pc,
                                caption=c(paste("Number (percentage) of the negative subset of the most highly ",italic("COMT"),"\\den correlated genes in each brain area having at least one instance of each of three different consensus intiator element (Inr) sequences in the region from -100 to + 50 nucleotides relative to the transcription start site TSS (adjacent to +1)",sep="")))

print(num.Inr.neg.tab,type='latex',sanitize.text.function = function(x) {x})

@

<<test.Inr.posVneg.chisq>>=

###### Tests of 3 Inr types separately with posVneg x brain area
Inr.chisq <- list()

## B B C A B W
Inr1.df <- data.frame(pos=rep(NA,4),
                        neg=rep(NA,4))

Inr1.df[,1] <- num.Inr.pos[,1]
Inr1.df[,2] <- num.Inr.neg[,1]

row.names(Inr1.df) <- stand.Col.names.lc

Inr.chisq[[1]] <- chisq.test(Inr1.df)

## Y Y A N W Y Y
Inr2.df <- data.frame(pos=rep(NA,4),
                        neg=rep(NA,4))

Inr2.df[,1] <- num.Inr.pos[,3]
Inr2.df[,2] <- num.Inr.neg[,3]

row.names(Inr2.df) <- stand.Col.names.lc

Inr.chisq[[2]] <- chisq.test(Inr2.df)

### Y R
Inr3.df <- data.frame(pos=rep(NA,4),
                        neg=rep(NA,4))

Inr3.df[,1] <- num.Inr.pos[,5]
Inr3.df[,2] <- num.Inr.neg[,5]

row.names(Inr3.df) <- stand.Col.names.lc

Inr.chisq[[3]] <- chisq.test(Inr3.df)

#### test all three Inrs as factor with posVneg x brain area
#                pos  neg
# pf     Inr1    
#        Inr2
#        Inr3     
# cb     Inr1
#        Inr2
#        Inr3
# tm     Inr1
#        Inr2
#        Inr3       
# po     Inr1
#        Inr2
#        Inr3       
       
Inr3types <- matrix(rep(NA,12*2),ncol=2) 
#pf
Inr3types[1,c(1,2)] <- unlist(Inr1.df[1,c(1,2)])
Inr3types[2,c(1,2)] <- unlist(Inr2.df[1,c(1,2)])
Inr3types[3,c(1,2)] <- unlist(Inr3.df[1,c(1,2)])

#cb
Inr3types[4,c(1,2)] <- unlist(Inr1.df[2,c(1,2)])
Inr3types[5,c(1,2)] <- unlist(Inr2.df[2,c(1,2)])
Inr3types[6,c(1,2)] <- unlist(Inr3.df[2,c(1,2)])       

#tm
Inr3types[7,c(1,2)] <- unlist(Inr1.df[3,c(1,2)])
Inr3types[8,c(1,2)] <- unlist(Inr2.df[3,c(1,2)])
Inr3types[9,c(1,2)] <- unlist(Inr3.df[3,c(1,2)])

#po
Inr3types[10,c(1,2)] <- unlist(Inr1.df[4,c(1,2)])
Inr3types[11,c(1,2)] <- unlist(Inr2.df[4,c(1,2)])
Inr3types[12,c(1,2)] <- unlist(Inr3.df[4,c(1,2)])

Inr2types <- Inr3types[c(1,2,4,5,7,8,10,11),]

# Transform the ftable into a 4 x 3 x 2 array
# First dimension: brain area
# Second dimension: Inr type
# Third dimension: valence

library(stats)
 mtx3D <- aperm(array(t(as.matrix(Inr2types)),c(2,2,4)),c(3,2,1))
 
 mantelhaen.test(mtx3D)

@



<<dinucleotides>>=


seq.df.pos <- data.frame(seq=unlist(proms.pos[[1]])[960:1010],
                         pwms=pwms.site.pos[[1]]$V1)

seq.df.pos <- seq.df.pos[order(seq.df.pos$pwms),]

plotPatternDensityMap(proms.pos.p[[1]],
             c("CA"),
             flankUp = 40, flankDown = 10, useMulticore = TRUE, nrCores = 4)

@




<<dinucleotides.nearTSS>>=

# Around TSS put the DNA sequence for each gene aligned at TSS

dinucl.nearTSS <- list()
dinucl.nearTSS.temp <- list()
datset <- list(all=proms.all,
               pos=proms.pos,
               neg=proms.neg)

for (hk in 1:length(datset))     {
     for (im in ib)   {

          dinucl.nearTSS.temp[[im]] <- addmargins(table(substr(datset[[hk]][[im]],1000,1000),substr(datset[[hk]][[im]],1001,1001)))
     
     }
     
     dinucl.nearTSS[[hk]] <- dinucl.nearTSS.temp
     
}

find_cell <- function(table, row, col, name="core-fg"){
  l <- table$layout
  which(l$t==row & l$l==col & l$name==name)
}

ttm<- ttheme_minimal(base_size = 6, base_colour = "black", base_family = "",
  parse = FALSE, padding = unit(c(4, 4), "mm"))

allpf <- dinucl.nearTSS[[1]][[1]]
pospf <- dinucl.nearTSS[[2]][[1]]
negpf <- dinucl.nearTSS[[3]][[1]]
allcb <- dinucl.nearTSS[[1]][[2]]
poscb <- dinucl.nearTSS[[2]][[2]]
negcb <- dinucl.nearTSS[[3]][[2]]
alltm <- dinucl.nearTSS[[1]][[3]]
postm <- dinucl.nearTSS[[2]][[3]]
negtm <- dinucl.nearTSS[[3]][[3]]
allpo <- dinucl.nearTSS[[1]][[4]]
pospo <- dinucl.nearTSS[[2]][[4]]
negpo <- dinucl.nearTSS[[3]][[4]]

tallpf <- tableGrob(allpf, theme=ttm)
tpospf <- tableGrob(pospf, theme=ttm)
tnegpf <- tableGrob(negpf, theme=ttm)
tallcb <- tableGrob(allcb, theme=ttm)
tposcb <- tableGrob(poscb, theme=ttm)
tnegcb <- tableGrob(negcb, theme=ttm)
talltm <- tableGrob(alltm, theme=ttm)
tpostm <- tableGrob(postm, theme=ttm)
tnegtm <- tableGrob(negtm, theme=ttm)
tallpo <- tableGrob(allpo, theme=ttm)
tpospo <- tableGrob(pospo, theme=ttm)
tnegpo <- tableGrob(negpo, theme=ttm)

g <- grid.arrange(
  tallpf, tpospf,tnegpf,
  tallcb, tposcb,tnegcb,
  nrow=2,padding = unit(0.1, "line")
  )

h <- grid.arrange(
  talltm, tpostm,tnegtm,
  tallpo, tpospo,tnegpo,
  nrow=2,padding = unit(0.1, "line")
  )


grid.draw(g)
grid.draw(h)


near.TSS.posVneg.pf <- rbind(dinucl.nearTSS[[2]][[1]][1:4,1:4],
                              dinucl.nearTSS[[3]][[1]][1:4,1:4])

near.TSS.posVneg.cb <- rbind(dinucl.nearTSS[[2]][[2]][1:4,1:4],
                              dinucl.nearTSS[[3]][[2]][1:4,1:4])

near.TSS.posVneg.tm <- rbind(dinucl.nearTSS[[2]][[3]][1:4,1:4],
                              dinucl.nearTSS[[3]][[3]][1:4,1:4])

near.TSS.posVneg.po <- rbind(dinucl.nearTSS[[2]][[4]][1:4,1:4],
                              dinucl.nearTSS[[3]][[4]][1:4,1:4])

library(stats)
 mtx3D <- aperm(array(t(as.matrix(near.TSS.posVneg.pf)),c(4,4,2)),c(2,1,3))
 
 mantelhaen.test(mtx3D)
 
 
 # Put posVneg in long form
 
near.TSS.posVneg.pf.long <- stack(near.TSS.posVneg.pf)

near.TSS.posVneg.pf.long[,3] <- rep(rep(c('pos','neg'),each=4),4)

colnames(near.TSS.posVneg.pf.long) <- c('TSSp1','TSSm1','Valence','Count')
near.TSS.posVneg.pf.long <- data.frame(near.TSS.posVneg.pf.long)

near.TSS.posVneg.pf.long$TSSp1 <- as.factor(near.TSS.posVneg.pf.long$TSSp1)
near.TSS.posVneg.pf.long$TSSm1 <- as.factor(near.TSS.posVneg.pf.long$TSSm1)
near.TSS.posVneg.pf.long$Valence <- as.factor(near.TSS.posVneg.pf.long$Valence)

str(near.TSS.posVneg.pf.long)
# 'data.frame':	32 obs. of  4 variables:
#  $ TSSp1  : Factor w/ 4 levels "A","C","G","T": 1 2 3 4 1 2 3 4 1 2 ...
#  $ TSSm1  : Factor w/ 4 levels "A","C","G","T": 1 1 1 1 1 1 1 1 2 2 ...
#  $ Valence: Factor w/ 2 levels "neg","pos": 2 2 2 2 1 1 1 1 2 2 ...
#  $ Count  : num  8 54 15 21 2 45 7 8 7 35 ...

# Convert to Table

tab.temp <- xtabs(Count ~ TSSp1 + TSSm1 + Valence,
              data=near.TSS.posVneg.pf.long)

ftable(tab.temp)

mantelhaen.test(tab.temp)

# 	Cochran-Mantel-Haenszel test
# 
# data:  tab.temp
# Cochran-Mantel-Haenszel M^2 = 35.208312, df = 9,
# p-value = 0.00005474671

## Repeat for other areas
## Cerebellum

near.TSS.posVneg.cb <- rbind(dinucl.nearTSS[[2]][[2]][1:4,1:4],
                              dinucl.nearTSS[[3]][[2]][1:4,1:4])
near.TSS.posVneg.cb.long <- stack(near.TSS.posVneg.cb)

near.TSS.posVneg.cb.long[,3] <- rep(rep(c('pos','neg'),each=4),4)

colnames(near.TSS.posVneg.cb.long) <- c('TSSp1','TSSm1','Valence','Count')
near.TSS.posVneg.cb.long <- data.frame(near.TSS.posVneg.cb.long)

near.TSS.posVneg.cb.long$TSSp1 <- as.factor(near.TSS.posVneg.cb.long$TSSp1)
near.TSS.posVneg.cb.long$TSSm1 <- as.factor(near.TSS.posVneg.cb.long$TSSm1)
near.TSS.posVneg.cb.long$Valence <- as.factor(near.TSS.posVneg.cb.long$Valence)

str(near.TSS.posVneg.cb.long)
# 'data.frame':	32 obs. of  4 variables:
#  $ TSSp1  : Factor w/ 4 levels "A","C","G","T": 1 2 3 4 1 2 3 4 1 2 ...
#  $ TSSm1  : Factor w/ 4 levels "A","C","G","T": 1 1 1 1 1 1 1 1 2 2 ...
#  $ Valence: Factor w/ 2 levels "neg","pos": 2 2 2 2 1 1 1 1 2 2 ...
#  $ Count  : num  8 54 15 21 2 45 7 8 7 35 ...

# Convert to Table

tab.temp <- xtabs(Count ~ TSSp1 + TSSm1 + Valence,
              data=near.TSS.posVneg.cb.long)

ftable(tab.temp)

mantelhaen.test(tab.temp)



## Temporal Cortex

near.TSS.posVneg.tm <- rbind(dinucl.nearTSS[[2]][[3]][1:4,1:4],
                              dinucl.nearTSS[[3]][[3]][1:4,1:4])
near.TSS.posVneg.tm.long <- stack(near.TSS.posVneg.tm)

near.TSS.posVneg.tm.long[,3] <- rep(rep(c('pos','neg'),each=4),4)

colnames(near.TSS.posVneg.tm.long) <- c('TSSp1','TSSm1','Valence','Count')
near.TSS.posVneg.tm.long <- data.frame(near.TSS.posVneg.tm.long)

near.TSS.posVneg.tm.long$TSSp1 <- as.factor(near.TSS.posVneg.tm.long$TSSp1)
near.TSS.posVneg.tm.long$TSSm1 <- as.factor(near.TSS.posVneg.tm.long$TSSm1)
near.TSS.posVneg.tm.long$Valence <- as.factor(near.TSS.posVneg.tm.long$Valence)

str(near.TSS.posVneg.tm.long)
# 'data.frame':	32 obs. of  4 variables:
#  $ TSSp1  : Factor w/ 4 levels "A","C","G","T": 1 2 3 4 1 2 3 4 1 2 ...
#  $ TSSm1  : Factor w/ 4 levels "A","C","G","T": 1 1 1 1 1 1 1 1 2 2 ...
#  $ Valence: Factor w/ 2 levels "neg","pos": 2 2 2 2 1 1 1 1 2 2 ...
#  $ Count  : num  8 54 15 21 2 45 7 8 7 35 ...

# Convert to Table

tab.temp <- xtabs(Count ~ TSSp1 + TSSm1 + Valence,
              data=near.TSS.posVneg.tm.long)

ftable(tab.temp)

mantelhaen.test(tab.temp)


## Pons

near.TSS.posVneg.po <- rbind(dinucl.nearTSS[[2]][[4]][1:4,1:4],
                              dinucl.nearTSS[[3]][[4]][1:4,1:4])
near.TSS.posVneg.po.long <- stack(near.TSS.posVneg.po)

near.TSS.posVneg.po.long[,3] <- rep(rep(c('pos','neg'),each=4),4)

colnames(near.TSS.posVneg.po.long) <- c('TSSp1','TSSm1','Valence','Count')
near.TSS.posVneg.po.long <- data.frame(near.TSS.posVneg.po.long)

near.TSS.posVneg.po.long$TSSp1 <- as.factor(near.TSS.posVneg.po.long$TSSp1)
near.TSS.posVneg.po.long$TSSm1 <- as.factor(near.TSS.posVneg.po.long$TSSm1)
near.TSS.posVneg.po.long$Valence <- as.factor(near.TSS.posVneg.po.long$Valence)

str(near.TSS.posVneg.po.long)
# 'data.frame':	32 obs. of  4 variables:
#  $ TSSp1  : Factor w/ 4 levels "A","C","G","T": 1 2 3 4 1 2 3 4 1 2 ...
#  $ TSSm1  : Factor w/ 4 levels "A","C","G","T": 1 1 1 1 1 1 1 1 2 2 ...
#  $ Valence: Factor w/ 2 levels "neg","pos": 2 2 2 2 1 1 1 1 2 2 ...
#  $ Count  : num  8 54 15 21 2 45 7 8 7 35 ...

# Convert to Table

tab.temp <- xtabs(Count ~ TSSp1 + TSSm1 + Valence,
              data=near.TSS.posVneg.po.long)

ftable(tab.temp)

mantelhaen.test(tab.temp)








@



<<signif.PWM>>=

#fasta.MI <- MolecularMI(fasta.by.lett,'DNA')

# Use resampling to evaluate the statistical significance of the PWMs for the loci from -40 to +10. Do this in an area-specific manner.

# See Xia (2012)

# site-specific PWMs for sites from -40 to +10 for the complete set of genes (that have complete information)

# all_genes.lett.freq[[im]] For a given area this is 4 x 51. 4 bases by 51 sites.

# as the background site-specific proportions, use promoter_seq. This has the -1000 to +600 sequences of all genes in the human genome (23,056 genes)

# all_genes.lett.freq[[1]]    All genes that were analyzed in the COMT project

pwn.by.site.temp <- matrix(rep(NA,4*length(subseq)),ncol=4)
pwm.by.site <- matrix(rep(NA,5*(length(subseq) + 1),ncol=5))
for (kj in subseq)   {

     which(substr(as.character(promoter_seq),kj,kj) == 'N')
     
     temp.tab <- table(substr(as.character(promoter_seq),kj,kj))
     
     if (dim(temp.tab) > 4) {
          
          temp.tab <- temp.tab[c(1:3,5)]
     
     } else {
          
     }
     
     pwn.by.site.temp[(kj - (subseq[1] - 1)),] <-  temp.tab
}

     pwm.by.site <- prop.table(pwn.by.site.temp,margin=1)
     pwm.by.site <- data.frame(pwm.by.site)
     colnames(pwm.by.site) <- DNA_BASES
     pwm.by.site$site <- c(-40:10)
     
### pwm.by.site holds the PWM for -40 to + 10 (re: TSS) for all promoters in the human genome 
     
#### Compute a proper PWM by taking the log2 of the ratio of the probability at a given site for some defined subset of genes to the probability at that site in the background set.
     
log2.PWM.pos <- lapply(pwm_pos_comt_genes[ib], function(x,ib) log2(x[,1:4]/pwm.by.site[,1:4]),
                       ib)
log2.PWM.neg <- lapply(pwm_neg_comt_genes[ib], function(x,ib) log2(x[,1:4]/pwm.by.site[,1:4]),
                       ib)
     
log2.PWM.all <- lapply(pwm_all_comt_genes[ib], function(x,ib) log2(x[,1:4]/pwm.by.site[,1:4]),
                       ib)  

### Compute the PWMScores for pos, neg and all for all areas

#### positive   # fasta.by.lett.pos

code.base <- data.frame(nums=c(1,2,3,4))
row.names(code.base) <- DNA_BASES

comp.num.genes <- matrix(c(length(proms.pos[[1]]),length(proms.pos.entrez[[1]]),
                         length(proms.pos[[2]]),length(proms.pos.entrez[[2]]),
                         length(proms.pos[[3]]),length(proms.pos.entrez[[3]]),
                         length(proms.pos[[4]]),length(proms.pos.entrez[[4]])),
                         ncol=2,byrow=TRUE
                         )



pwms.site.pos <- list()

     for (im in ib) {
          
          pwms.site.pos.temp <- data.frame(pwm.score=c(rep(NA,length(sseq))))
          
          for (lc in sseq2)   {
               
               aug.pwms <- data.frame(pwmScore=c(rep(NA,length(proms.pos[[1]]))))
           
          for (dk in 1:length(proms.pos[[im]])) { # genes
     
               aug.pwms[dk] <- as.numeric(sum(pwm.by.site[dk,code.base[unlist(fasta.by.lett.pos[[im]][dk])[lc], ]]))
               
          }
               
               pwms.site.pos.temp[lc] <- aug.pwms
          }    
     }


#### negative   # fasta.by.lett.neg

code.base <- data.frame(nums=c(1,2,3,4))
row.names(code.base) <- DNA_BASES

comp.num.genes <- matrix(c(length(proms.neg[[1]]),length(proms.neg.entrez[[1]]),
                         length(proms.neg[[2]]),length(proms.neg.entrez[[2]]),
                         length(proms.neg[[3]]),length(proms.neg.entrez[[3]]),
                         length(proms.neg[[4]]),length(proms.neg.entrez[[4]])),
                         ncol=2,byrow=TRUE
                         )

pwms.site.neg <- list()

     for (im in ib) {
          
          aug.pwms <- data.frame(pwmScore=c(),
                                 entrez=c(),
                                 strand=c()
          )
          
          for (dk in 1:length(proms.neg[[im]])) { # genes
     
               aug.pwms[dk,1] <- as.numeric(sum(pwm.by.site[dk,code.base[unlist(fasta.by.lett.neg[[im]][dk])[sseq], ]]))
               aug.pwms[dk,2] <- proms.neg.entrez[[im]][dk]
               aug.pwms[dk,3] <- proms.neg.strand[[im]][dk]
               
          }
               
               pwms.site.neg[[im]] <- aug.pwms
               
     }




out.t.test <- list()
for (im in ib) {
     
     out.t.test[[im]] <- t.test(pwms.site.pos[[im]]$V1,pwms.site.neg[[im]]$V1,var.equal = FALSE)
     
}
out.t.test

  
     
     
# pwm_pos_comt_genes[[im]]  holds the pwms for the positive subset

     ## all refers to all comt genes     
     gene.samp_sizes.pos <- lapply(seq.pos.fasta[ib], function(x,ib) length(x), ib)
     gene.samp_sizes.neg <- lapply(seq.neg.fasta[ib], function(x,ib) length(x), ib)
     gene.samp_sizes.all <- lapply(proms.all[ib], function(x,ib) length(x), ib)

#    obs.freq <- gene.samp_sizes.pos[[1]]*pwm_pos_comt_genes[[1]][,1:4] 
     exp.freq <- gene.samp_sizes.pos[[1]]*pwm.by.site[,1:4]
#     obs.freq <- gene.samp_sizes.pos[[1]]*pwm.by.site[,1:4]
     obs.freq <- gene.samp_sizes.pos[[1]]*pwm_neg_comt_genes[[1]][,1:4]

     chsq.out <- list()     
     
     for (tf in 1:length(subseq))  {
  
     test.1 <- matrix(c(unlist(obs.freq[tf,]),unlist(exp.freq[tf,])),ncol=4,byrow=TRUE)
          chsq.out[[tf]] <- chisq.test(test.1)
     }     

     site.range <- sseq1
#     st.l <- c(1:length(subseq))
     st.l <- -(site.range[1] -1) + site.range
     out.pvals <- matrix(rep(NA,4*length(st.l)),ncol=4)
     out.pvals[,2] <- matrix(unlist(lapply(chsq.out[st.l], function(x,st.l) x$p.value, st.l)),ncol=1)
#     out.pvals[,1] <- c(-40:10)
     
     out.pvals[,1] <- st.l
     
     pcrit <- c(.05)
     nt <- length(st.l)                   # length(subseq)
     sorted.pvals <- data.frame(matrix(rep(NA,5*nrow(out.pvals)),ncol=5))
     
     sorted.pvals[,1:4] <- out.pvals[order(out.pvals[,2]),]
     sorted.pvals[,4] <- c(1:nrow(sorted.pvals))
     sorted.pvals[,3] <- pcrit*sorted.pvals[,4]/nt
     sorted.pvals[,5] <- c(rep('',nrow(sorted.pvals)))
     
     for (jn in 1:nrow(sorted.pvals)) {
     
          if (sorted.pvals[jn,2] < sorted.pvals[jn,3]) {
               
               sorted.pvals[jn,5] <- c('*')
          }  else {
               
          }
          
     }     
     sorted.pvals

@






<<tata_box>>=
# Concensus sequence
     # TATA(A/T)A(A/T)(A/G) (TATAWAWR)
     # initial T is at -30 re: TSS
     # T    A    T    A    (A/T)    A    (A/T)    (A/G)
      -30  -29  -28  -27  -26     -25    -24     -23
     # T    A    T    A    A       A      A       A
     # T    A    T    A    A       A      A       G
     # T    A    T    A    A       A      T       A
     # T    A    T    A    A       A      T       G
     # T    A    T    A    T       A      A       A
     # T    A    T    A    T       A      A       G
     # T    A    T    A    T       A      T       A
     # T    A    T    A    T       A      T       G
     
tata.seq.mtx <- matrix(c('T',    'A',    'T',    'A',    'A',       'A',      'A',       'A',
                         'T',    'A',    'T',    'A',    'A',       'A',      'A',       'G',
                         'T',    'A',    'T',    'A',    'A',       'A',      'T',       'A',
                         'T',    'A',    'T',    'A',    'A',       'A',      'T',       'G',
                         'T',    'A',    'T',    'A',    'T',       'A',      'A',       'A',
                         'T',    'A',    'T',    'A',    'T',       'A',      'A',       'G',
                         'T',    'A',    'T',    'A',    'T',       'A',      'T',       'A',
                         'T',    'A',    'T',    'A',    'T',       'A',      'T',       'G' ),
                   ncol = 8, byrow=TRUE)
     

refgene <- makeTxDbFromUCSC(genome="hg19", tablename="refGene") 
transcripts <- transcripts(refgene, columns=c("tx_id", "tx_name")) 
tss <- resize(transcripts, width=1, fix='start')


     
     
     
@

<<dinucleotides>>=


seq.df.pos <- data.frame(seq=proms.pos.p[[1]],
                         pwms=pwms.site.pos[[1]]$V1)

seq.df.pos <- seq.df.pos[order(seq.df.pos$pwms),]

plotPatternDensityMap(proms.pos.p[[1]],
             c("AA", "TA", "CG", "GC"),
             flankUp = 400, flankDown = 800, useMulticore = TRUE, nrCores = 4)





@



<<cpg.islands>>=

##################################################################

# From Top 500 run all, positive only and negative only
# First get overall G and C content separately, then get 'CG'
# Only use -1000 to 0 of promoter sequence (the part 5' to TSS)

gc.sep.stats <- list()
cpg.stats <- list()
comp.cpg.stats <- list()
tot.promoters <- list()

seq.pos.fasta <- promoters.fasta$pos
seq.neg.fasta <- promoters.fasta$neg

wp.promoter.set <- list(pos=seq.pos.fasta,                        # all=seq.fasta,
                     neg=seq.neg.fasta)


# unlist(promoters.fasta$pos)

     
# Divide -1000 to 0 promoter sequence into n (even) equal bp sequences
crit.vals <- c(0.50, 0.60)
num.bp <- c(5)
len.seq <- nchar(substr(wp.promoter.set$pos[[1]][[1]],1,1000))/num.bp

for (wp in 1:2)   {
     
     promoter.set <- wp.promoter.set[[wp]]   # 1=pos   2=neg

for (im in ib)   {
     
     
     gc.sep <- list(obs.c=matrix(rep(0,num.bp*length(promoter.set[[im]])),ncol=num.bp),
                          obs.g=matrix(rep(0,num.bp*length(promoter.set[[im]])),ncol=num.bp),
                          obs.cg=matrix(rep(0,num.bp*length(promoter.set[[im]])),ncol=num.bp))

     obs.exp.cg <- list(cperc=matrix(rep(0,num.bp*length(promoter.set[[im]])),ncol=num.bp),
                              gperc=matrix(rep(0,num.bp*length(promoter.set[[im]])),ncol=num.bp),
                              cg.exp=matrix(rep(0,num.bp*length(promoter.set[[im]])),ncol=num.bp),
                              cg.obs=matrix(rep(0,num.bp*length(promoter.set[[im]])),ncol=num.bp),
                              ratio=matrix(rep(0,num.bp*length(promoter.set[[im]])),ncol=num.bp),
                              cpg.island=matrix(rep(0,num.bp*length(promoter.set[[im]])),ncol=num.bp)
                                   )
for (sp in 1:num.bp)   {
          
     for (kj in 1:length(promoter.set[[im]]))   {
          
          sp.start <- (len.seq*(sp - 1) + 1)
          sp.end <- len.seq*sp
          temp.string <- substr(promoter.set[[im]][kj],sp.start,sp.end)
          gc.sep$obs.c[kj,sp] <- length(gregexpr('C',temp.string)[[1]])
          gc.sep$obs.g[kj,sp] <- length(gregexpr('G',temp.string)[[1]])
          gc.sep$obs.cg[kj,sp] <- length(gregexpr('CG',temp.string)[[1]])
          obs.exp.cg$cperc[kj,sp] <- gc.sep$obs.c[kj,sp]/len.seq
          obs.exp.cg$gperc[kj,sp] <- gc.sep$obs.g[kj,sp]/len.seq
          obs.exp.cg$cg.exp[kj,sp] <- ((gc.sep$obs.c[kj,sp])*(gc.sep$obs.g[kj]))/len.seq
          obs.exp.cg$cg.obs[kj,sp] <- gc.sep$obs.cg[kj,sp]
          obs.exp.cg$ratio[kj,sp] <- obs.exp.cg$cg.obs[kj,sp]/obs.exp.cg$cg.exp[kj,sp]
          
          temp.gc <- obs.exp.cg$cperc[kj,sp] + obs.exp.cg$gperc[kj,sp]
          if (temp.gc >= crit.vals[1] & obs.exp.cg$ratio[kj,sp] >= crit.vals[2]) {
               obs.exp.cg$cpg.island[kj,sp] <- TRUE
               
          } else {
               obs.exp.cg$cpg.island[kj,sp] <- FALSE
          }
          
     } # end number of promoter.set promoters

     
} # end split promoter into -1000 to -501 and -500 to 0
     
     gc.sep.stats[[im]] <- gc.sep
     cpg.stats[[im]] <- obs.exp.cg
     
} # end brain area loop

     comp.cpg.stats[[wp]] <- cpg.stats

}

tot.promoters <- data.frame(pos=rep(0,4),
                            neg=rep(0,4))

tot.promoters$pos <- unlist(lapply(wp.promoter.set[[1]][ib], function(x,ib) length(x), ib))
tot.promoters$neg <- unlist(lapply(wp.promoter.set[[2]][ib], function(x,ib) length(x), ib))


perc.cpg <- list()

for (im in ib)   {
     
     temp.cpg <- matrix(rep(0,3*num.bp),ncol=num.bp)   

          for (hj in 1:3)   {
               temp.cpg[hj,1:num.bp] <- colSums(comp.cpg.stats[[hj]][[im]]$cpg.island)/tot.promoters[[hj]][im]

          }

     perc.cpg[[im]] <- temp.cpg
}

prop.test(c(colSums(comp.cpg.stats[[1]][[1]]$cpg.island)[5],
            colSums(comp.cpg.stats[[2]][[1]]$cpg.island)[5]),
          c(tot.promoters[[1]][1],
            tot.promoters[[2]][1]),
          alternative="two.sided")


###### Use sliding window

##################################################################

# From Top 500 run all, positive only and negative only
# First get overall G and C content separately, then get 'CG'
# Only use -1000 to 0 of promoter sequence (the part 5' to TSS)

gc.sep.stats <- list()
cpg.stats <- list()
comp.cpg.stats <- list()
tot.promoters <- list()

wp.promoter.set <- list(all=seq.fasta,
                     pos=seq.pos.fasta,
                     neg=seq.neg.fasta)

     
# Divide -1000 to 0 promoter sequence into n (even) equal bp sequences
crit.vals <- c(0.50, 0.60)
inc.bp <- c(1)  # increment in base pairs
wind.size <- c(200)  # bp
len.seq <- nchar(promoter.set[[1]][1])
n.s <- (len.seq - wind.size)/inc.bp

for (wp in 1:3)   {
     
     promoter.set <- wp.promoter.set[[wp]]   # 1=all, 2 = neg, 3 = neg

for (im in ib)   {
     
     
     gc.sep <- list(obs.c=matrix(rep(0,(n.s + 1)*length(promoter.set[[im]])),ncol=(n.s + 1)),
                    obs.g=matrix(rep(0,(n.s + 1)*length(promoter.set[[im]])),ncol=(n.s + 1)),
                    obs.cg=matrix(rep(0,(n.s + 1)*length(promoter.set[[im]])),ncol=(n.s + 1)))

     obs.exp.cg <- list(cperc=matrix(rep(0,(n.s + 1)*length(promoter.set[[im]])),ncol=(n.s + 1)),
                         gperc=matrix(rep(0,(n.s + 1)*length(promoter.set[[im]])),ncol=(n.s + 1)),
                         cg.exp=matrix(rep(0,(n.s + 1)*length(promoter.set[[im]])),ncol=(n.s + 1)),
                         cg.obs=matrix(rep(0,(n.s + 1)*length(promoter.set[[im]])),ncol=(n.s + 1)),
                         ratio=matrix(rep(0,(n.s + 1)*length(promoter.set[[im]])),ncol=(n.s + 1)),
                         cpg.island=matrix(rep(0,(n.s + 1)*length(promoter.set[[im]])),ncol=(n.s + 1))
                                   )
for (sp in 1:(n.s + 1))   {
          
     for (kj in 1:length(promoter.set[[im]]))   {
          
          
          
          cat(paste('valence: ',wp,', area: ',im,', sp: ',sp,', gene: ',kj,' \n ',sep=''))
          
          sp.start <- sp
          sp.end <- sp + (wind.size - 1)
          temp.string <- substr(promoter.set[[im]][kj],sp.start,sp.end)
          gc.sep$obs.c[kj,sp] <- length(gregexpr('C',temp.string)[[1]])
          gc.sep$obs.g[kj,sp] <- length(gregexpr('G',temp.string)[[1]])
          gc.sep$obs.cg[kj,sp] <- length(gregexpr('CG',temp.string)[[1]])
          obs.exp.cg$cperc[kj,sp] <- gc.sep$obs.c[kj,sp]/wind.size
          obs.exp.cg$gperc[kj,sp] <- gc.sep$obs.g[kj,sp]/wind.size
          obs.exp.cg$cg.exp[kj,sp] <- ((gc.sep$obs.c[kj,sp])*(gc.sep$obs.g[kj]))/wind.size
          obs.exp.cg$cg.obs[kj,sp] <- gc.sep$obs.cg[kj,sp]
          obs.exp.cg$ratio[kj,sp] <- obs.exp.cg$cg.obs[kj,sp]/obs.exp.cg$cg.exp[kj,sp]
          
          temp.gc <- obs.exp.cg$cperc[kj,sp] + obs.exp.cg$gperc[kj,sp]
          if (temp.gc >= crit.vals[1] & obs.exp.cg$ratio[kj,sp] >= crit.vals[2]) {
               obs.exp.cg$cpg.island[kj,sp] <- TRUE
               
          } else {
               obs.exp.cg$cpg.island[kj,sp] <- FALSE
          }
          
     } # end number of promoter.set promoters

     
} # end split promoter into -1000 to -501 and -500 to 0
     
     gc.sep.stats[[im]] <- gc.sep
     cpg.stats[[im]] <- obs.exp.cg
     
} # end brain area loop

     comp.cpg.stats[[wp]] <- cpg.stats

}

################# HERE July 4

tot.promoters <- data.frame(all=rep(0,4),
                            pos=rep(0,4),
                            neg=rep(0,4))

tot.promoters$all <- unlist(lapply(wp.promoter.set[[1]][ib], function(x,ib) length(x), ib))
tot.promoters$pos <- unlist(lapply(wp.promoter.set[[2]][ib], function(x,ib) length(x), ib))
tot.promoters$neg <- unlist(lapply(wp.promoter.set[[3]][ib], function(x,ib) length(x), ib))

perc.cpg <- list(all=list(),
                 pos=list(),
                 neg=list(),
                 bp=list())

for (im in ib)   {
     
     temp.cpg <- matrix(rep(0,3*(n.s + 1)),ncol=(n.s + 1))   

          for (hj in 1:3)   {
               temp.cpg[hj,1:(n.s + 1)] <- colSums(comp.cpg.stats[[hj]][[im]]$cpg.island)/tot.promoters[[hj]][im]

          }
     
     perc.cpg$all[[im]] <- temp.cpg[1,]
     perc.cpg$neg[[im]] <- temp.cpg[2,]
     perc.cpg$neg[[im]] <- temp.cpg[3,]
     perc.cpg$bp[[im]] <- seq(-900,500,1)

}

# Find contiguous runs of CpG islands

# Restrict analysis to window within -200 bp of TSS
     restrict.val <- c(200)
     restrict.window <- c(seq(1000-restrict.val,1000,1))

cpg.dist <- list()
cpg.dist.area <- list()
cpg.dist.area.temp <- list()

for (pn in 1:3)  {
for (im in ib)  {


     ########## DEBUG ############
    # im <- c(1)
    # pn <- c(2)
     ########## END DEBUG ########     
     max.cpg.run <- matrix(rep(0,5*tot.promoters[[pn]][im]),ncol=5)
     colnames(max.cpg.run) <- c('maxCpG','most.3prime.negition','num.CpG.islands','maxCpGbp',
                                'at.least.1.cpg')
for (gy in 1:tot.promoters[[pn]][im])  {

     ########## DEBUG ############
    # gy <- c(2)
     ########## END DEBUG ########  
     
#     temp.rle <- rle(as.logical(comp.cpg.stats[[pn]][[im]]$cpg.island[gy,]))
     

     temp.rle <- rle(as.logical(comp.cpg.stats[[pn]][[im]]$cpg.island[gy,restrict.window]))
     lengths <- temp.rle$lengths
     vals <- temp.rle$values
     
     # Is there a run of TRUE?
     any.true <- FALSE
     for (ij in 1:length(vals)) {
          if (vals[ij])  {
               any.true= TRUE
          } else {
               
          }
     }
     
     # This is necessary to ensure that the max run is a run of TRUE
     if (length(vals) == 1 & !any.true)  {
          
     }  else {
     
          is_max <- which(lengths == max(lengths[temp.rle$values]) & temp.rle$values)
          temp2.rle <- rep(1:length(lengths) == is_max[1], lengths)
          max.cpg.run[gy,1] <- sum(temp2.rle)
#          max.cpg.run[gy,3] <- length(lengths[vals][lengths[vals] >= 200])
          max.cpg.run[gy,3] <- length(lengths[vals])
          max.cpg.run[gy,2] <- max(which(temp2.rle))  # most 3' negition of longest CpG  
          max.cpg.run[gy,4] <- ((((sign(max.cpg.run[gy,1] - 1)) + 1)/2))*(200 + (max.cpg.run[gy,1] - 1))
          max.cpg.run[gy,5] <- TRUE
          
     } 
}
     cpg.dist[[im]] <- max.cpg.run
}

     cpg.dist.area.temp[[pn]] <- cpg.dist
}
     cpg.dist.area <- cpg.dist.area.temp
     cpg.dist.area$pos <- cpg.dist.area[[2]]
     cpg.dist.area$neg <- cpg.dist.area[[3]]
     
@

<<plotCpG.stats>>=

# put data into long form for ggplot

df.plot <- data.frame(rbind(cpg.dist.area[[1]][[2]],cpg.dist.area[[1]][[3]]))
df.plot$corsign <- c(rep('positive',tot.promoters[[2]][1]),
                     rep('negative',tot.promoters[[3]][1]))


# Proportion of genes with at least 1 CpG island in the window from -200 to 0 relative to the TSS
prop.cpg.near.TSS <- c(sum(cpg.dist.area$pos[[1]][,5])/tot.promoters[[2]][1],
                  sum(cpg.dist.area$neg[[1]][,5])/tot.promoters[[3]][1])

prop.cpg.near.TSS.test <- prop.test(c(sum(cpg.dist.area$pos[[1]][,5]),
                                      sum(cpg.dist.area$neg[[1]][,5])),
                                      c(tot.promoters$pos[[1]],
                                        tot.promoters$neg[[1]]),
                                    alternative='two.sided')

prop.cpg.near.TSS.test


ks.test(cpg.dist.area$pos[[1]][,4][cpg.dist.area$pos[[1]][,4] > 0],
        cpg.dist.area$neg[[1]][,4][cpg.dist.area$neg[[1]][,4] > 0],
        alternative = 'two.sided')

colnames(df.plot)
# > colnames(df.plot)
# [1] "maxCpG"               "most.3prime.negition"
# [3] "num.CpG.islands"      "maxCpGbp"            
# [5] "corsign"              "test" 

#df.plot$test <- df.plot$maxCpGbp 
df.plot <- subset(df.plot,df.plot$test > 0)


# Make most.3prime.position relative to TSS

# df.plot$test <- df.plot$test - 1001

# corsign.test <- by(df.plot$test,df.plot$corsign,summary)
# t.test(test ~ corsign, data=df.plot)
# wilcox.test(test ~ corsign, data=df.plot)

q <-quantile(df.plot$test, probs=seq(0, 1, .2))
outcome_bin <- cut(df.plot$test, breaks=q, include.lowest=T)

 df.plot.tab <- table(outcome_bin,df.plot$corsign)
#df.plot.tab <- table(df.plot$test,df.plot$corsign)
print(chisq.test(df.plot.tab))


### Plotting
cgi.stats.plot <- ggplot(data=df.plot, aes(test,fill=corsign)) +
     geom_density(alpha = 0.2) + 
     theme_classic() +
     scale_fill_manual(values=c(cbPalette[c(2,3)])) +
     labs(fill="Sign of Correlation",
          title=c("Most 3' negition of Longest CpG Island Relative to TSS"),
#          title=c("Number of CpG Islands >= 200 bp"),
          title=c("Longest CpG Island"),
          subtitle=c('Prefrontal Cortex'),
          y=c('Probability Density'),
          x=c('Length (bp)')) +
          
#          geom_vline(xintercept = 0,linetype=2) +
          
     theme(legend.position = c(0.8, 0.80),
           legend.title=element_text(size=8),
           legend.text=element_text(size=6))  +
     theme(plot.title = element_text(hjust=0.5,
                                     size=10)) +
     theme(plot.subtitle = element_text(hjust=0.5,
                                     size=10)) 
# annotate("text", x = -500, y = 0.025, label = c('window size'),
#           size = 2)  +
# annotate("text", x = 35, y = -0.0001, label = c('TSS'),
#           size = 3)  +
#scale_x_continuous(name=c('Location (TSS=0) bp'),breaks=c(-800,-600,-400,-200,0,200,400,600))

     # theme(strip.background = element_rect(fill="gray80")) + 
     # geom_rect(data=window.coords, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax), fill="black", alpha=0.3,inherit.aes = FALSE)

cgi.stats.plot

@

<< diffset.neg.unique>>=

# genes from top500 positively correlated in Prefrontal, but absent from each of the other areas

diff.neg.genes <- list()
diff.500.neg <- list()


# PF
     diff.500.neg[[1]] <- setdiff(hold.Lowest.pvals.neg[[1]]$Symbol,hold.Lowest.pvals.neg[[2]]$Symbol)
     diff.500.neg[[2]] <- setdiff(diff.500.neg[[1]],hold.Lowest.pvals.neg[[3]]$Symbol)
     diff.neg.genes[[1]] <- setdiff(diff.500.neg[[2]],hold.Lowest.pvals.neg[[4]]$Symbol)

# alt PF
     diff.500.neg[[1]] <- setdiff(hold.Lowest.pvals.neg[[1]]$Symbol,hold.Lowest.pvals.neg[[2]]$Symbol)
     diff.500.neg[[2]] <- setdiff(hold.Lowest.pvals.neg[[1]]$Symbol,hold.Lowest.pvals.neg[[3]]$Symbol)
     diff.500.neg[[3]] <- setdiff(hold.Lowest.pvals.neg[[1]]$Symbol,hold.Lowest.pvals.neg[[4]]$Symbol)
     
     
     diff.neg.genes[[1]] <- setdiff(diff.500.neg[[2]],hold.Lowest.pvals.neg[[4]]$Symbol)

     
     

# CB 
     diff.500.neg.CB[[4]] <- setdiff(hold.Lowest.pvals.neg[[2]]$Symbol,hold.Lowest.pvals.neg[[1]]$Symbol)
     diff.500.neg.CB[[5]] <- setdiff(diff.500.neg.CB[[4]],hold.Lowest.pvals.neg[[3]]$Symbol)
     diff.neg.genes[[2]] <- setdiff(diff.500.neg.CB[[5]],hold.Lowest.pvals.neg[[4]]$Symbol)

# TM     
     diff.500.neg[[7]] <- setdiff(hold.Lowest.pvals.neg[[3]]$Symbol,hold.Lowest.pvals.neg[[1]]$Symbol)
     diff.500.neg[[8]] <- setdiff(diff.500.neg[[7]],hold.Lowest.pvals.neg[[2]]$Symbol)
     diff.neg.genes[[3]] <- setdiff(diff.500.neg[[8]],hold.Lowest.pvals.neg[[4]]$Symbol)

# PO     
     diff.500.neg[[10]] <- setdiff(hold.Lowest.pvals.neg[[4]]$Symbol,hold.Lowest.pvals.neg[[1]]$Symbol)
     diff.500.neg[[11]] <- setdiff(diff.500.neg[[10]],hold.Lowest.pvals.neg[[2]]$Symbol)
     diff.neg.genes[[4]] <- setdiff(diff.500.neg[[11]],hold.Lowest.pvals.neg[[4]]$Symbol)
     



# diff.neg.genes[[1]]   only in pf
# diff.neg.genes[[2]]   only in cb
# diff.neg.genes[[3]]   only in tm
# diff.neg.genes[[4]]   only in po


@

<<ALT.diff.unique>>=
diff.neg.genes <- list()
diff.500.neg <- list()


     diff.neg.genes[[1]] <- setdiff(hold.Lowest.pvals.neg[[1]]$Symbol,hold.Lowest.pvals.neg[[2]]$Symbol)
     diff.neg.genes[[2]] <- setdiff(hold.Lowest.pvals.neg[[1]]$Symbol,hold.Lowest.pvals.neg[[3]]$Symbol)
     diff.neg.genes[[3]] <- setdiff(hold.Lowest.pvals.neg[[1]]$Symbol,hold.Lowest.pvals.neg[[4]]$Symbol)

     

     diff.neg.genes[[4]] <- setdiff(hold.Lowest.pvals.neg[[2]]$Symbol,hold.Lowest.pvals.neg[[1]]$Symbol)
     diff.neg.genes[[5]] <- setdiff(hold.Lowest.pvals.neg[[3]]$Symbol,hold.Lowest.pvals.neg[[1]]$Symbol)
     diff.neg.genes[[6]] <- setdiff(hold.Lowest.pvals.neg[[4]]$Symbol,hold.Lowest.pvals.neg[[1]]$Symbol)
     

     diff.neg.genes[[7]] <- setdiff(hold.Lowest.pvals.neg[[2]]$Symbol,hold.Lowest.pvals.neg[[3]]$Symbol)
     diff.neg.genes[[8]] <- setdiff(hold.Lowest.pvals.neg[[2]]$Symbol,hold.Lowest.pvals.neg[[4]]$Symbol)
     
     
     diff.neg.genes[[9]] <- setdiff(hold.Lowest.pvals.neg[[3]]$Symbol,hold.Lowest.pvals.neg[[2]]$Symbol)
     diff.neg.genes[[10]] <- setdiff(hold.Lowest.pvals.neg[[4]]$Symbol,hold.Lowest.pvals.neg[[2]]$Symbol)

          
     diff.neg.genes[[11]] <- setdiff(hold.Lowest.pvals.neg[[3]]$Symbol,hold.Lowest.pvals.neg[[4]]$Symbol)
     diff.neg.genes[[12]] <- setdiff(hold.Lowest.pvals.neg[[4]]$Symbol,hold.Lowest.pvals.neg[[3]]$Symbol)
     
# Now get unique per area
     
# PF
#only.neg.PF <- setdiff((setdiff(diff.neg.genes[[1]],diff.neg.genes[[2]])),diff.neg.genes[[3]])
only.neg.PF <- diff.neg.genes[[1]]
only.neg.PF.indx <- match(only.neg.PF,hold.Lowest.pvals.neg[[1]]$Symbol)
only.neg.PF.entrez <- hold.Lowest.pvals.neg[[1]]$ENTREZID[c(only.neg.PF.indx)]
only.neg.PF.noquote <- noquote(only.neg.PF)

writeLines(only.neg.TM.noquote,con='from500_only_unique_neg_genelist_PF_ALT.txt',sep='\n')
### end TM only
        
@

<< diffset.neg.unique>>=

# genes from top500 positively correlated in Prefrontal, but absent from each of the other areas

diff.neg.genes <- list()
diff.500.neg <- list()



@

<<get.unique.area.genes>>=
### PF only
only.neg.PF <- diff.neg.genes[[1]]
only.neg.PF.indx <- match(only.neg.PF,hold.Lowest.pvals.neg[[1]]$Symbol)
only.neg.PF.entrez <- hold.Lowest.pvals.neg[[1]]$ENTREZID[c(only.neg.PF.indx)]
only.neg.PF.noquote <- noquote(only.neg.PF)

writeLines(only.neg.PF.noquote,con='from500_only_unique_neg_genelist_pf.txt',sep='\n')

### alt PF only
temp.unique <- hold.Lowest.pvals.neg[[1]]$Symbol
temp.unique <- setdiff(hold.Lowest.pvals.neg[[1]]$Symbol,union(union(hold.Lowest.pvals.neg[[2]]$Symbol,hold.Lowest.pvals.neg[[3]]$Symbol),hold.Lowest.pvals.neg[[4]]$Symbol))


only.neg.PF <- temp.shared
#only.neg.PF <- setdiff((setdiff(diff.500.neg[[1]],diff.500.neg[[2]])),diff.500.neg[[3]])
only.neg.PF.indx <- match(only.neg.PF,hold.Lowest.pvals.neg[[1]]$Symbol)
only.neg.PF.entrez <- hold.Lowest.pvals.neg[[1]]$ENTREZID[c(only.neg.PF.indx)]
only.neg.PF.noquote <- noquote(only.neg.PF)


only.neg.PF <- as.character(c('RPL18P13',
'ACY1',
'HSCB',
'TTLL4',
'MEGF10',   
'ZFAND3',
'PIK3C2A',
'ACAA2',
'HIST1H2AC',
'H3F3AP4',
'WDFY2',
'ELOVL2',
'CYP2J2',
'KRT10',
'SASH1',    
'RELA',
'CTNNA1',
'PARP4',
'CRYL1',
'AP3M1',    
'FBXO8',
'MIF4GD',
'C1orf198'))

only.neg.PF.indx <- match(only.neg.PF,hold.Lowest.pvals.neg[[1]]$Symbol)
only.neg.PF.entrez <- hold.Lowest.pvals.neg[[1]]$ENTREZID[c(only.neg.PF.indx)]
only.neg.PF.noquote <- noquote(only.neg.PF)

writeLines(only.neg.PF.noquote,con='from500_only_unique_neg_genelist_pf.txt',sep='\n')
### end PF only

### CB only
only.neg.CB <- diff.neg.genes[[2]]
only.neg.CB.indx <- match(only.neg.CB,hold.Lowest.pvals.neg[[2]]$Symbol)
only.neg.CB.entrez <- hold.Lowest.pvals.neg[[2]]$ENTREZID[c(only.neg.CB.indx)]
only.neg.CB.noquote <- noquote(only.neg.CB)

writeLines(only.neg.CB.noquote,con='from500_only_unique_neg_genelist_cb.txt',sep='\n')

only.neg.CB <- diff.neg.genes[[]]
only.neg.CB.indx <- match(only.neg.CB,hold.Lowest.pvals.neg[[2]]$Symbol)
only.neg.CB.entrez <- hold.Lowest.pvals.neg[[2]]$ENTREZID[c(only.neg.CB.indx)]
only.neg.CB.noquote <- noquote(only.neg.CB)

writeLines(only.neg.CB.noquote,con='from500_only_unique_neg_genelist_cb.txt',sep='\n')
### end CB only

### TM only
only.neg.TM <- diff.neg.genes[[3]]
only.neg.TM.indx <- match(only.neg.TM,hold.Lowest.pvals.neg[[3]]$Symbol)
only.neg.TM.entrez <- hold.Lowest.pvals.neg[[3]]$ENTREZID[c(only.neg.TM.indx)]
only.neg.TM.noquote <- noquote(only.neg.TM)

writeLines(only.neg.TM.noquote,con='from500_only_unique_neg_genelist_tm.txt',sep='\n')

only.neg.TM <- setdiff((setdiff(diff.neg.genes[[5]],diff.neg.genes[[9]])),diff.neg.genes[[11]])
only.neg.TM.indx <- match(only.neg.TM,hold.Lowest.pvals.neg[[3]]$Symbol)
only.neg.TM.entrez <- hold.Lowest.pvals.neg[[3]]$ENTREZID[c(only.neg.TM.indx)]
only.neg.TM.noquote <- noquote(only.neg.TM)

writeLines(only.neg.TM.noquote,con='from500_only_unique_neg_genelist_TM.txt',sep='\n')
### end TM only

### PO only
only.neg.PO <- diff.neg.genes[[4]]
only.neg.PO.indx <- match(only.neg.PO,hold.Lowest.pvals.neg[[4]]$Symbol)
only.neg.PO.entrez <- hold.Lowest.pvals.neg[[4]]$ENTREZID[c(only.neg.PO.indx)]
only.neg.PO.noquote <- noquote(only.neg.PO)

writeLines(only.neg.TM.noquote,con='from500_only_unique_neg_genelist_po.txt',sep='\n')

@

<<get.shared.genes>>=

shared.neg.PF <- intersect((intersect((intersect(hold.Lowest.pvals.neg[[1]]$Symbol,hold.Lowest.pvals.neg[[2]]$Symbol)),hold.Lowest.pvals.neg[[3]]$Symbol)),hold.Lowest.pvals.neg[[4]]$Symbol)

shared.neg.PF.indx <- match(shared.neg.PF,hold.Lowest.pvals.neg[[1]]$Symbol)
shared.neg.PF.entrez <- hold.Lowest.pvals.neg[[1]]$ENTREZID[c(shared.neg.PF.indx)]

@

     

<<>>=     
################################################################
# Facet the above four plots
#area.num <- c(4)

cpg.df <- data.frame(indx=rep(NA,4*2*length(perc.cpg$bp[[3]])),
                     perc.cpg=rep(NA,4*2*length(perc.cpg$bp[[3]])),
                     negVneg=rep(NA,4*2*length(perc.cpg$bp[[3]])),
                     area=rep(NA,4*2*length(perc.cpg$bp[[3]])))

cpg.df$indx <-c(perc.cpg$bp[[1]],perc.cpg$bp[[1]],
                perc.cpg$bp[[2]],perc.cpg$bp[[2]],
                perc.cpg$bp[[3]],perc.cpg$bp[[3]],
                perc.cpg$bp[[4]],perc.cpg$bp[[4]]) 
cpg.df$perc.cpg <-c(perc.cpg$neg[[1]],
                perc.cpg$neg[[2]],
                perc.cpg$neg[[3]],
                perc.cpg$neg[[4]],
                perc.cpg$neg[[1]],
                perc.cpg$neg[[2]],
                perc.cpg$neg[[3]],
                perc.cpg$neg[[4]]
                )
cpg.df$negVneg <-c(rep('positive',4*length(perc.cpg$bp[[area.num]])),
                   rep('negative',4*length(perc.cpg$bp[[area.num]])))
cpg.df$area <- c(rep(c(rep(stand.Col.names.aug[1],length(perc.cpg$bp[[3]])),
                 rep(stand.Col.names.aug[2],length(perc.cpg$bp[[3]])),
                 rep(stand.Col.names.aug[3],length(perc.cpg$bp[[3]])),
                 rep(stand.Col.names.aug[4],length(perc.cpg$bp[[3]]))),2))
                 
                 

# Plot the CpG island curves

window.coords <- data.frame(xmin=-600,
                            xmax=-400,
                            ymin=-0.04,
                            ymax=0.0)

cpg.plot <- ggplot(data=cpg.df,
       aes(x=indx, y=perc.cpg, color=negVneg)) +
       geom_line() +
          facet_wrap(~area, ncol=2) +
          labs(color="Sign of Correlation",
               title=c(paste("Proportion Genes with CpG Islands",sep=''))) +
          geom_hline(yintercept = 0,linetype=2) + 
          geom_vline(xintercept = 0,linetype=2) +
          scale_colour_manual(values=c("red", "blue")) +
     theme_classic() +
     theme(legend.position = c(0.5, 0.90),
           legend.title=element_text(size=8),
           legend.text=element_text(size=6))  +
     theme(plot.title = element_text(hjust=0.5)) +
     annotate("text", x = -500, y = 0.025, label = c('window size'),
               size = 2)  +
     annotate("text", x = 45, y = -0.025, label = c('TSS'),
               size = 2)  +
scale_x_continuous(name=c('Location (TSS=0) bp'),breaks=c(-800,-600,-400,-200,0,200,400,600)) +
scale_y_continuous(name=c('Proportion Genes with CpG Island'), breaks=c(0.0,0.1,0.2,0.3,0.4,0.5,0.6)) +
     theme(strip.background = element_rect(fill="gray80")) + 
     geom_rect(data=window.coords, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax), fill="black", alpha=0.3,inherit.aes = FALSE)
     
cpg.plot

# Because Temporal Cortex shows the opnegite CpG island pattern compared to Prefrontal Cortex, check the mean expression levels of the top 500 genes in each area sorted by correlation sign



mean.expr.area.sign <- 
     hold.Lowest.pvals[[4]][c(18,6)] %>%
                    aggregate(. ~ corsign, data = ., FUN = . %>% mean %>% round(2))


neg.intersect.area <- list()
neg.intersect.area <- list()
p1n2.intersect.area <- list()
n1p2.intersect.area <- list()
neg.union.area <- list()
neg.union.area <- list()

genes.intersect.area <- list()
genes.union.area <- list()

comp.area <- matrix(c(1,2,
                    1,3,
                    1,4,
                    2,3,
                    2,4,
                    3,4),ncol=2, byrow=TRUE)


     for (ji in 1:dim(comp.area)[1])   {
          
          
          neg.intersect.area[[ji]] <- intersect(hold.Lowest.pvals.sign$neg[[comp.area[ji,1]]]$Symbol,hold.Lowest.pvals.sign$neg[[comp.area[ji,2]]]$Symbol)
          neg.intersect.area[[ji]] <- intersect(hold.Lowest.pvals.sign$neg[[comp.area[ji,1]]]$Symbol,hold.Lowest.pvals.sign$neg[[comp.area[ji,2]]]$Symbol)
          p1n2.intersect.area[[ji]] <- intersect(hold.Lowest.pvals.sign$neg[[comp.area[ji,1]]]$Symbol,hold.Lowest.pvals.sign$neg[[comp.area[ji,2]]]$Symbol)
          n1p2.intersect.area[[ji]] <- intersect(hold.Lowest.pvals.sign$neg[[comp.area[ji,2]]]$Symbol,hold.Lowest.pvals.sign$neg[[comp.area[ji,1]]]$Symbol)
          
          neg.union.area[[ji]] <- union(hold.Lowest.pvals.sign$neg[[comp.area[ji,1]]]$Symbol,hold.Lowest.pvals.sign$neg[[comp.area[ji,2]]]$Symbol)
          neg.union.area[[ji]] <- union(hold.Lowest.pvals.sign$neg[[comp.area[ji,1]]]$Symbol,hold.Lowest.pvals.sign$neg[[comp.area[ji,2]]]$Symbol)
          
          
          genes.intersect.area$neg[[ji]] <- neg.intersect.area[[ji]]
          genes.intersect.area$neg[[ji]] <- neg.intersect.area[[ji]]
          genes.intersect.area$pVn[[ji]] <- p1n2.intersect.area[[ji]]
          genes.intersect.area$nVp[[ji]] <- n1p2.intersect.area[[ji]]
          
          genes.union.area$neg[[ji]] <- neg.union.area[[ji]]
          genes.union.area$neg[[ji]] <- neg.union.area[[ji]]
          
     }

num.comps <- seq(1,dim(comp.area)[1],1)
num.shared.genes <- data.frame(neg=rep(0,6),
                               neg=rep(0,6),
                               pVn=rep(0,6),
                               nVp=rep(0,6),
                               pUp=rep(0,6),
                               nUn=rep(0,6))

num.shared.genes$neg <- unlist(lapply(genes.intersect.area$neg[num.comps], function(x,num.comps) length(x),num.comps))
num.shared.genes$neg <- unlist(lapply(genes.intersect.area$neg[num.comps], function(x,num.comps) length(x),num.comps))
num.shared.genes$pVn <- unlist(lapply(genes.intersect.area$pVn[num.comps], function(x,num.comps) length(x),num.comps))
num.shared.genes$nVp <- unlist(lapply(genes.intersect.area$nVp[num.comps], function(x,num.comps) length(x),num.comps))
num.shared.genes$pUp <- unlist(lapply(genes.union.area$neg[num.comps], function(x,num.comps) length(x),num.comps))
num.shared.genes$nUn <- unlist(lapply(genes.union.area$neg[num.comps], function(x,num.comps) length(x),num.comps))
num.shared.genes$perc.neg <- round(unlist(num.shared.genes$neg)/unlist(num.shared.genes$pUp),3)
num.shared.genes$perc.neg <- round(unlist(num.shared.genes$neg)/unlist(num.shared.genes$nUn),3)



row.names(num.shared.genes) <- c('PfCtx vs. Cereb',
                                 'PfCtx vs. TemCtx',
                                 'PfCtx vs. Pons',
                                 'Cereb vs. TemCtx',
                                 'Cereb vs. Pons',
                                 'TemCtx vs. Pons')

colnames(num.shared.genes) <- c('positive in Common',
                                'Negative in Common',
                                'positive in Common with Negative',
                                'Negative in Common with positive',
                                'Union(positive)',
                                'Union(Negative)',
                                'Proportion positive in Common',
                                'Proportion Negative in Common')

num.shared.genes.tab <- xtable(num.shared.genes,
                               caption='Comparisons of gene sets by sign of correlation and by area',
                               digits=c(rep(0,7),3,3))







@




<<chisq.signs.500>>=

top500.signs <- lapply(promoter.Full$corsign[ib], function(x,ib) table(unlist(x)), ib)

long.top500.signs <- c(promoter.Full$corsign[[1]],
                       promoter.Full$corsign[[2]],
                       promoter.Full$corsign[[3]],
                       promoter.Full$corsign[[4]])

long.top500.signs.df <- data.frame(signs=long.top500.signs,
                                   areas=c(rep('pf',length(promoter.Full$corsign[[1]])),
                                           rep('cb',length(promoter.Full$corsign[[2]])),
                                           rep('tm',length(promoter.Full$corsign[[3]])),
                                           rep('po',length(promoter.Full$corsign[[4]]))
                                           ))
# This produces a contingency table of brain area x sign for the ~ top 500 COMT-correlated genes
top500.signs.tab <- table(long.top500.signs.df)

top500.signs.Percent.tab <- matrix(rep(0,length(area.abbrv)*2),ncol=4)
                                       

for (im in ib)  {
     for (sg in 1:2)  {
          top500.signs.Percent.tab[sg,im] <- round(top500.signs.tab[sg,im]/sum(top500.signs.tab[,im]),3)
     
     }  
}
colnames(top500.signs.Percent.tab) <- stand.Col.names
row.names(top500.signs.Percent.tab) <- c('-1','+1')

top500.signs.Percent.tab

chisq.area.by.sign <- chisq.test(top500.signs.tab) 

@

The results of the chi-square test of independence says that brain area and COMT-correlation signs are {\bfseries {not independent}}. The proportion of negatively COMT-correlated genes differs by brain areas with prefrontal and cereballum having the most negatively correlated genes and temporal and pons having the fewest.\\

<<chisq.signs.by.chrom>>=

map.Chrname.Chrnum <- data.frame(chrname = as.character(c(1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,                                             2, 20, 21, 22,  3,  4,  5,  6,  7, 8,  9,  'X', 'Y' )),
                                 chrnum = as.character(c(seq(1:22),'X','Y')))

chrname2num <- match(map.Chrname.Chrnum$chrnum,map.Chrname.Chrnum$chrname)

lowest.pvals.corsignXchrom <- as.data.table(table(hold.Lowest.pvals[[1]]$corsign,hold.Lowest.pvals[[1]]$loc))

lowest.pvals.corsignXchrom$V2 <- as.integer(rep(chrname2num[1:23],each=2))

lowest.pvals.corsignXchrom <- lowest.pvals.corsignXchrom[order(lowest.pvals.corsignXchrom$V2),]

lowest.pvals.corsignXchrom$V2 <- rep(as.character(c(1:22,'X')),each=2)

lowest.pvals.corsignXchrom <- data.frame(matrix(as.matrix(lowest.pvals.corsignXchrom$N,nrow=2,ncol=23,byrow=TRUE),nrow=2))
     
colnames(lowest.pvals.corsignXchrom) <- map.Chrname.Chrnum$chrnum[1:23]

     
lowest.pvals.corsignXchrom$Total <- round(rowSums(lowest.pvals.corsignXchrom),0)

lowest.pvals.corsignXchrom[3,] <- lowest.pvals.corsignXchrom[1,]/colSums(lowest.pvals.corsignXchrom[1:2,])

row.names(lowest.pvals.corsignXchrom) <- c('negative','positive','prop. neg.')

top500.corsignXchr.tab <- xtable(lowest.pvals.corsignXchrom[1:3,],
                                 caption='Distribution of five hundred most strongly COMT-correlated genes (ranked by p-value) by sign of correlation and chromosome',
                                 digits=2)

chisq.test(lowest.pvals.corsignXchrom[1:2,1:23])


# test the binomial proportion of negative correlated genes on each chromosome against 171/500


prop.neg.Xchr <- list()
prop.neg <- rowSums(lowest.pvals.corsignXchrom[1,1:23])/sum(rowSums(lowest.pvals.corsignXchrom[1:2,1:23]))

for (hj in 1:23) {

     prop.neg.Xchr[[hj]] <- binom.test(lowest.pvals.corsignXchrom[1,hj],
                                       sum(lowest.pvals.corsignXchrom[1:2,hj]),
                                       p=prop.neg)
}

@

\vspace{1em}
Pearson's Chi-squared test\\

Chi-squared = 44.6$, df = 23, p-value = 0.0044\\

The most strongly positively and negatively COMT-correlated genes are distributed proportionately unequally across the 22 autosomes and the X chromosome. There are significantly (p = 0.00034) fewer negatively correlated than positively correlated genes on Chromosome 1 than would be expected from the overall proportion of negatively COMT-correlated genes across the 500 most strongly correlated genes. The COMT gene is located on Chromosome 22.\\

Testing the binomial proportion of negatively correlated genes on each chromosome against 171/500, the overall proportion of negatively correlated genes out of the top 500, with a Bonferroni-corrected p-value of 0.05/23 = .002. By this test, the proportions on Chromosomes 



<<motif.analysis>>=
# Record all of the motifs (sequences) of length, n, in the COMT promoter.
motifs.with.entrez <- list()
ml <- c(6)  # number of bases in a motif
txStart <- c(1000)
after.txStart <- c(600)

ic <- seq(-txStart,(after.txStart - ml),1)

 for (im in ib)  {
      
     temp.motif <- matrix(rep(NA,((nchar(seq.fasta[[im]][1])-(ml-1))*length(seq.fasta[[im]]))),
                              ncol=length(seq.fasta[[im]]))
     
 for (nf in 1:length(seq.fasta[[im]]))   {

                    temp.motif[,nf] <- get.motif(seq.fasta[[im]][nf],ml,ic,txStart)

          } #end nf loop

motifs.with.entrez[[im]] <- temp.motif

} # end brain area loop

# motifs.with.entrez[[1]][,1] are the motifs for COMT;  motifs.with.entrez[[1]][,2] are the motifs for the second most highly COMT-correlated gene in prefrontal cortex

# The percentages of the four bases in the human genome are:
# 
# %A      %G 	     %C 	     %T 
# 30.0	20.0	     20.0	     30.0


# The distance of each motif from the transcription start site is 1000 - (row number -1)

@

<<match.motifs>>=

# only written for prefrontal now


no.hits <- c()
comt.motif.starts <- seq(984,986-30*ml,-ml)


for (cs in 1:length(comt.motif.starts))  {

motif.match.COMT <- list()

motif.match <- list()
num.hits <- matrix(rep(0,(dim(motifs.with.entrez[[1]])[2] - 1)))

# loc.comt.motif <- c(comt.motif.starts[cs])
loc.comt.motif <- c(1082)

for (gh in 2:dim(motifs.with.entrez[[1]])[2])  {
     
     

#     for (jk in 1:dim(motifs.with.entrez[[1]])[1])  {
     for (jk in loc.comt.motif:loc.comt.motif)  {

          if (length(which(grepl(motifs.with.entrez[[1]][jk,1],motifs.with.entrez[[1]][,gh]))) > 0)  {
               
               motif.match[[(gh-1)]] <- which(grepl(motifs.with.entrez[[1]][jk,1],motifs.with.entrez[[1]][,gh]))
               
          } else {
               
               motif.match[[(gh-1)]] <- c(0)
               
          }
          
#          motif.match.COMT$symbol[[gh]] <- 
          
#          num.hits[(gh-1)] <- length(motif.match[[(gh-1)]])

}
          
}

for (hj in 1:length(motif.match))  {
     
     if (motif.match[[hj]] == 0)  {
          
          num.hits[(hj-1)] <- c(0)
          
     } else {
          
          num.hits[(hj-1)] <- length(motif.match[[hj]])
     }
}



#no.hits[cs] <- length(which(unlist(num.hits) == 0))
no.hits <- length(which(unlist(num.hits) == 0))

}

motif.match.COMT$loc <- motif.match
motif.match.COMT$Symbol <- promoter.Full$Symbol[[1]][2:length(promoter.Full$Symbol[[1]])]
motif.match.COMT$corsign <- promoter.Full$corsign[[1]][2:length(promoter.Full$corsign[[1]])]


for (ui in 1:length(motif.match.COMT$Symbol))  {
     
     cat(c(motif.match.COMT$corsign[[ui]],
           motif.match.COMT$Symbol[[ui]],
           motif.match.COMT$loc[[ui]]),
         file=c(paste('comt_motif_',motifs.with.entrez[[1]][loc.comt.motif,1],'_',
               (loc.comt.motif - txStart),'_bp_pf.txt',sep='')),
         sep=',',
         append=TRUE,
         fill=TRUE)
}


 
@

<<comt.promoter>>=

e2f3 <- "1312"

transcriptCoordsByGene.GRangesList <-
     transcriptsBy (TxDb.Hsapiens.UCSC.hg19.knownGene, by = "gene") [e2f3]

promoter.seqs <- getPromoterSeq (transcriptCoordsByGene.GRangesList[[1]][1],
                                   Hsapiens, upstream=1000, downstream=600)


@

<<51287.promoter>>=

source("https://bioconductor.org/biocLite.R")

biocLite('Biostrings')
library('Biostrings')

biocLite("TxDb.Hsapiens.UCSC.hg19.knownGene")
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene #shorthand (for convenience) 

library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(BSgenome.Hsapiens.UCSC.hg19)

e2f3 <- "51287"



transcriptCoordsByGene.GRangesList <-

#     transcriptsBy(TxDb.Hsapiens.UCSC.hg19.knownGene, by = "gene")[e2f3]
     
     transcriptsBy(txdb, by = "gene")[e2f3]

promoter.seqs <- getPromoterSeq (transcriptCoordsByGene.GRangesList[[1]][1],
                                   Hsapiens, upstream=1000, downstream=600)


@


<<dotplots>>=
 # Plot the locations of matching motifs to the chosen COMT motif

 
 comt.motif <- motifs.with.entrez[[1]][loc.comt.motif,1]
 comt.motif.loc <- data.frame(COMT.motif.loc = c(loc.comt.motif - txStart))
 
 match.locs <- data.frame(dist.from.txStart=(unlist(motif.match.COMT$loc) - 1000))
 
 nonzero.matches <- 
      
      match.locs %>%
      
          filter(dist.from.txStart > -1000)
      
          
motif.5 <-  ggplot(nonzero.matches, aes(x = dist.from.txStart)) +    # match.locs
      geom_dotplot(binwidth = 8,
                   method="dotdensity",
                   dotsize = 1.5,
                   color='gray40',
                   fill='gray40') + 
      geom_point(data=comt.motif.loc, aes(x=COMT.motif.loc, y=-0.075),
                 shape=c(24),
                 colour="blue",
                 fill=c('blue'),
                 size=c(2)
                 )                  +
     theme_minimal() +
      theme(axis.line.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.title.y=element_blank(),
          axis.title.x = element_text(margin = margin(t = 15, r = 0, b = 0, l = 0)),
          axis.text.x = element_text(margin = margin(t = 6, r = 0, b = 0, l = 0))
#          axis.ticks.length=unit(0.25, "cm")
          )    +
      labs(x = 'Distance (bp) from transcription start location')  +
      annotate("text", x = -5, y = 0.65, label = motifs.with.entrez[[1]][loc.comt.motif,1],
               size = 3)  +
      annotate("text", x = -800, y = 0.65, 
               label = "binwidth: 8 bp",
               size = 3,
               parse=FALSE)  + 
     annotate("text", x = -750, y = 0.9, 
               label = paste("italic(COMT)~motif~negition==~",
                             comt.motif.loc$COMT.motif.loc,"~bp",sep=""),
               size = 3,
               parse=TRUE)  +
     annotate("text", x = 300, y = 0.9, 
               label = paste(as.character((length(motif.match) - no.hits)),' genes',sep=""),
               size = 3,
               parse=FALSE)  +
      coord_fixed(200)

motif.5

ggsave(paste("/Volumes/Macintosh_HD_3/genetics/genenetwork2/new_plots/comt_motif_CCCCTCCC_-16bp.pdf",sep=''),plot=motif.5,device="pdf",
       scale=2,
       dpi=300,
       width=6.0,
       height=3.0,
       units=c('in')
)
      
@

<<find.motifs>>=

### Prefrontal cortex ###

PF.motifs <- findMotifFasta("fasta_500_promoter_seq_pf_neg.fa","fasta_500_promoter_seq_pf_neg.fa",max.motif=3,
                    start.width=6,min.cutoff=5, min.ratio=1.3,
                    min.frac=0.01, both.strand=TRUE, flank=2,
                    mask=TRUE,other.data=NULL, start.nmer=NULL,
                    enriched.only=TRUE,n.bootstrap = 5, bootstrap.pvalue=0.1,is.parallel =
                    TRUE,mc.cores = 4,min.info=10,max.width=11,discretize=TRUE)

summaryMotif(PF.motifs$motifs,PF.motifs$category)

motifLatexTable(main="FG: positive COMT correlations, BG: negative COMT correlations, Prefrontal motifs", PF.motifs, prefix="negnegPF",plot.pwm= TRUE,summary.cols=c(1,7,8,9))

plotMotif(PF.motifs$motifs[[1]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE,
          main = 'Dinucleotide differential motif 1 \n for positively COMT-correlated versus \n negatively COMT-correlated genes in Prefrontal Cortex')
plotMotif(PF.motifs$motifs[[2]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE,
          main = 'Dinucleotide differential motif 2 \n for positively COMT-correlated versus \n negatively COMT-correlated genes in Prefrontal Cortex')
plotMotif(PF.motifs$motifs[[3]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE,
          main = 'Dinucleotide differential motif 3 \n for positively COMT-correlated versus \n negatively COMT-correlated genes in Prefrontal Cortex')

# Hypothesis: the mean number of hits for a given motif will be greater for the positively correlated genes than for the negatively correlated genes.
# Compare the mean number of motif hits in the positive vs. negative groups. Do this separately by motif, then combine all 3 motifs and do this with the sum.

motif.negvNEG.t <- list()

# motif 1
motif.negvNEG.t[[1]] <- t.test(slot(PF.motifs$motifs[[1]], "count")[1:323],slot(PF.motifs$motifs[[1]], "count")[324:491],alternative="two.sided")

# motif 2
motif.negvNEG.t[[2]] <- t.test(slot(PF.motifs$motifs[[2]], "count")[1:323],slot(PF.motifs$motifs[[2]], "count")[324:491],alternative="two.sided")

# motif 3
motif.negvNEG.t[[3]] <- t.test(slot(PF.motifs$motifs[[3]], "count")[1:323],slot(PF.motifs$motifs[[3]], "count")[324:491],alternative="two.sided")

# all motifs
sum.motif.hits.neg <- slot(PF.motifs$motifs[[1]], "count")[1:323] + slot(PF.motifs$motifs[[2]], "count")[1:323] + slot(PF.motifs$motifs[[3]], "count")[1:323]

sum.motif.hits.neg <- slot(PF.motifs$motifs[[1]], "count")[324:491] + slot(PF.motifs$motifs[[2]], "count")[324:491] + slot(PF.motifs$motifs[[3]], "count")[324:491]

motif.negvNEG.t[[4]] <- t.test(sum.motif.hits.neg,sum.motif.hits.neg,alternative="two.sided")

# get descriptive on number of hits by corsign
motif.hits.pf <- data.frame()
motif.hits.pf <- data.frame(group = c(rep('neg',323),rep('neg',(491-323))),
                            motif1=slot(PF.motifs$motifs[[1]], "count"),
                            motif2=slot(PF.motifs$motifs[[2]], "count"),
                            motif3=slot(PF.motifs$motifs[[3]], "count")
                            )

motif.hits.pf$hitsAll <- motif.hits.pf$motif1 + motif.hits.pf$motif2 + motif.hits.pf$motif3

motif.hits.summary.pf <- describeBy(motif.hits.pf[,2:5],group=motif.hits.pf$group)

motif.hits.pf.tab <- tableContinuous(motif.hits.pf[,2:5], 
                                     weights = NA, 
                                     subset = NA, 
                                     group = motif.hits.pf$group, 
                                     stats = c("n", "min", "q1", "median", "mean", "s", "q3", "max", "iqr"), 
                                     prec = 1, col.tit = NA,
                                     col.tit.font = c("bf"),
                                     print.pval = c("anova"), 
                                     pval.bound = 10^-16,
                                     cap = "Descriptive statistics: Number of hits by motif in Prefrontal Cortex",
                                     lab = "", 
                                     font.size = "footnotesize", 
                                     longtable = TRUE, 
                                     disp.cols = NA, nams = NA)


position.by.motif.POSvNEG <- 
     
     as.integer(slot(PF.motifs$motifs[[1]], "match")[,3]) %>%
     
          filter(. <= 323)

               




### end Prefrontal ###


############## start pf vs. cb ###################

match.entrez.unique.pf <- match(unique.full.data.all$pf$ENTREZID,promoter.Full$entrezgene[[1]])
unique.promoter.seq.pf <- promoter.Full$prom.Seq[[1]][na.omit(match.entrez.unique.pf)]

match.entrez.unique.cb <- match(unique.full.data.all$cb$ENTREZID,promoter.Full$entrezgene[[2]])
unique.promoter.seq.cb <- promoter.Full$prom.Seq[[2]][na.omit(match.entrez.unique.cb)]

unique.promoter.seq.PFvCB <- c(unique.promoter.seq.pf,unique.promoter.seq.cb)
category <- c(rep(1,194),rep(0,233))

write.fasta(sequences=str_split(unique.promoter.seq.pf,''),
            names=promoter.Full$entrezgene[[1]][na.omit(match.entrez.unique.pf)],
            file.out='fasta_500_promoter_seq_pf_unique.fa',nbchar=1600)
write.fasta(sequences=str_split(unique.promoter.seq.cb,''),
            names=promoter.Full$entrezgene[[2]][na.omit(match.entrez.unique.cb)],
            file.out='fasta_500_promoter_seq_cb_unique.fa',nbchar=1600)


PFvCB.motifs <- findMotifFasta('fasta_500_promoter_seq_pf_unique.fa',
                               'fasta_500_promoter_seq_cb_unique.fa',
                               max.motif=3,enriched=T)

PFvCB.motifs

motifLatexTable(main="FG: positive pf COMT correlations, BG: positive cb COMT correlations, Prefrontal vs. Cerebellum motifs", PF.motifs, prefix="negPFvsCB")

plotMotif(PFvCB.motifs$motifs[[1]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)
plotMotif(PFvCB.motifs$motifs[[2]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)
plotMotif(PFvCB.motifs$motifs[[3]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)

############## end pf vs. cb ###################

############## start pf vs. tm #################
# try all neg but compare pf to tm

match.entrez.unique.pf <- match(unique.full.data.all$pf$ENTREZID,promoter.Full$entrezgene[[1]])
unique.promoter.seq.pf <- promoter.Full$prom.Seq[[1]][na.omit(match.entrez.unique.pf)]

match.entrez.unique.tm <- match(unique.full.data.all$tm$ENTREZID,promoter.Full$entrezgene[[3]])
unique.promoter.seq.tm <- promoter.Full$prom.Seq[[3]][na.omit(match.entrez.unique.tm)]

# write.fasta(sequences=str_split(unique.promoter.seq.pf,''),
#             names=promoter.Full$entrezgene[[1]][na.omit(match.entrez.unique.pf)],
#             file.out='fasta_500_promoter_seq_pf_unique.fa',nbchar=1600)
write.fasta(sequences=str_split(unique.promoter.seq.tm,''),
            names=promoter.Full$entrezgene[[3]][na.omit(match.entrez.unique.tm)],
            file.out='fasta_500_promoter_seq_tm_unique.fa',nbchar=1600)


PFvTM.motifs <- findMotifFasta('fasta_500_promoter_seq_pf_unique.fa',
                               'fasta_500_promoter_seq_tm_unique.fa',
                               max.motif=3,enriched=T)

PFvTM.motifs

motifLatexTable(main="FG: positive pf COMT correlations, BG: positive cb COMT correlations, Prefrontal vs. Cerebellum motifs", PF.motifs, prefix="negPFvsCB")

plotMotif(PFvCB.motifs$motifs[[1]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)
plotMotif(PFvCB.motifs$motifs[[2]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)
plotMotif(PFvCB.motifs$motifs[[3]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)

############## end pf vs. tm ###################

############## start pf vs. po #################
# try all neg but compare pf to tm

match.entrez.unique.pf <- match(unique.full.data.all$pf$ENTREZID,promoter.Full$entrezgene[[1]])
unique.promoter.seq.pf <- promoter.Full$prom.Seq[[1]][na.omit(match.entrez.unique.pf)]

match.entrez.unique.po <- match(unique.full.data.all$po$ENTREZID,promoter.Full$entrezgene[[4]])
unique.promoter.seq.po <- promoter.Full$prom.Seq[[4]][na.omit(match.entrez.unique.po)]

# write.fasta(sequences=str_split(unique.promoter.seq.pf,''),
#             names=promoter.Full$entrezgene[[1]][na.omit(match.entrez.unique.pf)],
#             file.out='fasta_500_promoter_seq_pf_unique.fa',nbchar=1600)
write.fasta(sequences=str_split(unique.promoter.seq.po,''),
            names=promoter.Full$entrezgene[[4]][na.omit(match.entrez.unique.po)],
            file.out='fasta_500_promoter_seq_po_unique.fa',nbchar=1600)


PFvPO.motifs <- findMotifFasta('fasta_500_promoter_seq_pf_unique.fa',
                               'fasta_500_promoter_seq_po_unique.fa',
                               max.motif=3,enriched=T)

PFvTM.motifs

motifLatexTable(main="FG: positive pf COMT correlations, BG: positive cb COMT correlations, Prefrontal vs. Cerebellum motifs", PF.motifs, prefix="negPFvsCB")

plotMotif(PFvCB.motifs$motifs[[1]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)
plotMotif(PFvCB.motifs$motifs[[2]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)
plotMotif(PFvCB.motifs$motifs[[3]]@match$pattern, logodds=TRUE, entropy=TRUE,has.box=TRUE)

############## end pf vs. po ###################


###### start Cerebellum ###########
CB.motifs <- findMotifFasta("fasta_500_promoter_seq_cb_neg.fa","fasta_500_promoter_seq_cb_neg.fa",max.motif=3,enriched=T)

motifLatexTable(main="FG: positive COMT correlations, BG: negative COMT correlations, Cerebellum motifs", CB.motifs, prefix="negnegCB")

plotMotif(CB.motifs$motifs[[1]]@match$pattern, logodds=TRUE, entropy=TRUE)

###### end Cerebellum ###########


###### start Temporal ###########
TM.motifs <- findMotifFasta("fasta_500_promoter_seq_tm_neg.fa","fasta_500_promoter_seq_tm_neg.fa",max.motif=3,enriched=T)

motifLatexTable(main="FG: positive COMT correlations, BG: negative COMT correlations, Temporal Cortex motifs", TM.motifs, prefix="negnegTM")

plotMotif(TM.motifs$motifs[[1]]@match$pattern, logodds=TRUE, entropy=TRUE)
###### end Temporal ###########

###### start Pons ###########
PO.motifs <- findMotifFasta("fasta_500_promoter_seq_po_neg.fa","fasta_500_promoter_seq_po_neg.fa",max.motif=3,enriched=T)

motifLatexTable(main="FG: positive COMT correlations, BG: negative COMT correlations, Pons motifs", TM.motifs, prefix="negnegPONS")

plotMotif(PO.motifs$motifs[[1]]@match$pattern, logodds=TRUE, entropy=TRUE)
###### end Pons ###########


@

<<background.foreground.DNAletters>>=
# The first function gets the percentages of DNA across ALL promoters in the human genome

all.promoters.DNAletts <- getBackgroundFrequencies(organism = "hg19",
                                                   pseudo.count = 1, 
                                                   quick = TRUE)
neg.lett.freq <- list()

negi <- seq(1,as.integer(length(fasta.by.lett.neg$pf)/1600),1)
neg.lett.freq[[1]] <- lapply(fasta.by.lett.neg$pf[negi], function(x,negi)  table(x), negi)

negi <- seq(1,as.integer(length(fasta.by.lett.neg$cb)/1600),1)
neg.lett.freq[[2]] <- lapply(fasta.by.lett.neg$cb[negi], function(x,negi)  table(x), negi)

negi <- seq(1,as.integer(length(fasta.by.lett.neg$tm)/1600),1)
neg.lett.freq[[3]] <- lapply(fasta.by.lett.neg$tm[negi], function(x,negi)  table(x), negi)

negi <- seq(1,as.integer(length(fasta.by.lett.neg$po)/1600),1)
neg.lett.freq[[4]] <- lapply(fasta.by.lett.neg$po[negi], function(x,negi)  table(x), negi)

neg.corr.lett.freq <- matrix(rep(0,16),ncol=4)

neg.corr.lett.freq[1,] <- colSums(matrix(unlist(neg.lett.freq[[1]]),ncol=4))
neg.corr.lett.freq[2,] <- colSums(matrix(unlist(neg.lett.freq[[2]]),ncol=4))
neg.corr.lett.freq[3,] <- colSums(matrix(unlist(neg.lett.freq[[3]]),ncol=4))
neg.corr.lett.freq[4,] <- colSums(matrix(unlist(neg.lett.freq[[4]]),ncol=4))

neg.corr.lett.freq[1,] <- neg.corr.lett.freq[1,]/sum(neg.corr.lett.freq[1,])
neg.corr.lett.freq[2,] <- neg.corr.lett.freq[2,]/sum(neg.corr.lett.freq[2,])
neg.corr.lett.freq[3,] <- neg.corr.lett.freq[3,]/sum(neg.corr.lett.freq[3,])
neg.corr.lett.freq[4,] <- neg.corr.lett.freq[4,]/sum(neg.corr.lett.freq[4,])


######## negatively correlated
neg.lett.freq <- list()

negi <- seq(1,as.integer(length(fasta.by.lett.neg$pf)/1600),1)
neg.lett.freq[[1]] <- lapply(fasta.by.lett.neg$pf[negi], function(x,negi)  table(x), negi)

negi <- seq(1,as.integer(length(fasta.by.lett.neg$cb)/1600),1)
neg.lett.freq[[2]] <- lapply(fasta.by.lett.neg$cb[negi], function(x,negi)  table(x), negi)

negi <- seq(1,as.integer(length(fasta.by.lett.neg$tm)/1600),1)
neg.lett.freq[[3]] <- lapply(fasta.by.lett.neg$tm[negi], function(x,negi)  table(x), negi)

negi <- seq(1,as.integer(length(fasta.by.lett.neg$po)/1600),1)
neg.lett.freq[[4]] <- lapply(fasta.by.lett.neg$po[negi], function(x,negi)  table(x), negi)

neg.corr.lett.freq <- matrix(rep(0,16),ncol=4)

neg.corr.lett.freq[1,] <- colSums(matrix(unlist(neg.lett.freq[[1]]),ncol=4))
neg.corr.lett.freq[2,] <- colSums(matrix(unlist(neg.lett.freq[[2]]),ncol=4))
neg.corr.lett.freq[3,] <- colSums(matrix(unlist(neg.lett.freq[[3]]),ncol=4))
neg.corr.lett.freq[4,] <- colSums(matrix(unlist(neg.lett.freq[[4]]),ncol=4))

neg.corr.lett.freq[1,] <- neg.corr.lett.freq[1,]/sum(neg.corr.lett.freq[1,])
neg.corr.lett.freq[2,] <- neg.corr.lett.freq[2,]/sum(neg.corr.lett.freq[2,])
neg.corr.lett.freq[3,] <- neg.corr.lett.freq[3,]/sum(neg.corr.lett.freq[3,])
neg.corr.lett.freq[4,] <- neg.corr.lett.freq[4,]/sum(neg.corr.lett.freq[4,])

lett.proportion.matrix <- data.frame(rbind(neg.corr.lett.freq,neg.corr.lett.freq))
colnames(lett.proportion.matrix) <- c('A','C','G','T')
row.names(lett.proportion.matrix) <- c('PFneg',
                                       'CBneg',
                                       'TMneg',
                                       'POneg',
                                       'PFneg',
                                       'CBneg',
                                       'TMneg',
                                       'POneg')

@

<<matchTF.to.Symbols>>=

tf.matches.pf <- match(as.character(tfs.PvN.pf$TF_Name),hold.Lowest.pvals[[1]]$Symbol)
tf.matches.pf

@

<<show.Bob>>=
st.A <- c('TCTGTGGCCCTAGGCC')
st.B <- c('ACAGGTGGACCCCGCA')
st.A.sp <- strsplit(st.A,NULL)
st.B.sp <- strsplit(st.B,NULL)

st.A.sp.c <- c(rep(NA,16))
st.B.sp.c <- c(rep(NA,16))

for (iu in 1:16)  {
     
     if (st.A.sp[[1]][iu] == 'A') {
          st.A.sp.c[iu] <- c('T')
     } else if (st.A.sp[[1]][iu] == 'T') {
          st.A.sp.c[iu] <- c('A')
     } else if (st.A.sp[[1]][iu] == 'C') {
          st.A.sp.c[iu] <- c('G')     
     } else if (st.A.sp[[1]][iu] == 'G') {
          st.A.sp.c[iu] <- c('C') 
     } else {
          
     }
}

for (iu in 1:16)  {
     
     if (st.B.sp[[1]][iu] == 'A') {
          st.B.sp.c[iu] <- c('T')
     } else if (st.B.sp[[1]][iu] == 'T') {
          st.B.sp.c[iu] <- c('A')
     } else if (st.B.sp[[1]][iu] == 'C') {
          st.B.sp.c[iu] <- c('G')     
     } else if (st.B.sp[[1]][iu] == 'G') {
          st.B.sp.c[iu] <- c('C') 
     } else {
          
     }
}


@

<<TATA.boxes>>=

# TATA box sequences

tata.boxes <- c('TATAAAA',
                'TATAAAT',
                'TATATAA',
                'TATATAT')

tata.hits.neg <- list()
tata.hits.neg <- list()

tata.hits.neg <- lapply(seq.neg.fasta[ib], function(x,ib) which(grepl('TATA[AT]A[AT]',x)),ib)
tata.hits.neg <- lapply(seq.neg.fasta[ib], function(x,ib) which(grepl('TATA[AT]A[AT]',x)),ib)

tata.hits.neg <- lapply(seq.neg.fasta[ib], function(x,ib) gregexpr('TATA[AT]A[AT]',x),ib)
tata.hits.neg <- lapply(seq.neg.fasta[ib], function(x,ib) gregexpr('TATA[AT]A[AT]',x),ib)

hist(unlist(tata.hits.neg[[1]][which(tata.hits.neg[[1]] != '-1')]),20)
hist(unlist(tata.hits.neg[[1]][which(tata.hits.neg[[1]] != '-1')]),20)





@




<<tf.hits.comp.negvneg>>=

wbtf <- loadWorkbook('/Volumes/Macintosh_HD_3/genetics/genenetwork2/bob analysis/tf_hits_by_location.xlsx')   

# now tell R to read that workbook and which sheet
# sheet: positive = positively correlated genes, length 6 motifs
# sheet: negative = negatively correlated genes, length 6 motifs
# sheet: neglen7 = positively correlated genes, length 7 motifs
# sheet: neglen7 = negatively correlated genes, length 7 motifs

  neg.hits.Data <- data.frame(read.xlsx(wbtf,sheet = "positive"))
  
  neg.hits.Data <- data.frame(read.xlsx(wbtf,sheet = "negative"))
  
  neg.hits.Data$avgloc <- neg.hits.Data$avgloc - 1001
  neg.hits.Data$avgloc <- neg.hits.Data$avgloc - 1001
  
  colnames(neg.hits.Data)

# colnames for positive and negative sheets
#  [1] "N.Com"  "Cnt"    "Aver"   "str6"   "SndCnt" "Lgest" 
#  [7] "Loc"    "Aver.1" "X9"     "X10"    "X11"    "X12"   
# [13] "X13"    "X14"    "X15"    "X16"    "X17"    "X18"   
# [19] "X19"    "X20"    "X21"    "X22"    "X23"    "X24" 
 
#  Note: bucket sizes are larger for the length 7 motifs 
# colnames for neglen7 and neglen7 sheets
#  [1] "N.Com"  "Cnt"    "Aver"   "str7"   "SndCnt" "Lgest" 
#  [7] "Loc"    "avgloc" "X9"     "X10"    "X11"    "X12"   
# [13] "X13"    "X14"    "X15"    "X16"  

# The following code determines the motifs for which the proportion of negatively-correlated genes is significantly different after Bonferroni correction from the proportion of positively-correlated genes.
  
# colnames str6 for length 6 strings; str7 for length 7 strings
  
match.motifs.negVneg <- matrix(rep(NA,length(neg.hits.Data$str6)),
                               ncol=length(neg.hits.Data$str6))

match.motifs.negVneg <- match(neg.hits.Data$str6,neg.hits.Data$str6)

# length(seq.neg.fasta[[1]])
# [1] 323
# length(seq.neg.fasta[[1]])
# [1] 168

div.num <- c(length(seq.neg.fasta[[1]]),
             length(seq.neg.fasta[[1]]))

comp.prop.motif.hits <- data.frame(neg=rep(0,length(which(!is.na(match.motifs.negVneg)))),
                                   negTot=rep(div.num[1],
                                              length(which(!is.na(match.motifs.negVneg)))),
                                   neg=rep(0,length(which(!is.na(match.motifs.negVneg)))),
                                   negTot=rep(div.num[2],
                                              length(which(!is.na(match.motifs.negVneg)))),
                                   tval=rep(0,length(which(!is.na(match.motifs.negVneg)))),
                                   pval=rep(0,length(which(!is.na(match.motifs.negVneg)))),
                                   motif=rep(NA,length(which(!is.na(match.motifs.negVneg)))))


comp.prop.motif.hits$neg <- neg.hits.Data$SndCnt[which(!is.na(match.motifs.negVneg))]
comp.prop.motif.hits$neg <- (neg.hits.Data$SndCnt[match.motifs.negVneg[which(!is.na(match.motifs.negVneg))]])
comp.prop.motif.hits$motif <- neg.hits.Data$str6[match.motifs.negVneg[which(!is.na(match.motifs.negVneg))]]


ci.propor.vals <- data.frame(prop.neg=rep(NA,length(which(!is.na(match.motifs.negVneg)))),
                         prop.Neg=rep(NA,length(which(!is.na(match.motifs.negVneg)))),
                         motif=rep(NA,length(which(!is.na(match.motifs.negVneg)))),
                         p.value=rep(NA,length(which(!is.na(match.motifs.negVneg)))))

tseq <- seq(1,length(which(!is.na(match.motifs.negVneg))),1)


# ci.propor <- diffscoreci(comp.prop.motif.hits$neg, comp.prop.motif.hits$negTot, 
#                          comp.prop.motif.hits$neg, comp.prop.motif.hits$negTot, 
#             conf.level=0.95)

# for (kl in tseq)   {
# 
#      ci.propor.vals$prop.neg[kl] <- round(comp.prop.motif.hits$neg[kl]/comp.prop.motif.hits$negTot[kl],4)
#      ci.propor.vals$prop.Neg[kl] <- round(comp.prop.motif.hits$neg[kl]/comp.prop.motif.hits$negTot[kl],4)
# 
# }


for (kl in tseq)   {
     
          ci.propor.vals$prop.neg[kl] <- round(comp.prop.motif.hits$neg[kl]/comp.prop.motif.hits$negTot[kl],4)
     ci.propor.vals$prop.Neg[kl] <- round(comp.prop.motif.hits$neg[kl]/comp.prop.motif.hits$negTot[kl],4)
     
     if (ci.propor.vals$prop.neg[kl] > 0.20 & ci.propor.vals$prop.Neg[kl] > 0.2)  {

     # ci.propor[kl] <- prop.test(c(comp.prop.motif.hits$neg[kl],
     #                                comp.prop.motif.hits$neg[kl]),
     #                              c(comp.prop.motif.hits$negTot[kl],
     #                                comp.prop.motif.hits$negTot[kl]),
     #                              alternative=c('two.sided'))
          
          # ci.propor.vals$prop.neg[kl] <- round(comp.prop.motif.hits$neg[kl]/comp.prop.motif.hits$negTot[kl],4)
          # ci.propor.vals$prop.Neg[kl] <- round(comp.prop.motif.hits$neg[kl]/comp.prop.motif.hits$negTot[kl],4)
          ci.propor.vals$motif[kl] <- comp.prop.motif.hits$motif[kl]
          ci.propor.vals$p.value[kl] <- prop.test(c(comp.prop.motif.hits$neg[kl],
                                    comp.prop.motif.hits$neg[kl]),
                                  c(comp.prop.motif.hits$negTot[kl],
                                    comp.prop.motif.hits$negTot[kl]),
                                  alternative=c('two.sided'))$p.value
     
     } else {
     
          ci.propor.vals$p.value[kl] <- c(NA)
          ci.propor.vals$motif[kl] <- comp.prop.motif.hits$motif[kl]
}

}


p20.indx <- c(which(!is.na(ci.propor.vals$p.value)))   # indices of the motifs negsessed by > 20% of promoters

p.Bonfer <- 0.05/length(p20.indx)

np20 <- seq(1,length(p20.indx),1)

sig.motifs.indx <- matrix()
for (yh in np20)  {
     
     if (ci.propor.vals$p.value[p20.indx[yh]] <= p.Bonfer) {
          sig.motifs.indx[yh] <- p20.indx[yh]
     } else {
          sig.motifs.indx[yh] <- NA
     }
}

sig.motifs.indx <- na.omit(sig.motifs.indx)

sig.motifs <- data.frame(motif=ci.propor.vals$motif[c(sig.motifs.indx)],
                         propneg=ci.propor.vals$prop.neg[c(sig.motifs.indx)],
                         propNeg=ci.propor.vals$prop.Neg[c(sig.motifs.indx)],
                         pval=ci.propor.vals$p.value[c(sig.motifs.indx)])

sig.motifs <- sig.motifs[order(sig.motifs$pval,decreasing=FALSE),]

sig.fancy.motifs.tab <- print.xtable(xtable(sig.motifs,
                         caption='Heptamer motifs in the promoter regions of genes in Prefrontal Cortex for which the proportion of positively COMT-correlated genes containing that motif  differs significantly (after Bonferroni correction) from the proportion of negatively COMT-correlated genes containing that motif ordered by p value.',
                         type='latex',
                         floating=FALSE,
                         caption.placement='top',
                         tabular.environment='longtable',
#                         caption.width ='0.5\\textwidth',
#                         hline.after=c(-1,0,nrow(topgene.By.chr.tab)),
                         include.rownames=FALSE,
                         print.results=TRUE,
                         booktabs=TRUE,
#                         comment=TRUE
                         digits=c(0,0,2,2,11)
                         ))

@

<<atVcg.content.promoters>>=

# The negatively correlated genes that had proportionately more instances of a given motif appeared to be A,T enriched over the positively correlated genes.

# First, get the AT vs. CG content of the full promoters for negitvely vs. negatively correlated genes.

# acgt.content.neg <- lapply(neg.lett.freq[ib], function(x,ib) colSums(x)/(1600*dim(x)[1]),ib)
# acgt.content.neg <- lapply(neg.lett.freq[ib], function(x,ib) colSums(x)/(1600*dim(x)[1]),ib)

acgt.content.neg <- lapply(neg.lett.freq[ib], function(x,ib) colSums(x),ib)
acgt.content.neg <- lapply(neg.lett.freq[ib], function(x,ib) colSums(x),ib)

acgt.content.full.promoters <- list(neg=acgt.content.neg,
                                    neg=acgt.content.neg,
                                    neg.Perc=sapply(acgt.content.full.promoters$neg[ib], function(x,ib) x/sum(unlist(x)), ib),
                                    neg.Perc=sapply(acgt.content.full.promoters$neg[ib], function(x,ib) x/sum(unlist(x)), ib))

promoter.content.chsq <- list()
promoter.content <- data.frame(neg=rep(NA,4),
                               neg=rep(NA,4))
row.names(promoter.content) <- c('A','C','G','T')

promoter.content.atVcg.chsq <- list()

promoter500.atVcg <- list()

for (im in ib)   {

     promoter.content <- data.frame(neg=acgt.content.full.promoters$neg[[im]],
                                    neg=acgt.content.full.promoters$neg[[im]])
     
     promoter.content.atVcg <- data.frame(matrix(c(sum(acgt.content.full.promoters$neg[[im]][c(1,4)]),
                                      sum(acgt.content.full.promoters$neg[[im]][c(2,3)]),     
                                      sum(acgt.content.full.promoters$neg[[im]][c(1,4)]),
                                      sum(acgt.content.full.promoters$neg[[im]][c(2,3)])),
                                      ncol=2,byrow=TRUE
                                                    ))
      
     promoter.content.atVcg[,3] <- promoter.content.atVcg[,2]/rowSums(promoter.content.atVcg)
     
     promoter500.atVcg[[im]] <- promoter.content.atVcg
     
     colnames(promoter.content.atVcg) <- c('AT','CG','PercCG')
     row.names(promoter.content.atVcg) <- c('neg','neg')
     
     promoter500.atVcg[[im]] <- promoter.content.atVcg
     
     promoter.content.chsq[[im]] <- chisq.test(promoter.content)
     row.names(promoter.content.chsq[[im]]$observed) <- c('A','C','G','T')
     
     promoter.content.atVcg.chsq[[im]] <- chisq.test(promoter.content.atVcg[,1:2],correct=TRUE)
     row.names(promoter.content.atVcg.chsq[[im]]$observed) <- c('neg','neg')
     
}


sink('dnaLetter_content_chisq_negVneg.txt')
lapply(promoter.content.chsq[ib], function(x,ib) print(x[]), ib)
sink()

sink('dnaLetter_atVcg_content_chisq_negVneg.txt')
lapply(promoter.content.atVcg.chsq[ib], function(x,ib) print(x[]), ib)
sink()


# This computes/checks the chisq.test
promoter.content.pf[,3] <- rowSums(promoter.content.pf)
promoter.content.pf[5,] <- colSums(promoter.content.pf)

promoter.content.pf[1:4,4] <- promoter.content.pf[5,1]*promoter.content.pf[1:4,3]/promoter.content.pf[5,3]
promoter.content.pf[1:4,5] <- promoter.content.pf[5,2]*promoter.content.pf[1:4,3]/promoter.content.pf[5,3]

x.sq <- sum(((promoter.content.pf[1:4,1] - promoter.content.pf[1:4,4])^2)/promoter.content.pf[1:4,4]) + sum(((promoter.content.pf[1:4,2] - promoter.content.pf[1:4,5])^2)/promoter.content.pf[1:4,5])

x.sq
# end check chisq.test



@

<<promoter.content.proportions>>=




@




<<>>=
# Reverse, complement and Reverse-complement the set of significant motifs to check against original set

motifs.DNA <- DNAStringSet(x=sig.motifs$motif)
motifs.DNA.rev <- reverse(motifs.DNA)
motifs.DNA.compl <- complement(motifs.DNA)
motifs.DNA.revCompl <- reverseComplement(motifs.DNA)

comp.motifs.rev.comp <- list(rev=matrix(rep(FALSE,length(motifs.DNA)*length(motifs.DNA)),
                                    ncol=length(motifs.DNA)),
                             compl=matrix(rep(FALSE,length(motifs.DNA)*length(motifs.DNA)),
                                    ncol=length(motifs.DNA)),       
                             revCompl=matrix(rep(FALSE,length(motifs.DNA)*length(motifs.DNA)),
                                    ncol=length(motifs.DNA))       
                                    )
     

for (hj in 1:length(motifs.DNA)) {
     
     for (nk in 1:length(motifs.DNA))  {
     
          if (motifs.DNA[[hj]] == motifs.DNA.rev[[nk]])  {
              comp.motifs.rev.comp$rev[nk,hj] = TRUE 
          }
          
          if (motifs.DNA[[hj]] == motifs.DNA.compl[[nk]])  {
              comp.motifs.rev.comp$compl[nk,hj] = TRUE 
          }
          
          if (motifs.DNA[[hj]] == motifs.DNA.revCompl[[nk]])  {
              comp.motifs.rev.comp$revCompl[nk,hj] = TRUE 
          }
     
     }
     
}


@

<<loc.sign.motifs>>=

#gregexpr(pattern ='2',"the2quickbrownfoxeswere2tired")

sig.motifs.indx <- list(neg=list(),
                        neg=list())

 for (gh in 1:length(motifs.DNA))  {
    
     
     
     sig.motifs.indx$neg[[gh]] <- gregexpr(pattern = motifs.DNA[gh],seq.neg.fasta[[1]],
                                         fixed=TRUE)
     sig.motifs.indx$neg[[gh]] <- gregexpr(pattern = motifs.DNA[gh],seq.neg.fasta[[1]],
                                         fixed=TRUE)
}


# Get a matrix with the negitions 
neg.motif.hits <- list()

for (uj in 1:length(motifs.DNA)) {
     
     temp.vec <- matrix()
     
     for (kl in 1:length(sig.motifs.indx$neg))    {
     
     if (unlist(sig.motifs.indx$neg[[uj]][kl])[1] > -1)  {
          temp.vec <- c(temp.vec,
                       c(unlist(sig.motifs.indx$neg[[uj]][kl]) - 1001))
     } else {
          
     }
  } 
     neg.motif.hits[[uj]] <- temp.vec
}

neg.motif.hits <- list()

for (uj in 1:length(motifs.DNA)) {
     
     temp.vec <- matrix()
     
     for (kl in 1:length(sig.motifs.indx$neg))    {
     
     if (unlist(sig.motifs.indx$neg[[uj]][kl])[1] > -1)  {
          temp.vec <- c(temp.vec,
                       c(unlist(sig.motifs.indx$neg[[uj]][kl]) - 1001))
     } else {
          
     }
  } 
     neg.motif.hits[[uj]] <- temp.vec
}


@

<<dinucleotide.probs>>=


dinuc.sum <- (nchar(seq.fasta[[1]][1]) - 1)*length(seq.fasta[[1]])
fasta.strings <- DNAStringSet(x=as.character(seq.fasta[[1]]))


# dinucl.prob contains the probability of observing AA, AC, AG, AT, CA, CC, etc. across all of the fasta sequences
dinucl.prob <- colSums(dinucleotideFrequency(fasta.strings))/dinuc.sum

dinucl.motifs <- dinucleotideFrequency(motifs.DNA)

motifs.freq <- c()

for (kl in 1:dim(dinucl.motifs)[1])   {

          motifs.freq[kl] <- (exp(sum(dinucl.motifs[kl,]*log(dinucl.prob))))*dinuc.sum

}




@



<< >>=

# This is used below in the ontology analysis section.

# Which genes show the largest variance in COMT-correlation coefficients across brain areas?
# Need to find out which genes were measured in all four brain areas - do this using the onegene 
# data

all.Areas.symbols <- na.omit(intersect(intersect(intersect(na.omit(prefront.Data.onegene$Symbol),na.omit(cbell.Data.onegene$Symbol)),na.omit(tempor.Data.onegene$Symbol)),na.omit(pons.Data.onegene$Symbol)))

# This leaves 10636 genes in common across the brain areas
pf.common.Genes.indx <- match(all.Areas.symbols,prefront.Data.onegene$Symbol)
cb.common.Genes.indx <- match(all.Areas.symbols,cbell.Data.onegene$Symbol)
tm.common.Genes.indx <- match(all.Areas.symbols,tempor.Data.onegene$Symbol)
po.common.Genes.indx <- match(all.Areas.symbols,pons.Data.onegene$Symbol)
# 
area.colwise <- data.frame(pf.a = prefront.Data.onegene$Symbol[pf.common.Genes.indx],
           cb.a = cbell.Data.onegene$Symbol[cb.common.Genes.indx],
           tm.a = tempor.Data.onegene$Symbol[tm.common.Genes.indx],
           po.a = pons.Data.onegene$Symbol[po.common.Genes.indx],
           pf.m = prefront.Data.onegene$Mean[pf.common.Genes.indx],
           cb.m = cbell.Data.onegene$Mean[pf.common.Genes.indx],
           tm.m = tempor.Data.onegene$Mean[pf.common.Genes.indx],
           po.m = pons.Data.onegene$Mean[pf.common.Genes.indx],
           pf.r = prefront.Data.onegene$Sample.r[pf.common.Genes.indx],
           cb.r = cbell.Data.onegene$Sample.r[cb.common.Genes.indx],
           tm.r = tempor.Data.onegene$Sample.r[tm.common.Genes.indx],
           po.r = pons.Data.onegene$Sample.r[po.common.Genes.indx])
# 
area.colwise$ENTREZID <- prefront.Data.onegene$ENTREZID[pf.common.Genes.indx]
# 
# 

# Determine for each gene whether the correlation with COMT expression was above or
# below the average correlation WITHIN a brain area

# First use Fisher's Z-transformation to convert the correlations to z scores.

r2Z <- function (r.in) 0.5*(log(1.0 + r.in) - log(1.0 - r.in))    # Fisher's r to Z

fix.dim <- dim(area.colwise)[2]
area.colwise[,(fix.dim + 1:4)] <- r2Z(area.colwise[,(fix.dim - 4:1)])
colnames(area.colwise)[(fix.dim + 1:4)] <- c('pf.Z','cb.Z','tm.Z','po.Z')

area.colwise$pf.z <- scale(area.colwise$pf.Z,center=TRUE,scale=TRUE) 
area.colwise$cb.z <- scale(area.colwise$cb.Z,center=TRUE,scale=TRUE)
area.colwise$tm.z <- scale(area.colwise$tm.Z,center=TRUE,scale=TRUE)
area.colwise$po.z <- scale(area.colwise$po.Z,center=TRUE,scale=TRUE)

fix.dim <- dim(area.colwise)[2]
area.colwise[,(fix.dim + 1:4)] <- sign(area.colwise[,(fix.dim - 3:0)])

# sign of the z-scored correlation further normalized (z-scored within a brain area)
fix.dim <- dim(area.colwise)[2]
colnames(area.colwise)[(fix.dim - 3:0)] <- c('pf.zsign','cb.zsign','tm.zsign','po.zsign')

fix.dim <- dim(area.colwise)[2]
sign.tab <- table(area.colwise[,(fix.dim - 3:0)])
 
summary(sign.tab)
sign.tab2 <- data.frame(sign.tab)

sign.tab3 <- structable(area.colwise[,22:25])


@

March 19, 2018\\
Using the following steps:
\begin{enumerate}
     \item All {\textit {COMT}}-correlations are Z transformed using Fisher's formula.
     \item Within a brain region, these Fisher Z scores are z-scored (x - m)/s.
     \item These z-scores are then converted to signs (+ or -).
     \item A plus sign means that gene in that brain area had a correlation that was above the average correlation for all genes in that brain area.
     \item A minus sign means that gene in that brain area had a correlation that was below the average correlation for all genes in that brain area.
\end{enumerate}

Using this order for brain areas: Prefrontal, Cerebellum, Temporal, Pons - the following sign patterns are indicative of:
\begin{enumerate}
     \item Tissue {\textit {non-specific}} expression regulation: +1, +1, +1, +1 or -1, -1, -1, -1
     \item Prefrontal-specific regulation: -1, +1, +1, +1 or +1, -1, -1, -1
     \item Cerebellum-specific regulation: +1, -1, +1, +1 or -1, +1, -1, -1
     \item Temporal-specific regulation: +1, +1, -1, +1 or -1, -1, +1, -1
     \item Pons-specific regulation: +1, +1, +1, -1 or -1, -1, -1, +1
\end{enumerate}

The table in the file zsign_tab.pdf shows that a very large proportion of the genes exhibited the first pattern above indicating tissue {\textit {non-specific}} expression regulation. There were, however, nontrivial numbers of genes who showed one of the other four patterns. By classifying the genes into the other four categories above, it should be negsible to do ontology to discover what networks or functions those genes might exhibit.

<< >>=
# Classify genes into one of the four tissue specific regulation patterns, or the tissue nonspecific pattern.

hold.binary <- matrix(rep(0,5*dim(area.colwise)[1]),ncol=5)
hold.binary[,1:4] <- c((area.colwise$pf.zsign + 1)/2,
                       (area.colwise$cb.zsign + 1)/2,
                       (area.colwise$tm.zsign + 1)/2,
                       (area.colwise$po.zsign + 1)/2
                       )
hold.binary[,5] <- (hold.binary[,1])*(2^3) + (hold.binary[,2])*(2^2) + (hold.binary[,3])*(2^1) + (hold.binary[,4])*(2^0)

# hold.binary[,5] holds the numbers 0:15. The z-score signs (e.g., pf.zsign) were first transfortmed from -1, +1 to 0,+1. Then using the above numbers 8, 4, 2, 1, unique numbers designating the different negsible patterns of relationships between correlations (above or below the area-specific average correlation) were obtained. Pairs of numbers represent different types of expression regulation: 4 pairs represent area-specific regulation, and 1 pair represents area (tissue) nonspecific regulation. For example the numbers 0 and 15 represent area nonspecific regulation because the correlations in all four brain areas are above the average correlation in their respective brain areas or all of them are below. The numbers 7 and 8 represent PF-specific regulation.

area.colwise$signClass <- hold.binary[,5]

pf.specific.up <- subset(area.colwise,area.colwise$signClass == 8)
pf.specific.down <- subset(area.colwise,area.colwise$signClass == 7)
pf.specific <- subset(area.colwise,area.colwise$signClass == 7 | area.colwise$signClass == 8)
pf.specific$shuffSymb <- sample(pf.specific$pf.a,dim(pf.specific)[1],replace=FALSE)





@




<< >>=
# 
# # Do the same analysis for mean expression level
# ############************ First z-score the mean expression levels to remove between probeset effects
# 
area.colwise$zscorepf <- scale(area.colwise$pf.m,center=T,scale=T)
area.colwise$zscorecb <- scale(area.colwise$cb.m,center=T,scale=T)
area.colwise$zscoretm <- scale(area.colwise$tm.m,center=T,scale=T)
area.colwise$zscorepo <- scale(area.colwise$po.m,center=T,scale=T)

# Now calculate mean and variance

avg.expr <- rowMeans(area.colwise[,14:17])

var.expr <- rowVars(as.matrix(area.colwise[,14:17]))

# Now calculate the coefficient of variation for the correlation coefficient
coeff.Var.expr <- matrix(rep(0,length(avg.expr)),ncol=1)

coeff.Var.expr <- sqrt(var.expr)/abs(avg.expr)

# Now add columns to area.colwise

area.colwise$avg.expr <- avg.expr
area.colwise$varnc.expr <- var.expr
area.colwise$coeffVar.expr <- coeff.Var.expr

# Order by expression CV
area.colwise <- area.colwise[order(area.colwise$coeffVar.expr,decreasing=TRUE),]

area.colwise[1:20,1]

@ 


% latex table generated in R 3.4.3 by xtable 1.8-2 package
% Wed Feb 21 08:07:04 2018
\begin{table}[ht]
\centering
%\begin{tabular}{lllllll}
\begin{tabular}{l >{\itshape}l >{\itshape}l >{\itshape}l >{\itshape}l >{\itshape}l >{\itshape}l }
  \hline
&  &  &  &  & \\ 
  \hline
{\bfseries{Cerebellum}} &   &   &   &   \\ 
& GPM6B & PMP22 & CPQ & COMT & MYO6 \\ 
& GPM6B & SEC22C & CAT & ATRAID & PPIB \\
{\bfseries{Temporal Cerebral Wall}} &   &   &   &   \\ 
& GPM6B & NTSR2 & PMP22 & EDNRB & PKM \\ 
& GATM & CDC14B & PTTG1IP & ECH1 & HSCB \\ 
& GPM6B & SEC22C & DTYMK & TSPO & CSTB \\ 
& MGLL & SLC3A2 & COMT & MEGF10 & ACY1 \\ 
& CAT & PLPP3 & CLDN10 & FGFR3 &   \\ 
{\bfseries{Pons}} &   &   &   &   \\ 
& GPM6B & SEC22C & GPM6B & GATM & CLU \\ 
& C2ORF28 & COMT & PMP22 & CAT & MEGF10 \\ 
   \hline
\end{tabular}
\caption{Genes having the strongest positively correlated expression with \textit{COMT} in each area also among the 50 most strongly \textit{COMT}-correlated genes in Prefrontal Cortex} 
\end{table}





<<include=FALSE, echo=False, results=tex >>=
# Generate tables that show which genes were most strongly positively or negatively correlated with COMT expression on a per chromosome basis.

for (b in 1:8)  {
########## DEBUG 

#b <- c(2)

########## END DEBUG

temp.Hold <- area.onegene.List[[b]][neg.neg.Lims[b,1]:neg.neg.Lims[b,2],]

temp.Hold2 <- temp.Hold[order(temp.Hold$loc),]

temp.tab <- table(temp.Hold2$loc)

temp.tab.seq <- matrix(rep(0,46),nrow=23)
temp.tab.seq[1,1:2] <- c(1,temp.tab[1])

for (i in 2:23) {
     temp.tab.seq[i,1] <- temp.tab.seq[i-1,2] + 1
     temp.tab.seq[i,2] <- temp.tab.seq[i,1] + temp.tab[i] -1
                       
}

fname <- paste0('topgenes_by_chr_',sign.Names[b],'_',rep(stand.Col.names,each=2)[b],'.txt',sep='')
fnameinput <- paste0('readable_topgenes_by_chr_',sign.Names[b],'_',rep(stand.Col.names,each=2)[b],'.csv',sep='')
write(paste(rep(stand.Col.names,each=2)[b],' ',sign.Names[b],'\n',sep=''),file=fname,append=FALSE)

for (j in 1:23)     {
     # Human readable
     write(print(paste('Chromosome ',map.Chrname.Chrnum$chrnum[j],sep=''),quote=FALSE),append=TRUE,
           ncolumns=8,file=fname,sep='\t')
     write(print(temp.Hold2[temp.tab.seq[chrname2num[j],1]:temp.tab.seq[chrname2num[j],2],3],rownames=FALSE,quote=FALSE),append=TRUE,ncolumns=8,file=fname,sep='\t')
     write(print(''),file=fname,append=TRUE)
     
     # R readable csv
     hold.Genes <- c(temp.Hold2[temp.tab.seq[chrname2num[j],1]:temp.tab.seq[chrname2num[j],2],3])
     hold.Genes[2:(length(hold.Genes) + 1)] <- hold.Genes
     hold.Genes[1] <- as.character(map.Chrname.Chrnum$chrnum[j])
     # write(print(temp.Hold2[temp.tab.seq[chrname2num[j],1]:temp.tab.seq[chrname2num[j],2],3],rownames=FALSE,quote=FALSE),append=TRUE,ncolumns=8,file=fnameinput,sep=', ')
     
     write(print(hold.Genes,rownames=FALSE,quote=FALSE),ncolumns=30,append=TRUE,file=fnameinput,sep=', ')

}

} # end brain area x sign loop 
@ 

<<include=FALSE, echo=FALSE, results=tex>>=
# Because only prefrontal negative and temporal negative showed significant chi-squares when
# comparing the observed distribution of 200 genes across chromosomes to the expected distribution
# based on the overall sample of genes whose expression levels were measured, and because 
# Chromosome 5 for both brain areas was the area that showed significantly more genes than would have # been expected (binomial tests), determine which genes on chromosome 5 among the 200 most strongly
# negatively coprrelated genes were in common across the two brain areas.

wbgc <- loadWorkbook('readabletopgenes_by_chr.xlsx')   

# now tell R to read that workbook and which sheet
  pf.Neg <- read.xlsx(wbgc,sheet = "pfneg",colNames=FALSE,rowNames=TRUE,na.strings=NA)
  tm.Neg <- read.xlsx(wbgc,sheet = "tmneg",colNames=FALSE,rowNames=TRUE,na.strings=NA)

  num.Genes.neg.Chr5 <- data.frame(area=c('Prefrontal','Temporal'),
                                   number=c(length(pf.Neg[5,]),length(tm.Neg[5,])))
  
genes.Shared.neg.chr5 <- tm.Neg[5,c(na.omit(match(pf.Neg[5,],tm.Neg[5,])))]

common.genes.Chr5.neg <- list()
common.genes.Chr5.neg[[1]] <- num.Genes.neg.Chr5   # Number of genes in top 200 not the shared ones
common.genes.Chr5.neg[[2]] <- sub(' ','',genes.Shared.neg.chr5)

# Get the ENTREZIDs for the genes in common

common.neg.Chr5.entrez <- matrix(rep(NA,length(common.genes.Chr5.neg[[2]])),
                                 ncol=1)

for (w in 1:length(common.genes.Chr5.neg[[2]])) {
    
           
    common.neg.Chr5.entrez[w]  <- area.List.byGene[[1]]$ENTREZID[(which(area.List.byGene[[1]]$Symbol == common.genes.Chr5.neg[[2]][w]))]
    
}
common.genes.Chr5.neg[[3]] <- common.neg.Chr5.entrez
common.neg.Genes.Chr5 <- data.frame(genes=common.genes.Chr5.neg[[2]],
                                    ENTREZID=common.genes.Chr5.neg[[3]])

########### *************** Transcriptiopn factors analysis using PFAM
temp.start.neg <- getBM(attributes = c('hgnc_symbol',"start_negition",'entrezgene',"refseq_mrna"), 
                                        filters = "entrezgene",
                                        values = as.character(common.neg.Genes.Chr5$ENTREZID), 
                                        mart = ensembl)
comt.getBM <- getBM(attributes = c('hgnc_symbol',"start_negition",'entrezgene',"refseq_mrna"), 
                                        filters = "hgnc_symbol",
                                        values = as.character('COMT'), 
                                        mart = ensembl)

wbts <- loadWorkbook('tsfactors_shared_8_and_comt_pscan.xlsx')
# wbhsa2 <- loadWorkbook('comt_coex_list_500_hsa2.xlsx')
# wbhsa3 <- loadWorkbook('comt_coex_list_500_hsa3.xlsx')

shared8.tfacts <- data.frame(read.xlsx(wbts,         # now tell R to read that workbook and which sheet
                                  sheet = "shared_8"))

comt.tfacts <- data.frame(read.xlsx(wbts,         # now tell R to read that workbook and which sheet
                                  sheet = "comt"))

shared8.comt.tsfactors.indx <- match(comt.tfacts$TF.NAME,shared8.tfacts$TF.NAME)
shared8.tfacts[shared8.comt.tsfactors.indx[1:10],]

one.genelims.pf <- c(rep(NA,2))
one.genelims.pf[1] <- length(prefront.Data.onegene$Symbol)
one.genelims.pf[2] <- length(prefront.Data.onegene$Symbol) - 199

na.omit(match(prefront.Data.onegene$Symbol[one.genelims.pf[1]:one.genelims.pf[2]],comt.tfacts$TF.NAME))

na.omit(match(prefront.Data.onegene$Symbol[1:200],comt.tfacts$TF.NAME))
################## END Transcription factor analysis ##########################


gene.Output.order <- match(common.neg.Genes.Chr5$genes,temp.start.neg$hgnc_symbol)

common.neg.Genes.Chr5$startneg <- temp.start.neg$start_negition[c(gene.Output.order)]/1000000.

# order by start negition
common.neg.Genes.Chr5 <- common.neg.Genes.Chr5[order(common.neg.Genes.Chr5$startneg,
                                                     decreasing=FALSE),]
common.neg.Genes.Chr5$placehold <- c(0,
                                     0,
                                     0.04,
                                     0,
                                     0.04,
                                     0.08,
                                     0.12,
                                     0)



genes8.chr5.Plt <-   ggplot(data=common.neg.Genes.Chr5, aes(x=round(startneg,2),
                                                            y=placehold),
                                                            label=genes) +
              geom_point(color = "black",size=1.5,shape=25,fill='black') + 
              geom_text(aes(label=genes),hjust=1.2, vjust = 0.5,
                        size=1.8) +

    #            theme(aspect.ratio=1) +
    scale_y_continuous(name='',
                       limits=c(0,0.9)) +
    scale_x_continuous(name='Gene Start negition (Mb)',
                       breaks = pretty_breaks(n = 8),
                       limits=c(40,round(chrom.Data$chrom.Length[5]/1000000.,0))
                       ) +
     
    labs(title="Strongly Negatively Correlated Genes in Common between Prefrontal Cortex and Temporal Cortex") 

#    theme_minimal() + 
    theme_classic() + 
    theme(aspect.ratio=0.4) +
    theme(axis.line.x = element_line(colour = "black",size=0.25)) +
     theme(axis.line.y = element_line(colour = "white",size=0.25),               
           axis.ticks.y = element_blank()) +
#    theme(plot.title = '') + 
    theme(axis.title = element_text(color="black",
                                    size=10,
                                    margin = margin(t = 4, r = 4, b = 0, l = 0)
                                    )) +
    theme(axis.text.x = element_text(size=10,
                                     margin = margin(t = 4, r = 0, b = 0, l = 0)),
          axis.text.y = 'none') + 

annotate("text", x = 160,
             y = 0.5,
             label = "cd949340d2d8b03116818001a9139944", 
             parse=FALSE,
             color="gray30",
             size=1.0,
         angle=0)    +
     
     annotate("text", x = 160,
             y = 0.6,
             label = "Nearly overlapping negitions have been \n displaced vertically for clarity.", 
             parse=FALSE,
             color="gray30",
             size=2.0,
         angle=0)    +
     
     annotate("text", x = 110,
             y = 0.42,
             label = c('Start negitions of the Eight Genes on Chromosome 5 in Common in both  Prefrontal Cortex and Temporal Cortex among the 200 Most Strongly Negatively Correlated Genes'), 
             parse=FALSE,
             color="black",
             size=3.5,
             fontface='bold')


genes8.chr5.Plt

# save plots to file
     
     # ggsave(c('start_negitions_8_on_chr5.pdf'), 
     #        plot = genes8.chr5.Plt, device = NULL, path = NULL,
     #              scale = 1, width = 8, height = 4, units = c("in"),
     #              dpi = 1200, limitsize = TRUE)

@

There were \Sexpr{common.genes.Chr5.neg[[1]][1,2]} and \Sexpr{common.genes.Chr5.neg[[1]][2,2]} genes on Chromosome 5 in \Sexpr{common.genes.Chr5.neg[[1]][1,1]} cortex and \Sexpr{common.genes.Chr5.neg[[1]][2,1]} cortex, respectively that were among the 200 most strongly negatively {\textit {COMT}}-correlated genes. There were \Sexpr{length(common.genes.Chr5.neg[[2]])} genes in common in these two sets of \Sexpr{common.genes.Chr5.neg[[1]][1,2]} genes.\\


Here is the plot of the starting negitions of those 8 genes:\\

\includegraphics{start_negitions_8_on_chr5}\vspace{3em}

The file transcription_factors_shared8_chr5-coExpressed-genes.txt was produced by the web site genefriends.org. It shows transcription factors that are co\den expressed with the eight shared genes on Chromosome 5. The first line of the file shows that the transcription factor SLC30A9, is shared by 6 of these 8 genes.

<<>>=
# Dendrogram plots of the relations between the 8 shared genes on Chr 5
# For MR
MR.dat <- read.delim("LocLocMR.tbl")
MR.dat <- MR.dat[,2:9]
MR.dist <- as.dist(log10(MR.dat))
MR.hc <- hclust(MR.dist, method="complete")
plot (MR.hc, hang=-1)
# For COR
COR.dat <- read.delim("LocLocCOR.tbl")
COR.dat <- COR.dat[,2:9]
COR.dist <- as.dist(1 - COR.dat)
COR.hc <- hclust(COR.dist, method="complete")
plot (COR.hc, hang=-1)


@


\vspace{-1em}\hspace{2em}
{\tiny{Note: Chr 23 = X and Chr 24 = Y}}\\


Plot of Number of genes per chromosome by chromosome length\\
\begin{figure}[H]
\begin{center}
<<label=plotChrcountvsLength, fig=TRUE,  echo = FALSE, include=FALSE >>= , pdf=FALSE, eps=TRUE 

area.Plot <- list()


for (k in ib) { 

     raw.Chr.count <- matrix(rep(NA,72),ncol=3)
     raw.Chr.count <- as.data.frame(raw.Chr.count)
     colnames(raw.Chr.count) <- c('ChrLabel','Gene.Count','Chromosome.Length')
     raw.Chr.count$ChrLabel <- c(as.character(c(1:22)),'X','Y')
     raw.Chr.count$Chromosome.Length <- chrom.Data$chrom.Length/1000000.

#     raw.Chr.count$Gene.Count <- c(table(area.onegene.List[[k]]$loc)[c(mapIndx[1:24])])
     raw.Chr.count$Gene.Count <- c(table(major.Area[[k]]$loc)[c(chrname2num)])
     corval <- round(cor(raw.Chr.count$Chromosome.Length,raw.Chr.count$Gene.Count,
                      method=c('pearson')),2)


numgenesvslength.Plt <-   ggplot(raw.Chr.count, aes(x=(Chromosome.Length),y=Gene.Count,
                                                     label=ChrLabel)) +
              geom_point(color = "blue",size=1.0) + 
              geom_text(aes(label=ChrLabel),hjust=.5, vjust=-.75,
                        size=2.5) +
              stat_smooth(method='lm',   # Add linear regression line
                geom='smooth',
                se=FALSE,
                color="red",
                size = 0.5,
                fullrange=TRUE,
                formula=y ~ x)  +  # Don't add shaded confidence region
    #            theme(aspect.ratio=1) +
    scale_y_continuous(name='Number of Genes',
                       limits=c(0,1.1*max(raw.Chr.count$Gene.Count))) +
    scale_x_continuous(name='Length of Chromosome (Mb)',
                       limits=c(25,275),
                       breaks = pretty_breaks(n = 8)) +
    ggtitle('Number of Genes by Chromosome versus Chromosome Length') + 
#    theme_minimal() + 
    theme_classic() + 
    theme(aspect.ratio=1/(gold.R^2)) +
    theme(axis.line = element_line(colour = "black",size=0.25)) +
    theme(plot.title = element_text(color="black",
                                    face="bold",
                                    size=10,
                                    hjust=0.5)) +
    theme(axis.title = element_text(color="black",
                                    size=10,
                                    margin = margin(t = 4, r = 4, b = 0, l = 0)
                                    )) +
    theme(axis.text.x = element_text(size=10,
                                     margin = margin(t = 4, r = 0, b = 0, l = 0)),
          axis.text.y = element_text(size=10,
                                     margin = margin(t = 0, r = 2, b = 0, l = 0))) + 
    annotate("text", x = c(50),
             y = c(1600),
             label = c(paste('r = ',toString(corval),sep='')),
             color="black",
             size=3) +
     
     annotate("text", x = c(52),
             y = c(1720),
             label = stand.Col.names[k],
             color="black",
             size=3)
  
area.Plot[[k]] <- numgenesvslength.Plt

# save plots to file

ggsave(c(paste('plot_Chrcount_vs_Length_',stand.Col.names[k],'.pdf',sep='')), plot =                   area.Plot[[k]], device = NULL, path = NULL,
                  scale = 1, width = 8, height = 5, units = c("in"),
                  dpi = 300, limitsize = TRUE)

     # genesvlength <- paste('plot_Chrcount_vs_Length_',stand.Col.names[k],'.eps',sep='')
     #      setEPS()
     #      negtscript(genesvlength,width=8,height=6)
     #      area.Plot[[k]]
     #      dev.off()
} # end area loop

@

\includegraphics[width=\textwidth]{plot_Chrcount_vs_Length_Prefrontal.pdf}\vspace{3em}
\includegraphics[width=\textwidth]{plot_Chrcount_vs_Length_Cerebellum.pdf}\vspace{3em}
\includegraphics[width=\textwidth]{plot_Chrcount_vs_Length_Temporal.pdf}\vspace{3em}
\includegraphics[width=\textwidth]{plot_Chrcount_vs_Length_Pons.pdf}\vspace{3em}

\end{center}
\end{figure}

<<include=FALSE, echo=FALSE, results=hide>>=
# Histogram of top 200 +/- genes starting negitions on Chromosome 22: the Chr that holds 
# MB-COMT

# Get the length of the COMT gene
comt.Specs <- c()
comt.Specs <- getBM(attributes = c("illumina_humanref_8_v3", "hgnc_symbol",
                                         "chromosome_name", "start_negition","end_negition",
                                         "entrezgene"), 
                                         filters = "illumina_humanref_8_v3", 
                          values = as.character('ILMN_1810941'), mart = ensembl)
comt.Length <- round((comt.Specs$end_negition - comt.Specs$start_negition)/1000000.,3)

i <- c(1)

 chr.22 <- subset(major.Area[[i]],major.Area[[i]]$loc=='22')
#chr.22 <- subset(hold.Lowest.pvals[[i]],hold.Lowest.pvals[[i]]$loc=='22')

medr.neg <- median(as.numeric(subset(chr.22,chr.22$corsign == '1')$Sample.r))
medr.Neg <- median(as.numeric(subset(chr.22,chr.22$corsign == '-1')$Sample.r))

# sign.bp <-  data.frame(direct=chr.22.pf$corsign,
#                                startLoc=chr.22.pf$bp)

phist <- ggplot(data=chr.22, aes(as.numeric(chr.22$bp))) + geom_histogram() +
     
     geom_vline(data=chr.22,aes(xintercept=as.numeric(prefront.Data$bp[1])),
                color='red') +
     stat_bin(binwidth=c(1))
     
     to_string <- as_labeller(c(`-1` = "negative", `1` = "positive"))
     
phista <- phist +  facet_wrap(~ corsign,nrow=2,labeller = to_string) +
          
     scale_y_continuous(name='Frequency',
                       limits=c(0,30)) +     
          
     theme_bw() +
     theme(strip.background=element_rect(fill="gray90")) +
     theme(strip.text = element_text(colour = 'black')) +
     
     labs(x = c("Gene Starting negition (Mb)"),
          y = c('Frequency'),
          title = c(paste('Distribution of Gene Transcription Start negitions \n',
                          stand.Col.names[i],sep=''))) +
     theme(axis.text=element_text(size=7),
        axis.title=element_text(size=9)) +
     theme(plot.title=element_text(size=10,
                                   hjust=0.5)) +
          
          annotate("text", x = 0.90*as.numeric(prefront.Data$bp[1]),
             y = c(28),
             label = "MB-italic(COMT)", 
             parse=TRUE,
             color="black",
             size=2)

 phista
     # save plots to file
     
     # hist.22 <- paste('histogram_start_negitions_Chr22_',stand.Col.names[i],'.eps',sep='')
     #      setEPS()
     #      negtscript(hist.22,width=8,height=6)
     #      phista
     #      dev.off()

# Plot correlation vs. starting negition for all genes on Chr 22 

for (i in ib)  {

chr.22 <- subset(major.Area[[i]],major.Area[[i]]$loc=='22')
#chr.22 <- subset(hold.Lowest.pvals[[i]],hold.Lowest.pvals[[i]]$loc=='22')

medr.neg <- median(as.numeric(subset(chr.22,chr.22$corsign == '1')$Sample.r))
medr.Neg <- median(as.numeric(subset(chr.22,chr.22$corsign == '-1')$Sample.r))
 
comt.Extent <- data.frame(xmin=(comt.Specs$start_negition/1000000.), 
                          xmax = (comt.Specs$end_negition/1000000.),   
                          ymin = -1.0, 
                          ymax = 1.0) 
 

cor.Vs.start <- ggplot(data=chr.22, aes(x=as.numeric(chr.22$bp),y=as.numeric(chr.22$Sample.r),
                                        color=chr.22$Sample.r)) +

          geom_point(size=0.75) +
     
     geom_rug(sides="r",alpha=1/2,size=0.25)   +

     geom_rect(data=comt.Extent,mapping=aes(xmin=xmin,
                                         ymin=ymin,
                                         xmax=xmax,
                                         ymax=ymax),
                    stat='identity',
                    fill='red',
                    alpha=c(0.85),inherit.aes = FALSE) +
     
     scale_color_gradient2(low = cbPalette[2], mid = "gray50",
               high = "blue", midpoint = 0, space = "Lab",
               na.value = "grey50", guide = FALSE,                            # "colorbar",
               limits=c(-1, 1)) +
     
     # geom_vline(data=chr.22,aes(xintercept=as.numeric(prefront.Data$bp[1])),
     #            color=muted('green'),size=0.4,
     #            linetype='dashed') +
     
     
     geom_hline(data=chr.22,aes(yintercept=medr.neg),
                color='black',size=0.5,
                linetype='dotted') +
     
     geom_hline(data=chr.22,aes(yintercept=medr.Neg),
                color='black',size=0.5,
                linetype='dotted') +
     
          
     scale_y_continuous(name='Correlation Coefficient, r',
                       limits=c(-1,1)) +  
          
     theme_bw() +
     
     labs(color = "Correlation", size=9) +

     labs(x = c("Gene Starting negition (Mb)"),
          y = c('Correlation Coefficient, r'),
          title = c(paste('Correlation Coefficient vs Gene Start negition \n',
                          'on Chromosome 22: ',stand.Col.names[i],sep=''))) +
     theme(axis.text=element_text(size=7),
        axis.title=element_text(size=9)) +
     theme(plot.title=element_text(size=10,
                                   hjust=0.5)) +
     
     # theme(legend.text = element_text(colour="black", size=7))     +
     # 
     # theme(legend.title = element_text(colour="black", size=9))    +
          
          annotate("text", x = 16,#0.92*(as.numeric(comt.Specs$start_negition/1000000.)),
             y = c(1.0),
             label = "MB-italic(COMT)",
             parse=TRUE,
             color="black",
             size=2) +

# annotate("text", x = 0.92*(as.numeric(comt.Specs$start_negition/1000000.)),
#              y = as.numeric(chr.22$Sample.r[which(chr.22$Symbol == 'COMT')]),
#              label = "S-italic(COMT)", 
#              parse=TRUE,
#              color="black",
#              size=2)  +

annotate("text", x = 51,
             y = -0.7,
             label = "a6f130dfc50751804905a7da48141392", 
             parse=FALSE,
             color="gray30",
             size=1.0,
         angle=-90)    +

annotate("text", x = 45,
             y = 1.0,
             label = "Note: dotted lines are medians.\n Red rect is extent of COMT gene.", 
             parse=FALSE,
             color="gray30",
             size=2.0)

cor.Vs.start


     # save plots to file pdf   - plots already saved
     
          ggsave(c(paste(new_plots,'corr_vs_start_negitions_Chr22_',stand.Col.names[i],'.pdf',sep='')), plot =                   cor.Vs.start, device = NULL, path = NULL,
                  scale = 1, width = 8, height = 5, units = c("in"),
                  dpi = 300, limitsize = TRUE)

          } # end area loop i

@

\begin{figure}
\begin{center}



The next plots show for each brain area correlations plotted against starting negitions for all measured genes on Chromosome 22. The dotted lines are median positive and negative correlations, and the vertical dashed line is the transcription start negition for MB-{\textit {COMT}}. There do not appear to be any gaps either in the positive or the negative correlations near the negition of the MB-{\textit {COMT}} gene.

\includegraphics[width=4cm, height=3cm]{corr_vs_start_negitions_Chr22_Prefrontal.pdf}\vspace{3em}
\includegraphics[width=4cm, height=3cm]{corr_vs_start_negitions_Chr22_Cerebellum.pdf}\vspace{3em}
\includegraphics[width=4cm, height=3cm]{corr_vs_start_negitions_Chr22_Temporal.pdf}\vspace{3em}
\includegraphics[width=4cm, height=3cm]{corr_vs_start_negitions_Chr22_Pons.pdf}\vspace{3em}

\end{center}
\end{figure}

<<results=tex>>=
# Use the hypergeometric distribution to determine the probability that 8 of 21 genes that were in the top 200 negatively correlated genes in Temporal Cortex on Chr 5, would also show up among the (partially different) 21 genes on Chr 5 in Prefrontal cortex.
          
# Number of genes measured in full sample on Chr 5
          
     num.Genes.neg.Chr5$total[1] <- dim(subset(prefront.Data.onegene,prefront.Data.onegene$loc == '5'))[1] 
     num.Genes.neg.Chr5$total[2] <- dim(subset(tempor.Data.onegene,tempor.Data.onegene$loc == '5'))[1]
     num.Genes.neg.Chr5$common[1] <- length(common.genes.Chr5.neg[[2]])
     num.Genes.neg.Chr5$common[2] <- length(common.genes.Chr5.neg[[2]])
     
     # Of the 20 genes in the top 200 negatively correlated genes in Prefrontal Cortex on Chromosome 5, how many of those were also measured in Temporal Cortex? In other words, if a particular gene were among the set of 20 in PfCtx, it could not negsibly also be among the set of 21 in TempCtx unless it was in the set of all genes measured in TempCtx.
     
# negs.Matches shows that all 20 of the genes in the top set in PfCtx on Chr 5 were also measured in TempCtx.
          negs.Matches <- length(match(pf.Neg[5,1:20],tempor.Data.onegene$Symbol))
     
     # Genes measured in Prefrontal on Chr 5
     genes.Chr5.pf <- subset(prefront.Data.onegene,prefront.Data.onegene$loc == '5')  # n = 715
     genes.Chr5.tm <- subset(tempor.Data.onegene,tempor.Data.onegene$loc == '5')    # n = 729

# 567 genes were measured both in PfCtx and TempCtx     
     same.Measured.pftm  <- intersect(genes.Chr5.pf$Symbol,genes.Chr5.tm$Symbol)
     num.genes.Common.pftm <- length(same.Measured.pftm)   # n = 567
     
# Number of ways to choose 21 genes from 715 genes meqasured on Chr 5 in Prefrontal
     A.pf <- 20
     B.pf <- (num.Genes.neg.Chr5$total[1] - A.pf)
     k.pf <- c(8:A.pf) #number of matching genes 8 or more
     
     # num.Choose.pf = 383288337264708946651341363588328903560
     num.Choose.pf <- chooseZ((A.pf + B.pf),A.pf)
     
# Number of ways to choose 21 genes from 729 genes meqasured on Chr 5 in Temporal
     A.tm <- 21
     B.tm <- (num.Genes.neg.Chr5$total[2] - A.tm)
     k.tm <- c(8:A.tm) #number of matching genes  8 or more
     
     # num.Choose.pf = 19170760017547961871654036186294130436130
     num.Choose.tm <- chooseZ((A.tm + B.tm),A.tm)

# What is the probability that both of these samples of genes of sizes 20 and 21, respectively, would contain 8 or more genes in common? Keep in mind that while 715 genes were measured in PfCtx and 729 in TempCtx, only 567 genes were measured in both places. So there are genes that could show up in the sample of 20 from PfCtx that could not show up in the sample of 21 from TempCtx and vice versa.

     # Once the 20 have been specified from PfCtx, how many different combinations of 8 genes are negsible in the set of 20 genes that were specified in PfCtx?

     # 125970 different sets of 8 genes any one of which could be the one that is also in the set of 21 from TempCtx. But it should be 8 or more.     
     comb.8ormore.20.pf <- as.bigq(chooseZ(A.pf,k.pf)) 
     
      # Once the 21 have been specified from TempCtx, how many different combinations of 8 genes are negsible in the set of 21 genes that were specified in TempCtx?

     # 203490 different sets of 8 genes any one of which could be the one that is also in the set of 20 from PfCtx.     
     comb.8ormore.21.tm <- as.bigq(chooseZ(A.tm,k.tm))  
     
     # If there are 383288337264708946651341363588328903560 ways to choose 20 genes randomly from 715 genes, and if for each of these ways there are 125970 different sets of 8 genes, nnn sets of 9 genes, nnn sets of 10 genes, etc., that increases the negsibility that any set of 8 or 9 or 10 etc genes will overlap in both areas because it could be this set of 8 or that set of 8 or that set of 8, etc. Therefore, multiply the probability of getting a particular set of 20 genes by the number of different sets of 8 that could match in that set. Do this for all numbers from 8 to 20 and sum the probabilities.
     
     prob.8ormore.20.matchpf <- asNumeric(sum(comb.8ormore.20.pf*(1.00/(num.Choose.pf))))
     
     # Same logic for TempCtx
     
     prob.8ormore.21.matchtm <- asNumeric(sum(comb.8ormore.21.tm*(1.00/(num.Choose.tm))))
          
@


% {\bfseries {Using the hypergeometric distribution to test for randomness in the number of probes shared in common between the reference area and another area.}}\\
% 
% Testing for probe matches between a reference and a test brain area involves the {\bfseries {hypergeometric}} distribution.\\ The computation of probabilities when sampling without replacement is based on the following pdf:
% 
% \href{http://people.wku.edu/david.neal/109/Unit2/SamplingWO.pdf}{c('MATH 109 Sampling without Replacement)}
% 
% Here is the description of the calculation: \\
% 
% {\bfseries {Sampling Without Regard to Order}}\\
% Now  supnege  we  have  a  population  of N elements  that  are  divided  into  two  types: Type I  which has A elements,  and Type II which has B elements, where $A + B == N$.\\  
% 
% For  example,  a  standard  deck  of  $N == 52$  playing  cards  can  be  divided  in  many  ways. Type  I  could  be  Hearts  and  Type  II    could  be  All  Others.    Then  there  are   $A == 13$ Hearts and  $B == 39$ Others.\\
% 
% In analogy to the genes/probes problem, $N == 20,000$ probes,  $A == 50$ or 200, as in the top 50 or the top 200 most strongly positively/negatively {\textit {COMT}}-correlated probes. Thus B is either 19,950 ($A == 50 $) or B is 19,800 ( $A == 200$). 
% 
% There are two other parameters: $n == $the number of probes randomnly sampled without replacement, and  $k = $ the number of negatively correlated genes in the sample of size n that also are contained in A. The calculation for the probability that a sample of size n will contain k negatively correlated genes:\\
% $$
% p = \frac{\binom{A,k}*\binom{B,(n-k)}}{\binom{N,n}}
% $$


<<include=FALSE, echo=FALSE, results=tex>>=
################################################
### Select the top 200 by p-value to determine which genes expression levels (by chromosome) are most highly correlated with COMT expression.
################################################


# These are ordered by pvalue regardless of sign
data.by.Pval.area <- list()
data.by.Pval.area[[1]] <- gene.Major[[1]][order(gene.Major[[1]]$Sample.p.r.,decreasing=FALSE),]
data.by.Pval.area[[2]] <- gene.Major[[2]][order(gene.Major[[2]]$Sample.p.r.,decreasing=FALSE),]
data.by.Pval.area[[3]] <- gene.Major[[3]][order(gene.Major[[3]]$Sample.p.r.,decreasing=FALSE),]
data.by.Pval.area[[4]] <- gene.Major[[4]][order(gene.Major[[4]]$Sample.p.r.,decreasing=FALSE),]

n <- c(500)     # sample of 500 genes

summ.Sign.area <- matrix(rep(0,32),nrow=8)
summ.Sign.area <- data.frame(summ.Sign.area) 
colnames(summ.Sign.area) <- stand.Col.names

summ.Sign.area[3,] <- c(n)

mdat <- matrix(c(rep(0,(3*5)),0,rep(3,4),rep(0,(2*5)),0,rep(3,(1*4)),
                 0,rep(3,(1*4))),
                 nrow = 8, ncol=5, byrow=TRUE)


# summ.Sign.area <- data.frame(samp=rep(0,4),
#                              expect=rep(0,4),
#                              size=rep(200,4),
#                              prop.samp=rep(0,4),
#                              num.neg=rep(0,4),
#                              total=rep(0,4),
#                              prop.total=rep(0,4),
#                              Pval=rep(0,4))

# For each brain area, use the hypergeometric distribution to determine the probability of obtaining
# the observed number of negative correlations (or fewere) given the proportion of negative 
# correlations in the complete sample

for (j in ib)    {
     
     if (exists('prob.N')) {rm(prob.N)}

     ############ DEBUG
#     j <- c(1)
     ##################
          
total.Corsign.tab <- table(data.by.Pval.area[[j]]$corsign)
samp.Corsign.tab <- table(data.by.Pval.area[[j]]$corsign[1:n])

summ.Sign.area[1,j] <- samp.Corsign.tab[1]     # samp
summ.Sign.area[5,j] <- total.Corsign.tab[1]    # num.neg
summ.Sign.area[4,j] <- round(samp.Corsign.tab[1]/summ.Sign.area[3,j],3)


# Sampling without replacement

     num.Genes <- length(data.by.Pval.area[[j]]$Symbol)
     summ.Sign.area[6,j] <- num.Genes
     N <- num.Genes
     A <- total.Corsign.tab[1]   # number of genes with negative correlations in full sample
     B <- N - A         # number of genes with positive correlations

     summ.Sign.area[7,j] <- round(summ.Sign.area[5,j]/summ.Sign.area[6,j],3)
     summ.Sign.area[2,j] <- round(summ.Sign.area[3,j]*summ.Sign.area[7,j],1)
     

# prob.N will hold the discrete probability distribution for k matches from a sample size of n = 500.


#     prob.N[k+1] <- (chooseMpfr(A,k)*chooseMpfr(B,(n-k)))/chooseMpfr(N,n)
     
     # Use built in hypergeometric distribution in R
     prob.N <- log10(phyper(samp.Corsign.tab[1],A,B,n,lower.tail=TRUE,log.p=FALSE))

summ.Sign.area[8,j] <- prob.N

} #end brain area loop

row.names(summ.Sign.area) <- c('Number of negative correlations',
                              'Expected number of negative correlations',
                              'Sample size',
                              'Proportion of negative correlations: sample',
                              'Total number of negative correlations',
                              'Total number of genes',
                              'Proportion negative correlations: total',
                              'Log10(probability)')

summ.Sign.area.tab <- xtable(summ.Sign.area,
                             caption=c(paste('Observed, expected number of negative correlations and associated hypergeometric p-values by brain area for the 200 genes whose '," \\textit{COMT}",
' expression correlations had the smallest p values.',sep='')),
                             digits=mdat,
                              label=c('tab:hypergeom'))

# the table has been saved
print.xtable(summ.Sign.area.tab,
                         file=paste('top_500_ranked_by_pval_hypergeom.tex',sep=''),
                         type='latex',
                         floating=FALSE,
                         caption.placement='top',
                         tabular.environment='longtable',
                         caption.width ='0.5\\textwidth',
                         hline.after=c(-1,0,nrow(summ.Sign.area.tab)),
                         include.rownames=TRUE,
                         print.results=TRUE,
                         booktabs=TRUE,
                         comment=TRUE,
                         digits=mdat
                         )


@

The analysis of the proportion of negative correlations among the 500 genes with the smallest p-values showed that for all four brain areas, the observed number of negative correlations was significantly smaller (all p-values $< 10^{-30}$) than would have been expected based on the proportion of negative p-values in the total sample. In fact, while approximately 62\% of the correlations in the complete sample (gene as unit) were negative, no more than 22\% of the correlations were negative among the 500 genes whose correlations with MB-{\textit {COMT}} were largest.\\

This is in keeping with previous work that has shown that the strongest co-expressed genes tend to have positive correlations (need ref).\\

<<change.sign>>=
# Do any of the genes in the top 500 change sign between brain areas?

# For genes that are in common between pairs of brain areas, what is the rank order correlation between their COMT expression correlations. In other words, if a gene shows up in the top 500 in Prefrontal cortex, with a high positive correlation, and it also shows up in Cerebellum, is its correlation also high and positive?

sign.Diffs <- list()
rank.order.corrs <- list()
rank.order.stats <- data.frame(compare=c('PFCtx vs. Cereb',
                                         'PFCtx vs. TemCtx',
                                         'PFCtx vs. Pons',
                                         'Cereb vs. TemCtx',
                                         'Cereb vs. Pons',
                                         'TemCtx vs. Pons'),
                             n=rep(NA,6),
                             rho=rep(NA,6),
                             pvalue=rep(NA,6))

comp.indx <- matrix(c(1,2,
                    1,3,
                    1,4,
                    2,3,
                    2,4,
                    3,4), ncol=2,byrow=TRUE)

for (kl in 1:dim(comp.indx)[1])   {


     same.symbols <- match(hold.Lowest.pvals[[comp.indx[kl,1]]]$Symbol,hold.Lowest.pvals[[comp.indx[kl,2]]]$Symbol)

     tempa.indx <- which(!is.na(same.symbols))
     tempb.indx <- na.omit(same.symbols)
     
     comp.signs <- data.frame(signA=hold.Lowest.pvals[[comp.indx[kl,1]]]$corsign[c(tempa.indx)],signB=hold.Lowest.pvals[[comp.indx[kl,2]]]$corsign[c(tempb.indx)])
     
     comp.corrs <- data.frame(rA=hold.Lowest.pvals[[comp.indx[kl,1]]]$Sample.r[c(tempa.indx)],rB=hold.Lowest.pvals[[comp.indx[kl,2]]]$Sample.r[c(tempb.indx)])
     
     rank.order.corrs[[kl]] <- cor.test(comp.corrs$rA,comp.corrs$rB,method='spearman')
     
     sign.Diffs[[kl]] <- which(comp.signs$signA != comp.signs$signB)
     
     rank.order.stats[kl,2:4] <- c(round(length(comp.corrs$rA),0),
                                   round(rank.order.corrs[[kl]]$estimate,3),
                                   round(rank.order.corrs[[kl]]$p.value,11)
                                         )
}

rank.order.stats.tab <- print.xtable(xtable(rank.order.stats,
                               caption=c('Rank order correlations between the expression level correlations for genes shared between pairs of brain areas. The determination of which genes were \"shared\" between pairs of brain areas was restricted to the 500 most strongly COMT-correlated genes in each brain area.'),
                               include.rownames=FALSE,
                               digits=c(0,0,0,3,11),
                               print.results=TRUE))


numworking.genes.by.area <- matrix(lapply(gene.Major[ib], function(x,ib) dim(x)[1], ib),ncol=1)


colnames(numworking.genes.by.area) <- c('Number of Genes')
row.names(numworking.genes.by.area) <- stand.Col.names

xtable(numworking.genes.by.area,
       caption=c('Number of Genes with COMT Expression Correlations'),
       digits=0)

@

There are no genes in the top 500 in each brain area that change the sign of correlation between two different brain areas. In other words, if a strongly correlated gene in Prefrontal Cortex has expression levels that are positively correlated with COMT, then if that gene is also among the top 500 genes in Cerebellum, its correlation sign will also be positive.\\

Additionally, for the genes that are in common between two brain areas in their respective sets of 500 most strongly correlated genes, the rank order correlation between their expression correlations with COMT are significantly positive for all pairwise comparisons between brain areas.\\



<<results=hide>>=
# Get the distributions of + and - correlations, positive-only, and negative-only for the 
# onegene data by brain area


#for (b in 1:4)   {
     
     ############## DEBUG
     b <- c(1)
     ####################

 phisto <- ggplot(data=area.onegene.List[[b]], aes(as.numeric(area.onegene.List[[b]]$Sample.r))) +    #          geom_density(stat='density',fill='gray90') +
          
          
          stat_density(data = area.onegene.List[[b]], 
                       aes(as.numeric(area.onegene.List[[b]]$Sample.r)),geom = "area",
                       negition = "stack", ..., bw = "nrd0", adjust = 1, kernel = "gaussian",
                       n = 1024, trim = FALSE, na.rm = FALSE, show.legend = NA,
                       inherit.aes = TRUE) +
    
     scale_x_continuous(name=c(paste("Correlation of expression with "," \\textit{COMT}",sep='')),
                               limits=c(-1.0,1.0)) +
          
     theme_bw() +
     theme(strip.background=element_rect(fill="gray70")) +
     theme(strip.text = element_text(colour = 'black')) +
     
     labs(x = c(paste("Correlation of expression with "," \\textit{COMT}",sep='')),
          y = c('Frequency'),
          title = c(paste('Distribution of Correlation Coefficients in ',stand.Col.names.aug[b],sep=''))) +
     theme(axis.text=element_text(size=7),
        axis.title=element_text(size=9)) +
     theme(plot.title=element_text(size=10,
                                   hjust=0.5)) 
          
          # annotate("text", x = 0.90*as.numeric(prefront.Data$bp[1]),
          #    y = c(28),
          #    label = "MB-italic(COMT)", 
          #    parse=TRUE,
          #    color="black",
          #    size=2)
     
     phisto

#} # end area loop

# phista
     # save plots to file
     
     # hist.22 <- paste('histogram_start_negitions_Chr22_',stand.Col.names[i],'.eps',sep='')
     #      setEPS()
     #      negtscript(hist.22,width=8,height=6)
     #      phista
     #      dev.off()







@


<<label=top10percent, echo=FALSE, results=tex>>=
################################################
### Select the top 200 by p-value to determine which genes expression levels (by chromosome) are most highly correlated with COMT expression.
### Done separately for positive and negative correlations
################################################

total.Corsign.tab <- table(prefront.by.Pval$corsign)
samp.Corsign.tab <- table(prefront.by.Pval$corsign[1:200]) 



##### positive correlations with COMT expression only #####################
full.Count <- table(manhat.negr$CHR)
order.by.P.neg <- manhat.negr[order(manhat.negr$P), ]
num.neg <- dim(order.by.P.neg)[1]
ten.percent.neg <- floor(0.10*num.neg)
top.10percent.neg <- order.by.P.neg[1:ten.percent.neg, ]
top10.neg.Count <- table(top.10percent.neg[,1])

# scaled.Props <- as.numeric(full.Count)/num.neg
# scaled.top10.Props <- as.numeric(top10.neg.Count)/sum(as.numeric(top10.neg.Count))

## This scales the number of probes in the top 10% inversely by the fitted number of probes from the regression of number of probes by chromosome length. It also preserves the absolute number of probes found in the top 10% (~886)
fit.inverse.Scaled <- as.numeric(top10.neg.Count)/(adjust.By.fit[1:23]/sum(adjust.By.fit[1:23]))
fit.inverse.Scaled <- round((fit.inverse.Scaled*(sum(top10.neg.Count)/sum(fit.inverse.Scaled))),0)


# ratio.top10.neg <- data.frame(ratio=scaled.top10.Props/scaled.Props[1:23])
# ratio.top10.neg$chr <- c(1:23)
# ratio.top10.neg <- ratio.top10.neg[c(2,1)]
# scaled.Ratio <- data.frame(prop=ratio.top10.neg[,2]/sum(ratio.top10.neg[,2]))
# scaled.Ratio$chr <- c(1:23)
# scaled.Ratio$chr <- scaled.Ratio[c(2,1)]
# 
# num2get <- top10.neg.Count*scaled.Ratio$prop
num2get2 <- data.frame(n = as.numeric(fit.inverse.Scaled))
num2get2$chr <- as.numeric(c(1:23))
num2get2 <- num2get2[c(2,1)]

hold.neg <- data.frame(CHR=rep(NA,sum(num2get2$n)),
                       BP=rep(NA,sum(num2get2$n)),
                       P=rep(NA,sum(num2get2$n)),
                       GENE=rep(NA,sum(num2get2$n))
)
hold.neg$GENE <- as.character(hold.neg$GENE)
hold.neg$CHR <- as.numeric(hold.neg$CHR)
hold.neg$P <- as.numeric(hold.neg$P)

### hold.neg holds the top 883 positively correlated genes inversely weighted for the number of probes per # chromosome
### So the choice of the top genes is within chromosome, but the number of genes is inversely normalized by the fitted number of probes for that chromosome as regressed against chromosome length as well as the absolute rank of those genes against all the other genes
lims.Count <- matrix(c(0,0),nrow=1)                               
for (ig in 1:23) {
  lims.Count[1] <- lims.Count[2] + 1
  lims.Count[2] <- lims.Count[1] + num2get2$n[ig] - 1
  hold.neg[lims.Count[1]:lims.Count[2],1:4] <-data.frame(subset(manhat.negr,manhat.negr$CHR == ig)[1:num2get2$n[ig], ])
}

colnames(hold.neg) <- c('CHR','BP','P','GENE')

### Put this into a latex table sorted by chromosome number

top.neg.ltx <- latex(hold.neg,file='top.neg_genes.tex',
                      insert.top=('Top positively correlated genes normalized for number of probes per chromosome ordered by P value within chromosome'),
                      booktabs=TRUE,
                      label=c('top.neg'),
#                      cgroup = c('Genes'),
#                      n.cgroup = c(4),
                      na.blank = TRUE,
                      vbar = FALSE,
                      longtable=TRUE,
                      table.env=FALSE,
                      continued=c('Top positively correlated genes continued'),
                      first.hline.double = TRUE,
                      size=c('tiny'),
                      append=FALSE
                      )
top.neg.ltx

### Put this into a latex table sorted by p-value
hold.neg.byP <- hold.neg[order(hold.neg$P),]
hold.neg.byP$GENE <- as.character(hold.neg.byP$GENE)

top.negbyP.ltx <- latex(hold.neg.byP,file='top.neg_genes_by_P.tex',
                      insert.top=('Top positively correlated genes normalized for number of probes per chromosome ordered by P-value'),
                      booktabs=TRUE,
                      label=c('top.negP'),
#                      cgroup = c('Genes'),
#                      n.cgroup = c(4),
                      na.blank = TRUE,
                      vbar = FALSE,
                      longtable=TRUE,
                      table.env=FALSE,
                      continued=c('Top positively correlated genes continued'),
                      first.hline.double = TRUE,
                      size=c('tiny'),
                      append=FALSE
                      )
top.negbyP.ltx

############ End positive only ########################
  
##### Negative correlations with COMT expression only #####################
full.Count <- table(manhat.Negr$CHR)
order.by.P.neg <- manhat.Negr[order(manhat.Negr$P), ]
num.Neg <- dim(order.by.P.neg)[1]
ten.percent.Neg <- floor(0.10*num.Neg)
top.10percent.neg <- order.by.P.neg[1:ten.percent.Neg, ]
top10.neg.Count <- table(top.10percent.neg[,1])

scaled.Props <- as.numeric(full.Count)/num.neg
scaled.top10.Props <- as.numeric(top10.neg.Count)/sum(as.numeric(top10.neg.Count))

## This scales the number of probes in the top 10% inversely by the fitted number of probes from the regression of number of probes by chromosome length. It also preserves the absolute number of probes found in the top 10% (~886)
fit.inverse.Scaled <- as.numeric(top10.neg.Count)/(adjust.By.fit[1:23]/sum(adjust.By.fit[1:23]))
fit.inverse.Scaled <- round((fit.inverse.Scaled*(sum(top10.neg.Count)/sum(fit.inverse.Scaled))),0)


# ratio.top10.neg <- data.frame(ratio=scaled.top10.Props/scaled.Props[1:23])
# ratio.top10.neg$chr <- c(1:23)
# ratio.top10.neg <- ratio.top10.neg[c(2,1)]
# scaled.Ratio <- data.frame(prop=ratio.top10.neg[,2]/sum(ratio.top10.neg[,2]))
# scaled.Ratio$chr <- c(1:23)
# scaled.Ratio <- scaled.Ratio[c(2,1)]
# 
# num2get <- top10.neg.Count*scaled.Ratio$prop
num2get2 <- data.frame(n = as.numeric(fit.inverse.Scaled))
num2get2$chr <- as.numeric(c(1:23))
num2get2 <- num2get2[c(2,1)]

hold.neg <- data.frame(CHR=rep(NA,sum(num2get2$n)),
                               BP=rep(NA,sum(num2get2$n)),
                               P=rep(NA,sum(num2get2$n)),
                               GENE=rep(NA,sum(num2get2$n))
)
hold.neg$GENE <- as.character(hold.neg$GENE)
manhat.Negr$GENE <- as.character(manhat.Negr$GENE)
hold.neg$CHR <- as.numeric(hold.neg$CHR)
hold.neg$P <- as.numeric(hold.neg$P)

### hold.neg holds the top 909 positively correlated genes weighted inversely for the number of probes per chromosome as determined from the fitted value when number of probes is regressed against chr length.
### So the choice of the top genes is within chromosome, but the number of genes inversely reflects the fitted number of probes used for that chromosome as well as the absolute rank of those genes against all the other genes
lims.Count <- matrix(c(0,0),nrow=1)                               
for (ig in 1:23) {
  lims.Count[1] <- lims.Count[2] + 1
  lims.Count[2] <- lims.Count[1] + num2get2$n[ig] - 1
  hold.neg[lims.Count[1]:lims.Count[2],1:4 ] <-data.frame(subset(manhat.Negr,manhat.Negr$CHR == ig)[1:num2get2$n[ig], ])
}

colnames(hold.neg) <- c('CHR','BP','P','GENE')


### Put this into a latex table sorted by chromosome number
top.Neg.ltx <- latex(hold.neg,file='top.Neg_genes.tex',
                      insert.top=('Top negatively correlated genes normalized for number of probes per chromosome ordered by P-value within chromosome'),
                      booktabs=TRUE,
                      label=c('top.Neg'),
#                      cgroup = c('Genes'),
#                      n.cgroup = c(4),
                      na.blank = TRUE,
                      vbar = FALSE,
                      longtable=TRUE,
                      table.env=FALSE,
                      continued=c('Top negatively correlated genes continued'),
                      first.hline.double = TRUE,
                      size=c('tiny'),
                      append=FALSE
                      )
top.Neg.ltx

### Put this into a latex table sorted by p-value
hold.neg.byP <- hold.neg[order(hold.neg$P),]
hold.neg.byP$GENE <- as.character(hold.neg.byP$GENE)

top.NegbyP.ltx <- latex(hold.neg.byP,file='top.Neg_genes_by_P.tex',
                      insert.top=('Top negatively correlated genes normalized for number of probes per chromosome ordered by P-value'),
                      booktabs=TRUE,
                      label=c('top.NegP'),
#                      cgroup = c('Genes'),
#                      n.cgroup = c(4),
                      na.blank = TRUE,
                      vbar = FALSE,
                      longtable=TRUE,
                      table.env=FALSE,
                      continued=c('Top positively correlated genes continued'),
                      first.hline.double = TRUE,
                      size=c('tiny'),
                      append=FALSE
                      )
top.NegbyP.ltx

############ End negative only ########################

@


<<include=FALSE, echo=FALSE, results=tex>>=
dim.areas <- matrix(c(dim(prefront.Data)[1],
                    dim(cbell.Data)[1],
                    dim(tempor.Data)[1],
                    dim(pons.Data)[1]),
                    nrow=4)

have.ENTREZ <- data.frame(indpf=c(1:dim.areas[1]),
                          ENTREZIDpf=rep(NA,dim.areas[1]),
                          ILMNpf=prefront.Data$Record,
                          indcb=c(1:dim.areas[1]),
                          ENTREZIDcb=rep(NA,dim.areas[2]),
                          ILMNcb=cbell.Data$Record,
                          indtm=c(1:dim.areas[1]),
                          ENTREZIDtm=rep(NA,dim.areas[3]),
                          ILMNtm=tempor.Data$Record,
                          indpo=c(1:dim.areas[1]),
                          ENTREZIDpo=rep(NA,dim.areas[4]),
                          ILMNpo=pons.Data$Record
                          )

# First determine which rows have the loc(Chromosome) listed as 'Un'. That is done below with
# the variables where.Un.pf, where.Un.cb, where.Un.tm, where.Un.po

# On an area by area basis separately, retrieve the ENTREZIDs for each Illumina probe.
have.Ent.pf <-na.omit(unlist(mget(x = prefront.Data$Record,envir=illuminaHumanv2ENTREZID)))   # n = 18724 of 20,000
have.Ent.cb <- na.omit(unlist(mget(x = cbell.Data$Record,envir=illuminaHumanv2ENTREZID)))      # n = 18726 of 20,000
have.Ent.tm <- na.omit(unlist(mget(x = tempor.Data$Record,envir=illuminaHumanv2ENTREZID)))     # n = 18698 of 20,000
have.Ent.po <- na.omit(unlist(mget(x = pons.Data$Record,envir=illuminaHumanv2ENTREZID)))       # n = 18713 of 20,000

# eliminate duplicates - these vectors show the unique ENTREZIDs in each brain area's data
# There are duplicates because there can be multiple ILMN probes for the same gene (ENTREZID)

############# Don't eliminate duplicates because the retention of rows will be done on the basis
############# of Illumina probe IDs which are unique
# notdups.pf <- which(!duplicated(have.Ent.pf))
# have.Ent.pf <- have.Ent.pf[c(notdups.pf),1]     
# 
# notdups.cb <- which(!duplicated(have.Ent.cb))
# have.Ent.cb <- have.Ent.cb[c(notdups.cb),1]
# 
# notdups.tm <- which(!duplicated(have.Ent.tm))
# have.Ent.tm <- have.Ent.tm[c(notdups.tm),1]
# 
# notdups.po <- which(!duplicated(have.Ent.po))
# have.Ent.po <- have.Ent.po[c(notdups.po),1]

entrez.By.area <- data.frame(num.entrez=c(length(have.Ent.pf),
                                          length(have.Ent.cb),
                                          length(have.Ent.tm),
                                          length(have.Ent.po)),
                             miss.entrez=c((20000 - length(have.Ent.pf)),
                                           (20000 -length(have.Ent.cb)),
                                           (20000 -length(have.Ent.tm)),
                                           (20000 -length(have.Ent.po)))
)

colnames(entrez.By.area) <- c('Number of Rows with ENTREZIDs','Number of Rows Missing ENTREZIDs')
row.names(entrez.By.area) <- c('Prefrontal Cortex',
                              'Cerebellum',
                              'Temporal Cortical Wall',
                              'Pons')

entrez.Area.tab <- xtable(entrez.By.area,
                         caption='Number of Unique ENTREZIDs in the Expression data\n for Each Brain Area. ENTREZIDs retrieved using ILMN identifiers.')

print(entrez.Area.tab)
@

\Sexpr{entrez.Area.tab}\\


<<include=FALSE, echo=FALSE, results=tex>>=

# The vectors above hold only the rows with ENTREZIDs in each area.
# NAs have been eliminated, and there are no duplicates.

# Attach a column with the ENTREZIDs to each of the 20,000 rows data frames
# Don't eliminate the NAs
prefront.Data$ENTREZID <- unlist(mget(x = prefront.Data$Record,envir=illuminaHumanv2ENTREZID))   # n = 18724 without NA; 1276 with NA
cbell.Data$ENTREZID <- unlist(mget(x = cbell.Data$Record,envir=illuminaHumanv2ENTREZID))      # n = 18726 withput NA, 1274 with NA
tempor.Data$ENTREZID <- unlist(mget(x = tempor.Data$Record,envir=illuminaHumanv2ENTREZID))     # n = 18698 without NA, 1302 with NA
pons.Data$ENTREZID <- unlist(mget(x = pons.Data$Record,envir=illuminaHumanv2ENTREZID))       # n = 18713 without NA, 1287 with NA

# Use the Illumina Human ref 8 v 2 bead chip reference file to try to find additional ENTREZIDs
# data.frame illumina.Data

# Get the list of ILMN probes for each data.frame that do not have ENTREZIDs
no.Entrez.pf <- prefront.Data$Record[c(which(is.na(prefront.Data$ENTREZID)))]
no.Entrez.pf.indx <- which(is.na(prefront.Data$ENTREZID))

no.Entrez.cb <- cbell.Data$Record[c(which(is.na(cbell.Data$ENTREZID)))]
no.Entrez.cb.indx <- which(is.na(cbell.Data$ENTREZID))

no.Entrez.tm <- tempor.Data$Record[c(which(is.na(tempor.Data$ENTREZID)))]
no.Entrez.tm.indx <- which(is.na(tempor.Data$ENTREZID))

no.Entrez.po <- pons.Data$Record[c(which(is.na(pons.Data$ENTREZID)))]
no.Entrez.po.indx <- which(is.na(pons.Data$ENTREZID))

# Get the indices in the illumina.Data$ilmn vector for which the entry matches a probe in 
# no.Entrez.xx that does not have an ENTREZID attached

extra.ILMN.pf <- match(no.Entrez.pf,illumina.Data$ilmn)
extra.ILMN.cb <- match(no.Entrez.cb,illumina.Data$ilmn)
extra.ILMN.tm <- match(no.Entrez.tm,illumina.Data$ilmn)
extra.ILMN.po <- match(no.Entrez.po,illumina.Data$ilmn)


# The lengths of these vactors show that every ILMN with a missing ENTREZID has a match
# in the ilumina.Data$ilmn vector. This doesn't necessarily mean that the ENTREZID is there
# as well

# These hold the ENTREZIDs that were missing from the original data set, but were found in the Illumina data set
extra.Entrez.pf <- illumina.Data$entrez[c(extra.ILMN.pf)]
# num.NA(extra.Entrez.pf) = 0; all of the missing ENTREZIDs were recovered for prefrontal
extra.Entrez.cb <- illumina.Data$entrez[c(extra.ILMN.cb)]
# num.NA(extra.Entrez.cb) = 0; all of the missing ENTREZIDs were recovered for cerebellum
extra.Entrez.tm <- illumina.Data$entrez[c(extra.ILMN.tm)]
# num.NA(extra.Entrez.cb) # = 0; all of the missing ENTREZIDs were recovered for temporal
extra.Entrez.po <- illumina.Data$entrez[c(extra.ILMN.po)]
# num.NA(extra.Entrez.cb) # = 0; all of the missing ENTREZIDs were recovered for pons

# a. Set up a correspondence matrix that holds the index in the Illumina file of the probes for which there was not an ENTREZID in the <area>.Data$ENTREZID column
# b. With the index in the Illumina data file that has a probe ID that matches one listed as not having an ENTREZID (a.)
correspond.Data.ILMN.pf <- matrix(c(no.Entrez.pf.indx,extra.ILMN.pf),
                               ncol=2)
correspond.Data.ILMN.cb <- matrix(c(no.Entrez.cb.indx,extra.ILMN.cb),
                               ncol=2)
correspond.Data.ILMN.tm <- matrix(c(no.Entrez.tm.indx,extra.ILMN.tm),
                               ncol=2)
correspond.Data.ILMN.po <- matrix(c(no.Entrez.po.indx,extra.ILMN.po),
                               ncol=2)
corresp.Data.ILM <- list(correspond.Data.ILMN.pf,
                         correspond.Data.ILMN.cb,
                         correspond.Data.ILMN.tm,
                         correspond.Data.ILMN.po)


# For example, corresp.Data.ILM[[1]][1,1] = 7
# corresp.Data.ILM[[1]][1,2] = 6147
# Thus, prefront.Data$ENTREZID[7] has an ILMN of "ILMN_1683883" and is missing and ENTREZID
# illumina.Data[6147,] has an ILMN of "ILMN_1683883" and it has a corresponding entrez = 95
# The illumina.Data$entrez[6147] = 95 can be used to fill in the missing ENTREZID in
# prefront.Data$ENTREZID[7]

# use the indices in extra.ILMN.xx to fill in the missing ENTREZID values
#Both sides have lengths of 20000. There are NAs in te ENTREZID columns
prefront.Data$ENTREZID <- as.character(prefront.Data$ENTREZID)
illumina.Data$entrez <- as.character(illumina.Data$entrez)

prefront.Data$ENTREZID[c(corresp.Data.ILM[[1]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[1]][,2])]

cbell.Data$ENTREZID <- as.character(cbell.Data$ENTREZID)
cbell.Data$ENTREZID[c(corresp.Data.ILM[[2]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[2]][,2])]

tempor.Data$ENTREZID <- as.character(tempor.Data$ENTREZID)
tempor.Data$ENTREZID[c(corresp.Data.ILM[[3]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[3]][,2])]

pons.Data$ENTREZID <- as.character(pons.Data$ENTREZID)
pons.Data$ENTREZID[c(corresp.Data.ILM[[4]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[4]][,2])]

# All 20,000 rows in each areal data.frame have ENTREZIDs (no NAs)
# This means also that all Illumina probe IDs also have identifiers that are mapped to a gene (ENTREZID)
# All of the ENTREZIDs are unique - not duplicated.
# This doesn't mean that the set of ENTREZIDs for each <area>.Data data.frame is the same
# In other words, because the <area>.Data correlation files with 20,000 correlations were
# obtained ranked by the p-values of the correlations, and because there are more than
# 20,000 Illumina probes, the sets of probes do not have to correspond
num.NA(prefront.Data$ENTREZID)    # n = 510 NA
num.NA(cbell.Data$ENTREZID)   # n = 229 NA
num.NA(tempor.Data$ENTREZID)  # n = 45 NA
num.NA(pons.Data$ENTREZID)    # n = 237 NA


# Next, intersect on the basis of ENTREZID (which is necessary to look up missing chromosomes;
# the ones that are listed as 'Un'). This will store only the ENTREZIDs that are in common
# across all four brain areas


all.areas.ENTREZID <- intersect(pons.Data$ENTREZID,intersect(tempor.Data$ENTREZID,intersect(prefront.Data$ENTREZID,cbell.Data$ENTREZID)))    # length = 13027

# all.areas.ENTREZID now holds all of the ENTREZIDs shared across all four brain areas


# Before finding the set of common Illumina probes across all areas, first try to find the 
# missing Chromosomes for each <area>.Data separately.
# Leverage the fact that the set of Illumina probes differs across areas, and some could be
# missing a chromosome name in one area while the same probe has the Chromosome in another area.

# Get the union of all Illumina probes across areas. First extract the probes, entrezids 
# and chromosomes into a data frame for each area

illum.entr.chr.pf <- data.frame(illum=prefront.Data$Record,
                                entrez=prefront.Data$ENTREZID,
                                chr=prefront.Data$loc)
illum.entr.chr.cb <- data.frame(illum=cbell.Data$Record,
                                entrez=cbell.Data$ENTREZID,
                                chr=cbell.Data$loc)
illum.entr.chr.tm <- data.frame(illum=tempor.Data$Record,
                                entrez=tempor.Data$ENTREZID,
                                chr=tempor.Data$loc)
illum.entr.chr.po <- data.frame(illum=pons.Data$Record,
                                entrez=pons.Data$ENTREZID,
                                chr=pons.Data$loc)

# Next get the union of all Illumina probes across the four areas

union.Illum.pfcb <- union(illum.entr.chr.pf$illum,illum.entr.chr.cb$illum)   # length 22016
union.Illum.pfcbtm <- union(union.Illum.pfcb,illum.entr.chr.tm$illum)     # length 22151
union.Illum.all <- union(union.Illum.pfcbtm,illum.entr.chr.po$illum)   # length 22180
# There are 22180 different probes across all four areas

diff.Probe.num <- matrix(c(rep(0,6)),nrow=6)
# Get the number of probe differences between each area
diff.Probe.num[1] <- length(setdiff(illum.entr.chr.pf$illum,illum.entr.chr.cb$illum))
diff.Probe.num[2] <- length(setdiff(illum.entr.chr.pf$illum,illum.entr.chr.tm$illum))
diff.Probe.num[3] <- length(setdiff(illum.entr.chr.pf$illum,illum.entr.chr.po$illum))
diff.Probe.num[4] <- length(setdiff(illum.entr.chr.cb$illum,illum.entr.chr.tm$illum))
diff.Probe.num[5] <- length(setdiff(illum.entr.chr.cb$illum,illum.entr.chr.po$illum))
diff.Probe.num[6] <- length(setdiff(illum.entr.chr.tm$illum,illum.entr.chr.po$illum))

row.names(diff.Probe.num) <- c('Prefrontal Cortex vs. Ceberebellum',
                               'Prefrontal Cortex vs. Temporal Cerebral Wall',
                               'Prefrontal Cortex vs. Pons',
                               'Cerebellum vs. Temporal Cerebral Wall',
                               'Cerebellum vs. Pons',
                               'Temporal Cerebral Wall vs. Pons'
                               )
colnames(diff.Probe.num) <- c('Number of Illumina Probe Differences')

diff.Probe.tab <- xtable(diff.Probe.num,
                         caption='Number of Illumina Probe Differences Between Brain Areas:\n Base of 20,000 Probes per Area',digits=0)

print(diff.Probe.tab)

@

\Sexpr{diff.Probe.tab}\\


<<include=FALSE,echo=FALSE,results=tex>>=
############# ********** Compare the top 50 and top 200 +/- correlations in Prefrontal with those
### in the other three areas






@


<<echo=FALSE, include=FALSE, results=hide>>=
### Create a data.frame with all areas, but only those variables necessary to find the top N genes averaged across all four areas. Use Alexander's (1990) method for averaging correlations.

### The relevant variables are:
#### area: prefront, cbell, tempcort, pons
#### Chr number
#### Gene Symbol
#### Correlation of expression with COMT expressiomn in that area
#### P-value of correlation

# dimensions of data sets
dim.Area <- data.frame(area=c('prefront', 'cbell','tempor','pons'),
                       len=rep(0,4), wid=rep(0,4))
# prefrontal
dim.Area$len[1] <- dim(prefront.Meanbothr)[1]
dim.Area$wid[1] <- dim(prefront.Meanbothr)[2]

#cerebellum
dim.Area$len[2] <- dim(cbell.Data)[1]
dim.Area$wid[2] <- dim(cbell.Data)[2]

#temporal cortex
dim.Area$len[3] <- dim(tempor.Data)[1]
dim.Area$wid[3] <- dim(tempor.Data)[2]

#pons
dim.Area$len[4] <- dim(pons.Data)[1]
dim.Area$wid[4] <- dim(pons.Data)[2]

@

<<include=FALSE,echo=FALSE,results=hide>>=

all.Area.dat <- data.frame(areapf=rep(NA,dim.Area$len[1]),
                           chrpf=rep(NA,dim.Area$len[1]),
                           genepf=rep(NA,dim.Area$len[1]),
                           corrpf=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpf=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpf=rep(NA,dim.Area$len[1]),
                           areacb=rep(NA,dim.Area$len[1]),
                           chrcb=rep(NA,dim.Area$len[1]),
                           genecb=rep(NA,dim.Area$len[1]),
                           corrcb=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalcb=as.numeric(rep(NA,dim.Area$len[1])),
                           illumcb=rep(NA,dim.Area$len[1]),
                           areatc=rep(NA,dim.Area$len[1]),
                           chrtc=rep(NA,dim.Area$len[1]),
                           genetc=rep(NA,dim.Area$len[1]),
                           corrtc=as.numeric(rep(NA,dim.Area$len[1])),
                           pvaltc=as.numeric(rep(NA,dim.Area$len[1])),
                           illumtc=rep(NA,dim.Area$len[1]),
                           areapo=rep(NA,dim.Area$len[1]),
                           chrpo=rep(NA,dim.Area$len[1]),
                           genepo=rep(NA,dim.Area$len[1]),
                           corrpo=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpo=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpo=rep(NA,dim.Area$len[1])
                           )




prefront.Ess <- data.frame(area=rep('prefront',dim.Area$len[1]),
                      loc=prefront.Meanbothr$chr,
                      Symbol=prefront.Meanbothr$gene,
                      Sample.r=prefront.Meanbothr$corr,
                      Sample.p.r=prefront.Meanbothr$pval,
                      Record=prefront.Meanbothr$record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(prefront.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
prefront.Ess <- prefront.Ess[c(sort.Ind$ix),]


cbell.Ess <- data.frame(area=rep('cbell',dim.Area$len[1]),
                      loc=cbell.Data$loc,
                      Symbol=cbell.Data$Symbol,
                      Sample.r=cbell.Data$Sample.r,
                      Sample.p.r=cbell.Data$Sample.p.r.,
                      Record=cbell.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(cbell.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
cbell.Ess <- cbell.Ess[c(sort.Ind$ix),]


tempor.Ess <- data.frame(area=rep('tempor',dim.Area$len[1]),
                      loc=tempor.Data$loc,
                      Symbol=tempor.Data$Symbol,
                      Sample.r=tempor.Data$Sample.r,
                      Sample.p.r=tempor.Data$Sample.p.r.,
                      Record=tempor.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(tempor.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
tempor.Ess <- tempor.Ess[c(sort.Ind$ix),]


pons.Ess <- data.frame(area=rep('pons',dim.Area$len[1]),
                      loc=pons.Data$loc,
                      Symbol=pons.Data$Symbol,
                      Sample.r=pons.Data$Sample.r,
                      Sample.p.r=pons.Data$Sample.p.r.,
                      Record=pons.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(pons.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
pons.Ess <- pons.Ess[c(sort.Ind$ix),]

all.Area.dat[,1:6] <- prefront.Ess
all.Area.dat[,7:12] <- cbell.Ess
all.Area.dat[,13:18] <- tempor.Ess
all.Area.dat[,19:24] <- pons.Ess

cols.Corr <- c(4,10,16,22)
cols.Gene <- c(3,9,15,21)

ind.Ill <- matrix(rep(NA,4*dim.Area$len[1]),ncol=4)
for (i in 1:dim.Area$len[1]) {
     
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumcb)) {
               ind.Ill[i,2] <- which(as.character(all.Area.dat$illumcb)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,2] <- c(NA)
     }         
               
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumtc)) {            ind.Ill[i,3] <- which(as.character(all.Area.dat$illumtc)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,3] <- c(NA)
     }         
               
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumpo)) {
          ind.Ill[i,4] <- which(as.character(all.Area.dat$illumpo)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,4] <- c(NA)
     } 
          
          }

ind.Ill[,1] <- seq(1,dim.Area$len[1],1)     

#### ******* In all.Area.dat, each area's columns, are sorted separately by area on the correlation. ind.Ill shows where each probe is (index) by area


# This orders the data independently in each brain area by a particular variable
# all.Area.dat[,1:6] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[1]]),decreasing=FALSE),c(1:6)]
# all.Area.dat[,7:12] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[2]]),decreasing=FALSE),c(7:12)]
# all.Area.dat[,13:18] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[3]]),decreasing=FALSE),c(13:18)]
# all.Area.dat[,19:24] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[4]]),decreasing=FALSE),c(19:24)]

@

<<include=FALSE, echo=FALSE, results=tex>>=
# Calculate average correlation with COMT expression of each probe's expression
# Use Alexander (1990) to average correlations
# ind.Ill holds the indices for cerebellum, temporal cortex and pons of each probe on prefrontal cortex.

hold.Corrs <- data.frame(illum=rep(NA,dim.Area$len[1]),
                         gene=rep(NA,dim.Area$len[1]),
                         corpf=rep(0,dim.Area$len[1]),
                         corcb=rep(0,dim.Area$len[1]),
                         cortc=rep(0,dim.Area$len[1]),
                         corpo=rep(0,dim.Area$len[1])
                         )

##### ***** The next code sorts hold.Corrs by the sorted correlations in the prefrontal cortex
##### ***** In other words, the correlations are no longer sorted separately by area, but ###### instead the probeID order in prefrontal cortex after having been sorted by pf
##### correlation determines the correlations shown in that row in the other three areas
# For example, just making up a scenario, whatever probeID has the second strongest expression correlation with COMT in prefrontal cortex might have a correlation of r=.65 in the cerebellum. That is the correlation that would show up in the second row for the cerebellum

hold.Corrs$illum <- all.Area.dat$illumpf
hold.Corrs$gene <- all.Area.dat$genepf
hold.Corrs$corpf <- all.Area.dat$corrpf
hold.Corrs$corcb <- all.Area.dat$corrcb[c(ind.Ill[,2])]
hold.Corrs$cortc <- all.Area.dat$corrtc[c(ind.Ill[,3])]
hold.Corrs$corpo <- all.Area.dat$corrpo[c(ind.Ill[,4])]

# average these four correlations and put them into a new column
# Use Alexander (1990) to average

ki <- c(4)
n.subj <- c(144,144,144,144)

# Calculate in parts then put together

sum.corr <- matrix(rep(0,dim.Area$len[1]),ncol=1)
for (l in 1:dim.Area$len[1]) {
     
     sum.corr[l] <-sum((((n.subj[1:4] - 1))/(sum(n.subj) - ki))*(hold.Corrs[l,3:6] + (hold.Corrs[l,3:6]*(1 - hold.Corrs[l,3:6]^2))/(2*(n.subj[1:4] - 3))))
     
hold.Corrs$avgCorr[l] <- sum.corr[l]
}

@

<<include=FALSE, echo=FALSE, results=tex>>=

## Leave columns sorted by correlation in prefrontal cortex

top200_neg_ordered_by_pf_corr <- xtable(hold.Corrs[1:cut.Part,],
                           caption=paste('Correlations of expression with COMT in each brain area for the ',cut.Part,' probes that show the strongest positive correlations in prefrontal cortex',sep=''))


write.table(hold.Corrs[1:cut.Part,],file=paste('top',cut.Part,'_neg_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,
            quote=FALSE)
write.table(hold.Corrs[1:cut.Part,1:3],file=paste('top',cut.Part,'_neg_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,
            quote=FALSE)



top200_neg_ordered_by_pf_corr <- xtable(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-200),],
                           caption=paste('Correlations of expression with COMT in each brain area for the ',cut.Part,' probes that show the strongest negative correlations in prefrontal cortex',sep=''))

# Note that these are written in reverse order because they are negative: 20,000:19800
write.table(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-200),],file=paste('top',cut.Part,'_neg_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,quote=FALSE)
write.table(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-200),1:3],file=paste('top',cut.Part,'_neg_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,quote=FALSE)


@



<<include=FALSE, echo=FALSE, results=tex>>=
# Tally the chromosome numbers of the top 200 + and top 200 - in each brain area separately
# Are (+) correlated genes more likely to be on the same chromosome than (-) correlated genes?
# Do this both for the top 200 as well as for all 20000 probes.
# Use the data.frame dfsort
# colnames(dfsort)
#[1] "chr"     "corsign" "freq"
# dfsort is already in tabular form

corsign.By.chr <- dfsort
corsign.By.chr$pm <- factor(rep(c('minus','plus'),each=24))
corsign.By.chr <- corsign.By.chr[,c(1,4,3)]

colnames(corsign.By.chr) <- c('chr','corsign','count')

xtabs.ChrCorsign <- xtabs(count ~ chr + corsign,data=corsign.By.chr)

chisq.ChrCorsign.out <- chisq.test(xtabs.ChrCorsign)
print(chisq.ChrCorsign.out)

@

The chi-square test of independence shows that the number of genes showing positive versus negative correlations with COMT is not independent of Chromosome number in prefrontal cortex.\\

Next, use the binomial distribution to determine if the distribution on Chr 22 where COMT is differs from the distribution on all other chromosomes.\\

<<include=FALSE, echo=FALSE, results=tex>>=
# First get the numbers of plus and minus correlations aggregated across all chromosomes except Chr 22.
# Get total probes/genes on Chr 22

pm.Sans22 <- c(rep(0,2))
pm.Sans22[1] <- sum(xtabs.ChrCorsign[,1]) - xtabs.ChrCorsign[22,1]
pm.Sans22[2] <- sum(xtabs.ChrCorsign[,2]) - xtabs.ChrCorsign[22,2]

counts.22 <- sum(xtabs.ChrCorsign[22,])
counts.Sans22 <- sum(pm.Sans22)

obs.Minus.22 <- xtabs.ChrCorsign[22,1]

p.minus.22 <- obs.Minus.22/counts.22


# probability of negative correlations across all chromosomes except Chr 22
p.minus <- pm.Sans22[1]/counts.Sans22

# get the binomial distribution with p = p.minus and the sample size of the number of probes on Chr 22
d.minus <- dbinom(seq(0,counts.22,1),counts.22,p.minus)

d.minus <- data.frame(num.minus = seq(0,counts.22,1),prob=d.minus)

# Now get the probability of xtabs.ChrCorsign[22,1] minuses or fewer given counts.22 probes. In this case
# p(k <= 286 minuses) with Binomial(N=19171, p = 0.63888)

cumul.d.minus <- sum(d.minus[1:(obs.Minus.22 + 1),2])

binom.test(obs.Minus.22, counts.22, p = p.minus,
           alternative = c("less"),
           conf.level = 0.95)

binom.test(obs.Minus.22, counts.22, p = p.minus,
           alternative = c("two.sided"),
           conf.level = 0.95)


# The proportion of negatively COMT-correlated genes in prefrontal cortex, 0.54806, is significantly lower than the proportion aggregated across all the other chromosomes, 0.63888.
@

The proportion genes with negative correlations mwith MB-COMT on Chr 22, \Sexpr{p.minus.22}, is signficantly lower than the proportion aggregated across all of the other chromosomes, \Sexpr{p.minus}.\\ 

<<include=FALSE, echo=FALSE, fig=TRUE, pdf=TRUE>>=

vcut <- data.frame(x1=(obs.Minus.22 + 0.5), x2=(obs.Minus.22 + 0.5), y1=-0.00075, y2=0.02)
p.low.d.minus <- subset(d.minus,d.minus$num.minus < (obs.Minus.22 + 1))

minus.plot <- ggplot() +
          
          geom_point(data=d.minus, aes(x=num.minus,y=prob,group=1),
                     size=0.6,color='blue',shape=1) +
     
          geom_point(data=p.low.d.minus, aes(x=num.minus,y=prob,group=1),
                     size=0.6,color='red',shape=1) +
     
          geom_segment(data=vcut, aes(x=x1,xend=x2,y=y1,yend=y2), color='red',size=0.5)  +
          
          scale_y_continuous(breaks = seq(0,0.05,0.01),
                             labels = comma(seq(0,0.05,0.01), digits = 2)) +
          
          scale_x_continuous(name='Number of Negative Correlations (k)',
                             limits=c(0,round((counts.22 + 5),0)),
                             breaks=seq(0,round((counts.22 + 5),0),200)) +
          
          theme_classic() +
          
          
          ggtitle('Probability of Negative Correlations Based on All Chromosomes Except Chr 22' ) +
          
          ylab('Probability density') + 
          theme(aspect.ratio=1/gold.R) + 
          theme(plot.title = element_text(color="black",
                                          size=8.5,
                                          hjust=0.5)) +
          theme(axis.title = element_text(color="black",
                                          size=10,
                                          vjust=1
          )) +

               theme(axis.text.x = element_text(size=8),
                axis.text.y = element_text(size=8)) +
          
          annotate("text", x = (obs.Minus.22 - 65),
                   y = 0.005,
                   label = c(paste('p(k < ',(obs.Minus.22 + 1),') = ',
                                   round(cumul.d.minus,8),sep='')),
                   color="black",
                   size=3.0)    +
     
          annotate("text", x = 0.10*(round((counts.22 + 5),0)),
                   y = 1.10*max(d.minus$prob),
                   label = c(paste('unique ID: ',prog.Name,sep='')),
                   parse=FALSE,
                   color="gray20",
                   size=1.5) 

file1.pdf <- c('p_binomial_mb_comt.pdf')
   ggsave(file1.pdf, plot = minus.plot, width = 8, height = 5.5)

minus.plot

@

%\includegraphics[width=0.5\textwidth]{p_binomial_comt_s.eps}\\

<<include=FALSE, echo=FALSE, results=tex>>=
#Get the mean and sd of the top 200 positives and negatives in each area

mean.sd.By.areaneg <- psych::describe(all.Area.dat[2:(cut.Part+1),cols.Corr])
mean.sd.By.areaNeg <- psych::describe(all.Area.dat[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]- cut.Part),cols.Corr])


@





<<include=FALSE, echo=FALSE, results=TEX>>= 
# Test the hypothesis that the rank order of the most negatively correlated genes changes more across brain area than do the rank orders of the most highly positively correlated genes.

# Rank the genes on their correlations separately by area, then compare the ranks of specific genes across areas to determine if there are greater differences among negatively correlated genes than among positively correlated genes.

### Do this with the all.Area.dat which has the strongest correlations in each brain area separately. Have to use ind.Ill to find out what those probes are in each area.

hold.Area.dat <- data.frame(areapf=rep(NA,dim.Area$len[1]),
                           chrpf=rep(NA,dim.Area$len[1]),
                           genepf=rep(NA,dim.Area$len[1]),
                           corrpf=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpf=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpf=rep(NA,dim.Area$len[1]),
                           areacb=rep(NA,dim.Area$len[1]),
                           chrcb=rep(NA,dim.Area$len[1]),
                           genecb=rep(NA,dim.Area$len[1]),
                           corrcb=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalcb=as.numeric(rep(NA,dim.Area$len[1])),
                           illumcb=rep(NA,dim.Area$len[1]),
                           areatc=rep(NA,dim.Area$len[1]),
                           chrtc=rep(NA,dim.Area$len[1]),
                           genetc=rep(NA,dim.Area$len[1]),
                           corrtc=as.numeric(rep(NA,dim.Area$len[1])),
                           pvaltc=as.numeric(rep(NA,dim.Area$len[1])),
                           illumtc=rep(NA,dim.Area$len[1]),
                           areapo=rep(NA,dim.Area$len[1]),
                           chrpo=rep(NA,dim.Area$len[1]),
                           genepo=rep(NA,dim.Area$len[1]),
                           corrpo=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpo=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpo=rep(NA,dim.Area$len[1])
                           )
     
cols.Corr <- c(4,10,16,22)
cols.Gene <- c(3,9,15,21)     
     
hold.Area.dat[,1:6] <- all.Area.dat[order(all.Area.dat[,cols.Corr[1]],decreasing=TRUE),c(1:6)]
hold.Area.dat[,7:12] <- all.Area.dat[order(all.Area.dat[,cols.Corr[2]],decreasing=TRUE),c(7:12)]
hold.Area.dat[,13:18] <- all.Area.dat[order(all.Area.dat[,cols.Corr[3]],decreasing=TRUE),c(13:18)]
hold.Area.dat[,19:24] <- all.Area.dat[order(all.Area.dat[,cols.Corr[4]],decreasing=TRUE),c(19:24)]

@


<<include=FALSE, echo=FALSE, results=tex>>=
# now for the 200 genes with the largest negative correlations in Prefrontal Cortex, find their ranks in the other three areas



rank.Stab.neg <- matrix(rep(0,4*cut.Part),ncol=4)

# First do negative correlations
for (h in 1:cut.Part) {
     
     rank.Stab.neg[h,1] <-(20000 - (cut.Part -h))
     
     if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumcb)) {
          rank.Stab.neg[h,2] <- which(as.character(hold.Area.dat$illumcb) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,2] <-  c(NA)  
          
     }    
     
     if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumtc)) {
          rank.Stab.neg[h,3] <- which(as.character(hold.Area.dat$illumtc) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,3] <-  c(NA)  
          
     }
     
    if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumpo)) {
          rank.Stab.neg[h,4] <- which(as.character(hold.Area.dat$illumpo) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,4] <-  c(NA)  
          
     }
     
}

colnames(rank.Stab.neg) <- c('rankpf','rankcb','ranktc','rankpo')
rank.Stab.neg <- data.frame(rank.Stab.neg)
rank.Stab.neg$illum <- hold.Area.dat$illumpf[(20000 - (cut.Part -1)):20000]
rank.Stab.neg$gene <- hold.Area.dat$genepf[(20000 - (cut.Part -1)):20000]
rank.Stab.neg <- rank.Stab.neg[,c(5,6,1:4)]

overlap.Area <- list()

# [[1]] pf vs cb
# [[2]] pf vs tc
# [[3]] pf vs po
# [[4]] cb vs tc
# [[5]] cb vs po
# [[6]] tc vs po

overlap.Area[[1]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$rankcb)
overlap.Area[[2]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$ranktc)
overlap.Area[[3]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$rankpo)
overlap.Area[[4]] <- intersect(rank.Stab.neg$rankcb,rank.Stab.neg$ranktc)
overlap.Area[[5]] <- intersect(rank.Stab.neg$rankcb,rank.Stab.neg$rankpo)
overlap.Area[[6]] <- intersect(rank.Stab.neg$ranktc,rank.Stab.neg$rankpo)

perc.Overlap <- data.frame(compare=(rep(NA,6)),num=c(rep(0,6)),percentage=c(rep(0,6)),
                           n.base=c(rep(0,6)),ofn=c(rep(NA,6)))
perc.Overlap$compare <- c('prefrontal cortex vs. cerebellum',
                         'prefrontal cortex vs. temporal cortex',
                         'prefrontal cortex vs. pons',
                         'cerebellum vs. temporal cortex',
                         'cerebellum vs. pons',
                         'temporal cortex vs. pons')

for (g in 1:6) {
     
    perc.Overlap$n.base[g]  <- cut.Part - length(which(is.na(rank.Stab.neg[,g])))
     perc.Overlap$num[g]  <- length(overlap.Area[[g]]) 
    perc.Overlap$percentage[g]  <- paste(round(100*(perc.Overlap$num[g])/(perc.Overlap$n.base[g]),0),'%',sep='')
}

perc.Overlap.neg <- perc.Overlap
perc.Overlap.neg$ofn <- paste(perc.Overlap$num,' (',perc.Overlap$n.base,')',sep='')

colnames(perc.Overlap.neg) <- c('Comparison','number shared','Percentage','base n',
                                'Shared Genes (N)')
overlap.Neg <- xtable(perc.Overlap.neg[,c(1,5,3)],
                         caption=c('Of the genes with the strongest negative correlations with COMT expression,\n the percentage of genes found in both areas'))

overlap.Neg


@

<<include=FALSE, echo=FALSE, results=tex>>=
# now for the 200 genes with the largest positive correlations in Prefrontal Cortex, find their ranks in the other three areas


#cut.Part <- c(200)
rank.Stab.neg <- matrix(rep(0,4*cut.Part),ncol=4)

# Now do positive correlations
for (h in 1:cut.Part) {
     
     rank.Stab.neg[h,1] <- h
     
     if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumcb)) {
          rank.Stab.neg[h,2] <- which(as.character(hold.Area.dat$illumcb) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.neg[h,2] <-  c(NA)  
          
     }    
     
     if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumtc)) {
          rank.Stab.neg[h,3] <- which(as.character(hold.Area.dat$illumtc) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.neg[h,3] <-  c(NA)  
          
     }
     
    if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumpo)) {
          rank.Stab.neg[h,4] <- which(as.character(hold.Area.dat$illumpo) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.neg[h,4] <-  c(NA)  
          
     }
     
}



colnames(rank.Stab.neg) <- c('rankpf','rankcb','ranktc','rankpo')
rank.Stab.neg <- data.frame(rank.Stab.neg)
rank.Stab.neg$illum <- hold.Area.dat$illumpf[1:cut.Part]
rank.Stab.neg$gene <- hold.Area.dat$genepf[1:cut.Part]
rank.Stab.neg <- rank.Stab.neg[,c(5,6,1:4)]

overlap.Area <- list()

# [[1]] pf vs cb
# [[2]] pf vs tc
# [[3]] pf vs po
# [[4]] cb vs tc
# [[5]] cb vs po
# [[6]] tc vs po

overlap.Area[[1]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$rankcb)
overlap.Area[[2]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$ranktc)
overlap.Area[[3]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$rankpo)
overlap.Area[[4]] <- intersect(rank.Stab.neg$rankcb,rank.Stab.neg$ranktc)
overlap.Area[[5]] <- intersect(rank.Stab.neg$rankcb,rank.Stab.neg$rankpo)
overlap.Area[[6]] <- intersect(rank.Stab.neg$ranktc,rank.Stab.neg$rankpo)


perc.Overlap <- data.frame(compare=(rep(NA,6)),num=c(rep(0,6)),percentage=c(rep(0,6)),
                           n.base=c(rep(0,6)),ofn=c(rep(NA,6)))
perc.Overlap$compare <- c('prefrontal cortex vs. cerebellum',
                         'prefrontal cortex vs. temporal cortex',
                         'prefrontal cortex vs. pons',
                         'cerebellum vs. temporal cortex',
                         'cerebellum vs. pons',
                         'temporal cortex vs. pons')

for (g in 1:6) {
     
    perc.Overlap$n.base[g]  <- cut.Part - length(which(is.na(rank.Stab.neg[,g])))
     perc.Overlap$num[g]  <- length(overlap.Area[[g]]) 
    perc.Overlap$percentage[g]  <- paste(round(100*(perc.Overlap$num[g])/(perc.Overlap$n.base[g]),0),'%',sep='')
}

perc.Overlap.neg <- perc.Overlap
perc.Overlap.neg$ofn <- paste(perc.Overlap$num,' (',perc.Overlap$n.base,')',sep='')

colnames(perc.Overlap.neg) <- c('Comparison','number shared','Percentage','base n',
                                'Shared Genes (N)')
overlap.neg <- xtable(perc.Overlap.neg[,c(1,5,3)],
                         caption=c('Of the genes with the strongest positive correlations with COMT expression,\n the percentage of genes found in both areas'))

overlap.neg


@


% {\bfseries {Using the hypergeometric distribution to test for randomness in the number of probes shared in common between the reference area and another area.}}\\
% 
% Testing for probe matches between a reference and a test brain area involves the {\bfseries {hypergeometric}} distribution.\\ The computation of probabilities when sampling without replacement is based on the following pdf:
% 
% \href{http://people.wku.edu/david.neal/109/Unit2/SamplingWO.pdf}{c('MATH 109 Sampling without Replacement)}
% 
% Here is the description of the calculation: \\
% 
% {\bfseries {Sampling Without Regard to Order}}\\
% Now  supnege  we  have  a  population  of N elements  that  are  divided  into  two  types: Type I  which has A elements,  and Type II which has B elements, where $A + B == N$.\\  
% 
% For  example,  a  standard  deck  of  $N == 52$  playing  cards  can  be  divided  in  many  ways. Type  I  could  be  Hearts  and  Type  II    could  be  All  Others.    Then  there  are   $A == 13$ Hearts and  $B == 39$ Others.\\
% 
% In analogy to the genes/probes problem, $N == 20,000$ probes,  $A == 50$ or 200, as in the top 50 or the top 200 most strongly positively/negatively {\textit {COMT}}-correlated probes. Thus B is either 19,950 ($A == 50 $) or B is 19,800 ( $A == 200$). 
% 
% There are two other parameters: $n == $the number of probes randomnly sampled without replacement, and  $k = $ the number of probes in the sample of size n that also are contained in A. The calculation for the probability that a sample of size n will contain k probes in common with the set in A is:\\
% $$
% p = \frac{\binom{A,k}*\binom{B,(n-k)}}{\binom{N,n}}
% $$


<<include=FALSE, echo=FALSE, results=tex>>=
# Conditional on the 500 probes with expression levels most strongly positively and negatively correlated with COMT expression in Prefrontal Cortex, find the probability of n of 500 matching

# Sampling without replacement

# rank.order.stats
#            compare   n   rho        pvalue
# 1  PFCtx vs. Cereb 120 0.510 0.00000000263
# 2 PFCtx vs. TemCtx 254 0.544 0.00000000000
# 3   PFCtx vs. Pons 114 0.460 0.00000026122
# 4 Cereb vs. TemCtx 109 0.399 0.00001709187
# 5   Cereb vs. Pons 208 0.428 0.00000000012
# 6  TemCtx vs. Pons 113 0.472 0.00000013108

# numworking.genes.by.area
#            Number of Genes
# Prefrontal 16670          
# Cerebellum 16685          
# Temporal   16636          
# Pons       16616  



# First compare PFCtx to Cerebellum

     num.Probes <- as.integer(unlist(numworking.genes.by.area[1]))
     N <- num.Probes
     A <- c(500)   # number of probes in the reference area that could be matched
     B <- c(N - A)         # number of probes not in slected set in reference area
n <- A     # sample of 500 probes
# then k ranges from 0 to A matches

###*** Note ***#####
# The average NUMBER of matches to the top 500 probes expected with a sample of 500 randomly
# selected genes in another area will be n x A/N or 500(500/16670) = 14.99; the expected number of matches by chance.

# prob.N will hold the discrete probability distribution for k matches from a sample size either of 500.

prob.N <- mpfr(matrix(rep(0,(A+1))),precBits=50)
for (k in 1:A) {
     
     prob.N[k+1] <- (chooseMpfr(A,k)*chooseMpfr(B,(n-k)))/chooseMpfr(N,n)
}


prob.N[1] <- 1.0 - sum(prob.N[2:(A+1)])


     prob.N.500 <- data.frame(n.match=seq(0,A,1),log10prob=as.numeric(log10(prob.N)))
     write.table(prob.N.500,file=paste('hypergeometric_probability_table_',A,'.csv',sep=''),sep=', ',row.names=FALSE)


Nx <- N      # number of objects
Ax <- A       # sample size
k <- Ax        # number of matches
pairs.probA <- mpfr(matrix(rep(0,2*(k+1)),ncol=2),10557)
pairs.probA[,1] <- c(0:k)



for (hj in 0:k) {
     
     hj <- as.integer(c(10))
     pairs.probA[hj+1,2] <- chooseMpfr(Nx,(Ax-hj))*(((Nx^2) - Nx)/Nx^2)^(Ax-hj)*chooseMpfr((Nx-(Ax-hj)),hj)*(1/Nx)^hj
     
}

repts <- c(10000)
Nx <- N #c(10)
Ax <- A #c(5)
pairs.prob <- matrix(rep(0,(Ax+1)*2),ncol=2)
pairs.prob[,1] <- c(0:Ax)

for (kl in 1:repts)   {
     
     samp1 <- sample(c(1:Nx),Ax,replace=FALSE)
     samp2 <- sample(c(1:Nx),Ax,replace=FALSE)
     num.match <- sum(samp1 %in% samp2)
     pairs.prob[num.match + 1,2] <- pairs.prob[num.match + 1,2] + 1 

}

pairs.prob[,2] <- pairs.prob[,2]/repts
plot(pairs.prob[,1],pairs.prob[,2])


@


<<include=FALSE, echo=FALSE>>=  # , fig=TRUE, pdf=TRUE
# For plotting purneges, the last probability in each frame is 0, so leave that out
# also because it is a discrete distribution, only plot every 5th or 10th point

     
# Using <<- instead of <- allows the variable to used globally
     # Do this when prob.N.500 is first set up in another program
#prob.N.500.plot <- prob.N.500[c(seq(1,200,10)),]
     # Call the hyperplot.R function to plot the hypergeometric distributions

hiLim <- c(500)
limitseq <- c(-1000,0,100)

# Using <<- instead of <- allows the variable to used globally
     # Do this when prob.N.200 is first set up in another program

     p.plot <- hyper.plot(prob.N.500,hiLim,limitseq,prog.Name,N)     

p.plot

# file.eps <- c('hypergeometric_distribution_500.pdf')
#   negtscript(file=file.eps,horiz=FALSE,onefile=FALSE,width=8.0,height=5.5,paper='letter')
# 
# p.plot

@

The hypergeometric distributions using the parameters described above are shown in the next figure.\\

%\includegraphics[width=0.5\textwidth]{hypergeometric_matching_genes_diagram.pdf}\\


<<include=FALSE, echo=FALSE, results=tex>>=
############## This needs to be changed to reflect the two prob.N as prob.N.50 and prob.N.200 and the fact that the probabilities are already represented as log10

genes.In.common <- cbind(perc.Overlap.neg[,c(1,5,3)],perc.Overlap.neg[,c(5,3)])



     genes.In.common$logp.valneg <- round(as.numeric(prob.N.200[(perc.Overlap.neg[,2]+1),2]),1)
     genes.In.common$logp.valneg <- round(as.numeric(prob.N.200[(perc.Overlap.neg[,2]+1),2]),1)

     
genes.In.common <- genes.In.common[,c(1:3,6,4,5,7)]

genes.In.common.tab <- xtable(genes.In.common,
                   caption = c(paste("Percentages of the ",cut.Part," Most Strongly Correlated Genes Shared in Common Between Two Brain Areas",sep="")))


genes.In.common.ltx <- latex(genes.In.common.tab,file='',
                   caption = c(paste("Percentages of the ",cut.Part," Most Strongly Correlated Genes Shared in Common Between Two Brain Areas",sep="")),
                     caption.loc = c('top'),
#                     colname = c('Name','URL'),
                     rowlabel = NULL,
                     colnamesTexCmd="bfseries",
                     booktabs=TRUE,
                     label=c('tab:sharedgenes'),
                     na.blank = TRUE,
                     vbar = FALSE,
                     longtable=TRUE,
                     table.env=TRUE,
                     center=c('center'),
                     continued=c('Genes Shared Across Areas Continued'),
                     first.hline.double = TRUE,
                     append=FALSE
                     )
                  
print(genes.In.common.ltx)

write.table(genes.In.common,paste('shared_perc_',cut.Part,'_negneg.csv',sep=', '),row.names = FALSE)

@


<<echo=FALSE, results=tex>>=
################################################
### Select the top 200 by p-value to determine which genes expression levels (by chromosome) are most highly correlated with COMT expression.
### Done separately for positive and negative correlations
### Inversely normalized by fitted number of probes from the regression on chr length, but weighted by proportion of each chromosome in the top 200. 
################################################

##### positive correlations with COMT expression only #####################
num.Sel <- cut.Part
full.Count <- table(manhat.negr.pf$CHR)
order.by.P.neg <- manhat.negr.pf[order(manhat.negr.pf$P), ]

order.by.P.neg$P <- -log10(order.by.P.neg$P)
colnames(order.by.P.neg)[3] <- c('-log10p')
xtable(order.by.P.neg[1:num.Sel,],caption=c(paste(cut.Part,' Genes with Strongest positive Correlations with COMT in Prefrontal Cortex',sep='')))

############ End positive only ########################
  
##### Negative correlations with COMT expression only #####################
full.Count <- table(manhat.Negr.pf$CHR)
order.by.P.neg <- manhat.Negr.pf[order(manhat.Negr.pf$P), ]
order.by.P.neg$P <- -log10(order.by.P.neg$P)
colnames(order.by.P.neg)[3] <- c('-log10p')

xtable(order.by.P.neg[1:num.Sel,],caption=c(paste(cut.Part,' Genes with Strongest Negative Correlations with COMT in Prefrontal Cortex',sep='')))

############ End negative only ########################

@

{\bfseries {Gene ontology analysis}}\\

<<echo=FALSE, include=FALSE, results=tex>>=

if (!exists('ensembl')) {
 ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")   
}

normal.chroms <- c(1:22, "X", "Y", "M")

if (!exists('ah')) {
 ah <- AnnotationHub()   
}

if (!exists('orgs')) {
 orgs <- AnnotationHub::query(ah, "org.Hs.eg.db")   
}

if (!exists('gene.DB')) {
 gene.DB <- orgs[["AH57973"]]   
}

# columns(gene.DB)
# keytypes(gene.DB)




# input entrez ID output gene symbol
# temp.Gene <- c('COMT',   'PHGDH',  'DDR1',   'SCAMP2', 'ZFAND3', 'NECAP2', 'HDAC1',  'FTL', 'TST',    'CRYL1')
# 

topplusr.Data$GENE <- gsub(" ", "", topplusr.Data$GENE)
topminusr.Data$GENE <- gsub(" ", "", topminusr.Data$GENE)

twohundred_comt_plus <- na.omit(biomaRt::select(gene.DB,keys=as.character(topplusr.Data$GENE[2:51]),columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL')))

write.table(twohundred_comt_plus,file='twohundred_comt_plus_corr.csv',sep=', ',quote=FALSE)


twohundred_comt_minus <- na.omit(biomaRt::select(gene.DB,keys=as.character(topminusr.Data$GENE[2:51]),columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL')))

write.table(twohundred_comt_minus,file='twohundred_comt_minus_corr.csv',sep=', ',quote=FALSE)


     

     top200.neg <- biomaRt::select(gene.DB,keys=order.by.P.neg$GENE[1:num.Sel],columns=c('GENENAME','SYMBOL','ENTREZID'),keytype=c('SYMBOL'))
     
#          top.neg <- top200.neg
     top.neg <- twohundred_comt_plus
          
     top200.Neg <- biomaRt::select(gene.DB,keys=order.by.P.neg$GENE[1:num.Sel],columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL'))
     


#          top.Neg <- top200.Neg
          top.Neg <- twohundred_comt_minus


neg.Tab <- xtable(top.neg,caption=c(paste('Top ',cut.Part,' positively Correlated Genes with COMT in Prefrontal Cortex',sep='')))

neg.Tab

neg.Tab <- xtable(top.Neg,caption=c(paste('Top ',cut.Part,' Negatively Correlated Genes with COMT in Prefrontal Cortex',sep='')))

neg.Tab

@

<<include=FALSE, echo=FALSE, results=tex>>=

#org.Hs.egGO is an R object that provides
#mappings between entrez gene identifers and the GO
#identifers that they are directly associated with
entrez_object <- org.Hs.egGO    # 


# *********** Ontology on various ranking criteria:

# sort the 500 lowest p-value genes by sign of correlation

lowest.pval.sign.neg <- list()
lowest.pval.sign.neg <- list()


lowest.pval.sign.neg <- lapply(hold.Lowest.pvals[ib], function(x,ib)  subset(x,x$corsign == 1),
                               ib)
lowest.pval.sign.neg <- lapply(hold.Lowest.pvals[ib], function(x,ib)  subset(x,x$corsign == -1),
                               ib)

lowest.pval.sign <- list(neg=lowest.pval.sign.neg,
                         neg=lowest.pval.sign.neg)

# lowest.pval.sign[[1]]$pf$corsign     
                    

########################################################
# Loops to do GOHyperGParams by brain area, correlation valence, and ontology term

# ontology loop: area (im, slowest), correlation valence (val), ontology term ( slowest, ct)

gene.Set.pos <- list()
gene.Set.neg <- list()

gene.Set.pos[[1]] <- as.character(hold.Lowest.pvals.pos[[1]]$ENTREZID)
gene.Set.pos[[2]] <- as.character(hold.Lowest.pvals.pos[[2]]$ENTREZID)
gene.Set.pos[[3]] <- as.character(hold.Lowest.pvals.pos[[3]]$ENTREZID)
gene.Set.pos[[4]] <- as.character(hold.Lowest.pvals.pos[[4]]$ENTREZID)


gene.Set.neg[[1]] <- as.character(hold.Lowest.pvals.neg[[1]]$ENTREZID)
gene.Set.neg[[2]] <- as.character(hold.Lowest.pvals.neg[[2]]$ENTREZID)
gene.Set.neg[[3]] <- as.character(hold.Lowest.pvals.neg[[3]]$ENTREZID)
gene.Set.neg[[4]] <- as.character(hold.Lowest.pvals.neg[[4]]$ENTREZID)

gene.Set <- list(pos=gene.Set.pos,
                 neg=gene.Set.neg)

universe <- list()
# This uses all 20,000 probes
# universe[[1]] <- as.character(unique(major.Area[[1]]$ENTREZID))
# universe[[2]] <- as.character(unique(major.Area[[2]]$ENTREZID))
# universe[[3]] <- as.character(unique(major.Area[[3]]$ENTREZID))
# universe[[4]] <- as.character(unique(major.Area[[4]]$ENTREZID))

# This is one probe per gene
universe[[1]] <- as.character(unique(gene.Major[[1]]$ENTREZID))
universe[[2]] <- as.character(unique(gene.Major[[2]]$ENTREZID))
universe[[3]] <- as.character(unique(gene.Major[[3]]$ENTREZID))
universe[[4]] <- as.character(unique(gene.Major[[4]]$ENTREZID))


GO.ontology <- list()
gene.Symbols.ontol <- list()
gene.entrez.ontol <- list()


go.categ <- c('BP','MF','CC')

for (im in ib)  {
     
     GO.ontol.results <- list()         #reset for each new brain area
     gene.Symbols.val <- list()         #reset for each new brain area
     gene.entrez.val <- list()
     for (val in 1:2)   {
          
          GO.ontol <- list()            #reset for each new corr valence
          GO.ontol.temp <- list()       #reset for each new corr valence
          gene.Symbols.term <- list()   #reset for each new corr valence
          gene.entrez.term <- list()   #reset for each new corr valence
          for (ct in 1:3)  {

               gene.Symbols.GOid <- list()
               gene.entrez.GOid <- list()
               # #### DEBUG #####
               # im <- c(1)
               # val <- c(2)
               # ct <- c(1)
               # ig <- c(1)
               # #### END DEBUG ####
               
cat(paste('area = ',im,' valence = ',val,' ontology = ',go.categ[ct],'\n ',sep=''))
               
          params <- new('GOHyperGParams',                          #
              # geneIds=target.background.genes[[im]]$gene.set,
              # universeGeneIds=target.background.genes[[im]]$universe,
              geneIds=as.character(gene.Set[[val]][[im]]),
              universeGeneIds=as.character(universe[[im]]),
              ontology=go.categ[ct],
              pvalueCutoff=0.001,
              conditional=F,
              testDirection='over',
              annotation="org.Hs.eg.db"
             )
GO.ontol[[ct]] <- hyperGTest(params)
GO.ontol.temp[[ct]] <- summary(GO.ontol[[ct]])

############# Get gene symbols for genes in each significant GOID ################

ontol.genes.allgos.temp <- list()  #reset for each new ontology term
ontol.genes.mygos.temp <- list()   #reset for each new ontology term

if (dim(GO.ontol.temp[[ct]])[1] > 0)   {
     for (ig in 1:dim(GO.ontol.temp[[ct]])[1]) {

     ontol.genes.allgos.temp[[ig]] <- geneIdUniverse(GO.ontol[[ct]])[[ig]]
     ontol.genes.mygos.temp[[ig]] <- geneIds(GO.ontol[[ct]])[geneIds(GO.ontol[[ct]]) %in% ontol.genes.allgos.temp[[ig]]]
     gene.entrez.GOid[[ig]] <- ontol.genes.mygos.temp[[ig]]

     gene.Symbols.GOid[[ig]] <- getBM(c("hgnc_symbol"),
                             filters = c("entrezgene"),
                             values = list(entrezgene=ontol.genes.mygos.temp[[ig]]),
                             mart = ensembl)
     
}  # number of significant GOIDs
     

     gene.Symbols.term[[ct]] <- gene.Symbols.GOid
     gene.entrez.term[[ct]] <- gene.entrez.GOid
     
} else {
     
     gene.Symbols.term[[ct]] <- 'None'
     gene.entrez.term[[ct]] <- 'None'
}
############# END Get gene symbols for genes in each significant GOID ##############

     }  # end ontology term loop
     
     GO.ontol.results[[val]] <- GO.ontol.temp
     gene.Symbols.val[[val]] <- gene.Symbols.term
     gene.entrez.val[[val]] <- gene.entrez.term
     
          } # end correlation valence loop
     
     GO.ontology[[im]] <- GO.ontol.results     
     gene.Symbols.ontol[[im]] <- gene.Symbols.val    
     gene.entrez.ontol[[im]] <- gene.entrez.val 
} # end brain area loop

gene.ontologies <- list(symbols=gene.Symbols.ontol,
                        entrez=gene.entrez.ontol)

### write out ontologies
wGO <- createWorkbook(type="xlsx")

sheetnameBP.neg <- c('pf_neg_BP',
               'cb_neg_BP',
               'tm_neg_BP',
               'po_neg_BP')
               
sheetnameMF.neg <- c('pf_neg_MF',
               'cb_neg_MF',
               'tm_neg_MF',
               'po_neg_MF')
               
sheetnameCC.neg <- c('pf_neg_CC',
               'cb_neg_CC',
               'tm_neg_CC',
               'po_neg_CC')

sheetnameBP.pos <- c('pf_pos_BP',
               'cb_pos_BP',
               'tm_pos_BP',
               'po_pos_BP')
               
sheetnameMF.pos <- c('pf_pos_MF',
               'cb_pos_MF',
               'tm_pos_MF',
               'po_pos_MF')
               
sheetnameCC.pos <- c('pf_pos_CC',
               'cb_pos_CC',
               'tm_pos_CC',
               'po_pos_CC')

sheetnameBP <- list(pos=sheetnameBP.pos,
                     neg=sheetnameBP.neg)

sheetnameMF <- list(pos=sheetnameMF.pos,
                     neg=sheetnameMF.neg)

sheetnameCC <- list(pos=sheetnameCC.pos,
                     neg=sheetnameCC.neg)

sheetname <- list(BP=sheetnameBP,
                  MF=sheetnameMF,
                  CC=sheetnameCC)

sheet <- list()
sheet.temp <- list()
sheet.val <- list()

for (im in ib)   {
     for (kj in 1:2)    {
          for (ct in 1:3)  {
               sheet.temp[[ct]] <- xlsx::createSheet(wGO, sheetName = sheetname[[ct]][[kj]][[im]])
               addDataFrame(as.data.frame(GO.ontology[[im]][[kj]][[ct]]), 
                                        sheet.temp[[ct]],
                                        startRow=1, 
                                        startColumn=1)
     } 
     
               sheet.val[[kj]] <- sheet.temp
     }
               sheet[[im]] <- sheet.val
}

saveWorkbook(wGO, "ontology_from500_GOHyperP.xlsx")


### write out gene symbol and entrezgene lists for all GO terms in all ontologies

names.ontology.genes <- list(area=stand.Col.names,
                             corrval=c('posr','negr'),
                             ontology=go.categ)


for (im in ib)  {
     for (jk in 1:2)  {
          for (ct in 1:3)  {
             
               name.temp <- paste(names.ontology.genes$area[im],'_',
                                  names.ontology.genes$corrval[jk],'_',
                                  names.ontology.genes$ontology[ct],
                                  '_',sep='')  
     names(gene.Symbols.ontol[[im]][[jk]][[ct]]) <- paste(rep(name.temp,
                    length(gene.Symbols.ontol[[im]][[jk]][[ct]])),c(1:length(gene.Symbols.ontol[[im]][[jk]][[ct]])),sep='')
                                        
          }
                    
     }
     
}

sink("ontology_from500_GOHyperP_genes.txt")
print(gene.Symbols.ontol)
sink()




####### END ontology by GOHyperGParams

##### RamiGO #############
goIDs <- GO.ontology[[1]][[2]][[1]][,1]

webserver <- "http://amigo.geneontology.org/visualize"
amigo_from500_pf_neg <- getAmigoTree(goIDs, 
                                     pvalues=GO.ontology[[1]][[2]][[1]][,2], 
             pcolors = c("white","tomato"),psplit = c(1,0.25,0.1,0.05,0.001), 
             filename='amigoTree_from500_test', picType = "dot",
             modeType = "amigo", webserver, saveResult = TRUE)

tt2 <- readAmigoDot(filename="amigoTree_from500_test.dot")


##########################


####### Ontology comparisons GOSemSim
d <- godata('org.Hs.eg.db', ont="BP", computeIC=FALSE)
cluster1 <- gene.entrez.ontol[[1]][[1]][[1]][1]
cluster2 <- gene.entrez.ontol[[1]][[2]][[1]][1]
clusters <- list(a=cluster1, b=cluster2)
clusters <- gene.entrez.ontol[[1]][[2]][[1]]
gosemsim_test <- mclusterSim(clusters, semData=d, measure="Wang")

corrplot(gosemsim_test,method='color',order="FPC",addCoef.col = "white",
         is.corr=TRUE,number.cex=0.4)

#######


####### Ontology by enrichGO
ontology.top500.neg.BP <- lapply(hold.Lowest.pvals.neg[ib], function(x,ib) enrichGO(x$ENTREZID,'org.Hs.eg.db', ont="BP", pvalueCutoff=0.01) )

ontology.top500.neg.MF <- lapply(hold.Lowest.pvals.neg[ib], function(x,ib) enrichGO(x$ENTREZID,'org.Hs.eg.db', ont="MF", pvalueCutoff=0.01) )

ontology.top500.neg.CC <- lapply(hold.Lowest.pvals.neg[ib], function(x,ib) enrichGO(x$ENTREZID,'org.Hs.eg.db', ont="CC", pvalueCutoff=0.01) )

####### END ontology by enrichGO


gs1 <- enrichGO(hold.Lowest.pvals.neg[[1]]$ENTREZID,'org.Hs.eg.db', ont="BP", pvalueCutoff=0.01)
gs1.simp <- simplify(gs1, cutoff = 0.7, by = "p.adjust",
                     select_fun = min, 
                     measure = "Wang",
                     semData = NULL)

########## DAVID ontology
ontol.DAVID.neg <- list()
for (im in ib)   {

     
ontol.DAVID.neg[[im]] <- enrichDAVID(hold.Lowest.pvals.neg[[im]]$ENTREZID, 
            idType = "ENTREZ_GENE_ID", 
            universe = as.character(unique(major.Area[[im]]$ENTREZID)), 
            minGSSize = 4,
            maxGSSize = 500, 
            annotation = "GOTERM_BP_FAT",
            pvalueCutoff = 0.05,
            pAdjustMethod = "BH", 
            qvalueCutoff = 0.2, 
            species = 'org.Hs.eg.db', 
            david.user = 'dannemil@rice.edu')

}

wD <- createWorkbook(type="xlsx")

sheetname <- c('pf_neg',
               'cb_neg',
               'tm_neg',
               'po_neg')

sheet <- list()
sheet[[1]] <- xlsx::createSheet(wD, sheetName = sheetname[1])
sheet[[2]] <- xlsx::createSheet(wD, sheetName = sheetname[2])
sheet[[3]] <- xlsx::createSheet(wD, sheetName = sheetname[3])
sheet[[4]] <- xlsx::createSheet(wD, sheetName = sheetname[4])


for (im in ib)   {

     addDataFrame(as.data.frame(ontol.DAVID.neg[[im]]), 
                                        sheet[[im]], 
                                        startRow=1, 
                                        startColumn=1)
} 

saveWorkbook(wD, "ontology_from500_DAVID.xlsx")

##### End DAVID ontology


# GO:0017156                               calcium ion regulated exocytosis
# These genes were the ones with this GO term
GO0017156.entrez <- c('93664','22930','9581','6860','8618','8867','63908')
GO0017156.Symbols.indx <- match(GO0017156.entrez,hold.Lowest.pvals.neg[[1]]$ENTREZID)
GO0017156.Symbols <- hold.Lowest.pvals.neg[[1]]$Symbol[c(GO0017156.Symbols.indx)]

plotGOgraph(gs1.simp, firstSigNodes = 10,
            useInfo = "all",
            sigForAll = TRUE,
            useFullNames = TRUE)


write.table(GO.ontol.output,file='ontology_neg_of_500_pf_output.txt',
            quote=FALSE,sep=',',eol='\n',row.names=FALSE,col.names=TRUE)



########## end get matching genes to ontology terms

# make a list that holds the ontology term and the genes that were associated with that term


num.ontol <- dim(bp.ontology.results)[1]


# for (k in 1:num.ontol)  {
#      
#    write(print(unlist(ontol.genes[[k]]),rownames=FALSE,quote=FALSE),ncolumns=(7+max.Count),append=TRUE,file=fname_ontology,sep=',')       
# }

ontology.tab <- xtable(bp.ontology.results,
                                caption=c('MF Ontology for the positively correlated genes with the lowest p-values for expression correlations with {\\textit {COMT}}: Pons'),
                                digits=c(0,0,17,2,2,0,0,0))

#} # end sign loop
#} # end area loop

print.xtable(ontology.tab,
             file=,
                         type='latex',
                         floating=FALSE,
                         caption.placement='top',
                         tabular.environment='longtable',
                         caption.width ='0.5\\textwidth',
                         hline.after=c(-1,0,nrow(ontology.tab)),
                         include.rownames=FALSE,
                         print.results=TRUE,
                         booktabs=TRUE,
                         comment=TRUE
                         )


@

The above analyses show that for the most part, ordering the genes by the largest correlation-variancle or z(expression)-variance or by the corresponding coefficients of variation (CV), and doing ontology on the 20 highest ranking genes, produces little significance in almost all areas of ontology.\\

Ranking by these measures would reveal the genes whose correlations or mean expression levels changed the most across brain areas. Thus, these would not necessarily be the genes co-expressed with COMT, but rather those that in some brain areas could have been strongly co-expressed with COMT while in others, those same genes were not or were negatively co-expressed.\\

In contrast, ranking on the correlation coefficient alone (split by sign) tended to produce more significant ontology results.\\


@


<<ontologyIndex>>=
# use ontologyIndex to simplify ontologies
# read in GO ontologies

ontol.file <- paste(getwd(),"/ontology_from500_GOHyperP.xlsx",sep='')
wGO <- loadWorkbook(ontol.file) 

temp.rexcel <- data.frame(read.xlsx(wGO,sheet = 'pf_neg_BP'))

# now tell R to read that workbook and which sheet
  sheetname <- getSheetNames(ontol.file)
  
# read in by sheet   prefront.Data <- data.frame(read.xlsx(wball,sheet = "prefrontal"))
val.range <- c(1:2)
ontol.range <- c(1:3)

# function to cycle through all levels of the derived ontologies with a function passed as an argument

cycle.params <- function(x.area,x.val,x.ontol,num.arg,fun.args,FUN)  {

returnQ <- list()
          
     for (i in x.area)   {
          
          returnQ.val <- list()
          for (j in x.val)   {
               
               returnQ.ontol <- list()
               for (k in x.ontol)  {
                    
                    
                    sheet.indx <- 6*i + 3*j + k - 9
                    returnQ.ontol[[k]] <- data.frame(FUN(fun.args[1],sheet.indx))
                    
               }
               
               returnQ.val[[j]] <- retrunQ.ontol
          }
          
          returnQ[[i]] <- returnQ.val
     }

          return(returnQ)
}

### end function ##########

GO.ontology <- list()  

args.to.FUN <- c(wGO)

  GO.ontology <- cycle.params(ib,val.range,ontol.range,1,args.to.FUN,FUN=read.xlsx)
       
data(go)
ontol.simplified <- list()

for (im in ib)  {
     
     ontol.simplified.val <- list()
     
     for (jk in 1:2)  {
          
          
          ontol.simplified.term <- list()
          
          for (ct in 1:3)  {
              
              if (length(GO.ontology[[im]][[jk]][[ct]]$GOBPID) > 0)  {
                   
                   ontol.complete <- GO.ontology[[im]][[jk]][[ct]]
                   ontol.min <- minimal_set(go,as.character(ontol.complete$GOBPID))
                   ontol.min.indx <- match(ontol.min,ontol.complete$GOBPID)
                   ontol.simplified.term[[ct]] <- ontol.complete[c(ontol.min.indx),]
                   
              } else {
                   ontol.simplified.term[[ct]] <- c('None')
              }
          }
          
          ontol.simplified.val[[jk]] <- ontol.simplified.term
     }
     
     ontol.simplified[[im]] <- ontol.simplified.val
}

### write out simplified ontologies
wGOsimp <- createWorkbook(type="xlsx")

sheetnameBP.neg <- c('pf_neg_BP',
               'cb_neg_BP',
               'tm_neg_BP',
               'po_neg_BP')
               
sheetnameMF.neg <- c('pf_neg_MF',
               'cb_neg_MF',
               'tm_neg_MF',
               'po_neg_MF')
               
sheetnameCC.neg <- c('pf_neg_CC',
               'cb_neg_CC',
               'tm_neg_CC',
               'po_neg_CC')

sheetnameBP.pos <- c('pf_pos_BP',
               'cb_pos_BP',
               'tm_pos_BP',
               'po_pos_BP')
               
sheetnameMF.pos <- c('pf_pos_MF',
               'cb_pos_MF',
               'tm_pos_MF',
               'po_pos_MF')
               
sheetnameCC.pos <- c('pf_pos_CC',
               'cb_pos_CC',
               'tm_pos_CC',
               'po_pos_CC')

sheetnameBP <- list(pos=sheetnameBP.pos,
                     neg=sheetnameBP.neg)

sheetnameMF <- list(pos=sheetnameMF.pos,
                     neg=sheetnameMF.neg)

sheetnameCC <- list(pos=sheetnameCC.pos,
                     neg=sheetnameCC.neg)

sheetname <- list(BP=sheetnameBP,
                  MF=sheetnameMF,
                  CC=sheetnameCC)

sheet <- list()
sheet.temp <- list()
sheet.val <- list()

for (im in ib)   {
     for (kj in 1:2)    {
          for (ct in 1:3)  {
               sheet.temp[[ct]] <- xlsx::createSheet(wGOsimp, sheetName = sheetname[[ct]][[kj]][[im]])
               addDataFrame(as.data.frame(ontol.simplified[[im]][[kj]][[ct]]), 
                                        sheet.temp[[ct]],
                                        startRow=1, 
                                        startColumn=1)
     } 
     
               sheet.val[[kj]] <- sheet.temp
     }
               sheet[[im]] <- sheet.val
}

saveWorkbook(wGOsimp, "ontology_simplified_from500_GOHyperP.xlsx")




@



<<echo=FALSE, include=FALSE, results=tex>>=
print(xtable(coexpress.URL[1,],caption=c('The next co-expression analysis used the database at this URL to find the top 500 genes coexpressed with COMT. That list was then checked against the top 200 genes (+ and - separately) from the comt-prefrontal data to find agreement between the two lists.')))

num.Sel <- c(500)
### read the COMT coexpression data file 

wbhsa <- loadWorkbook('comt_coex_list_500_hsa.xlsx')
# wbhsa2 <- loadWorkbook('comt_coex_list_500_hsa2.xlsx')
# wbhsa3 <- loadWorkbook('comt_coex_list_500_hsa3.xlsx')

coexpress.Data <- data.frame(read.xlsx(wbhsa,         # now tell R to read that workbook and which sheet
                                  sheet = "coex500"))


coexpress.Data$Entrez.Gene.ID <- as.character(coexpress.Data$Entrez.Gene.ID)

neg.match.coexpress.indx <- list()
neg.match.coexpress.indx <- list()
match.coexpress.indx <- list(neg=neg.match.coexpress.indx,
                             neg=neg.match.coexpress.indx)
neg.Matches.genes <- list()
neg.Matches.genes <- list()


     for (im in ib)   {

          neg.match.coexpress.indx[[im]] <- match(lowest.pval.sign[[1]][[im]]$ENTREZID,coexpress.Data$Entrez.Gene.ID)
          neg.match.coexpress.indx[[im]] <- match(lowest.pval.sign[[2]][[im]]$ENTREZID,coexpress.Data$Entrez.Gene.ID)
          
          match.coexpress.indx$neg[[im]] <- neg.match.coexpress.indx[[im]]
          match.coexpress.indx$neg[[im]] <- neg.match.coexpress.indx[[im]]
          neg.Matches.genes[[im]] <- coexpress.Data$Gene[c(na.omit(match.coexpress.indx$neg[[im]]))]
          neg.Matches.genes[[im]] <- coexpress.Data$Gene[c(na.omit(match.coexpress.indx$neg[[im]]))]

     }

neg.match.genes.tab <- list()
neg.match.genes.tab <- list()

negmatch.DF <- list()
negmatch.DF <- list()

for (im in ib)    {
     if (length(neg.Matches.genes[[im]]) > 0) {
          my.symbols <- neg.Matches.genes[[im]]
          my.regions <- getBM(c("hgnc_symbol", "chromosome_name", "start_negition", "end_negition"),
                    filters = c("hgnc_symbol", "chromosome_name"),
                    values = list(hgnc_symbol=my.symbols, chromosome_name=normal.chroms),
                    mart = ensembl)
         
          my.regions$chromosome_name

          negmatch.DF[[im]] <- data.frame(geneSymbol=my.regions$hgnc_symbol,
                                    chromosome=my.regions$chromosome_name)


     } else {negmatch.DF[[im]] <- data.frame(geneSymbol=NA,chromosome=NA)
     }

     neg.match.genes.tab[[im]] <- xtable(negmatch.DF[[im]],caption=c(paste('Genes co-expressed with COMT from ',coexpress.URL[1,2],' matching the top ',num.Sel,' positively COMT - correlated genes in ',stand.Col.names[im],sep='')))

}

# Generate tables for any negatively correlated genes
for (im in ib)    {
     if (length(neg.Matches.genes[[im]]) > 0) {
          my.symbols <- neg.Matches.genes[[im]]
          my.regions <- getBM(c("hgnc_symbol", "chromosome_name", "start_negition", "end_negition"),
                    filters = c("hgnc_symbol", "chromosome_name"),
                    values = list(hgnc_symbol=my.symbols, chromosome_name=normal.chroms),
                    mart = ensembl)
         
          my.regions$chromosome_name

          negmatch.DF[[im]] <- data.frame(geneSymbol=my.regions$hgnc_symbol,
                                    chromosome=my.regions$chromosome_name)


     } else {negmatch.DF[[im]] <- data.frame(geneSymbol=NA,chromosome=NA)
     }

     neg.match.genes.tab[[im]] <- xtable(negmatch.DF[[im]],caption=c(paste('Genes co-expressed with COMT from ',coexpress.URL[1,2],' matching the top ',num.Sel,' negatively COMT - correlated genes in ',stand.Col.names[im],sep='')))

}

@

<<overrep.chr.22>>=

# Check on whether genes on Chromosome 22 (COMT location) aree overrepresented among the genes overlapping the COMT-co-expressed genes from COXPRESdb http://coxpresdb.jp/

# get proportion of Chr 22 genes in the top 500 in each brain area for the positively correlated genes
chr22.propor.COXPRES <- data.frame(xnum=rep(NA,4),
                               nnum=rep(NA,4))

chr22.propor.500 <- unlist(lapply(hold.Lowest.pvals[ib], function(x,ib) (dim(subset(x,
                x$loc == '22' & x$corsign == 1))[1])/(dim(subset(x,x$corsign == 1))[1]), ib))

chr22.propor.COXPRES[,1] <- unlist(lapply(negmatch.DF[ib], function(x,ib) (dim(subset(x,
                x$chromosome == '22'))[1]), ib))
chr22.propor.COXPRES[,2] <- unlist(lapply(negmatch.DF[ib], function(x,ib) (length(x$chromosome)), ib))

binom.chr22.enrich <- list()

# Note: confidence level has been Bonferroni corrected .05/4 = 0.0125
for (im in ib)   {

     binom.chr22.enrich[[im]] <- binom.test(chr22.propor.COXPRES[im,1], chr22.propor.COXPRES[im,2], 
           p = chr22.propor.500[im],alternative = c("greater"),conf.level = (1-.05/4))

}

writeLines(binom.chr22.enrich,con='chr22_enrichment_genes_500_and_COXPRESdb.txt',sep='\n')

lapply(binom.chr22.enrich, write,'chr22_enrichment_genes_500_and_COXPRESdb.txt', append=TRUE,
       ncolumns=1000)

sink('chr22_enrichment_genes_500_and_COXPRESdb.txt')
print(binom.chr22.enrich)
sink()

@

The proportion of the 500 most strongly positively correlated genes (from the NIH data set) that were located on Chromosome 22 (COMT location) and that overlapped with the 500 most strongly co-expressed genes from COXPRESdb http://coxpresdb.jp/ was significantly greater in all brain areas except pons than the overall proportion of the top 500 positively correlated genes from the NIH data set that were located on Chromosome 22 (note: this latter set did not include the requirement that they overlap with the COXPRESdb genes). In other words, genes for which there were two sources of positive COMT-coexpression evidence (NIH data and COXPRESdb data) were enriched on Chromosome 22. This could be an indication of sharing transcription factors.


<< results=tex>>=
# use the web interface at http://amp.pharm.mssm.edu/Enrichr/enrich to do various kinds of ontology on the top (+) and bottom (-) of the <area-abbrev>.Data.onegene correlation-ranked data.


# first, verify that prefront.Data.onegene is ordered by Sample.r (this only verifies that the
# max(r) and min(r) are at the top and bottom of the ranked data)
check.Order <- as.vector(c(rep(NA,8)))

for (vi in seq(1,7,2))   {

 if(max(area.onegene.List[[vi]]$Sample.r) != area.onegene.List[[vi]]$Sample.r[1])  {
      
      check.Order[vi] <- FALSE
      
 }  else if (max(area.onegene.List[[vi]]$Sample.r) == area.onegene.List[[vi]]$Sample.r[1]) {
      
      check.Order[vi] <- TRUE
 }  else {
      
 }

# negative
# Check ordering at bottom of data

  if(min(area.onegene.List[[vi]]$Sample.r) != area.onegene.List[[vi]]$Sample.r[length(area.onegene.List[[vi]]$Sample.r)])  {
      
      check.Order[vi + 1] <- FALSE
      
 }  else if (min(area.onegene.List[[vi]]$Sample.r) == area.onegene.List[[vi]]$Sample.r[length(area.onegene.List[[vi]]$Sample.r)]) {
      
      check.Order[vi + 1] <- TRUE
 }  else {
      
 }
     
} # end combined brain area and sign loop

check.Order

num.Ont <- c(50)

symbols.top.bottom.50 <- data.frame(pfneg=rep(0,num.Ont),
                                    pfneg=rep(0,num.Ont),
                                    cbneg=rep(0,num.Ont),
                                    cbneg=rep(0,num.Ont),
                                    tmneg=rep(0,num.Ont),
                                    tmneg=rep(0,num.Ont),
                                    poneg=rep(0,num.Ont),
                                    poneg=rep(0,num.Ont))

# my.mod <-function(x,m)
#   {
#     return(m - (x %% m))
#   }

for (v in seq(1,7,2))   {
     for (w in 1:2)   {
          
          lims.Ont <- matrix(c(1,
                             num.Ont,
                             length(area.onegene.List[[(v+(w-1))]]$Sample.r),
                             (length(area.onegene.List[[(v+(w-1))]]$Sample.r) - num.Ont + 1)),
                             ncol=2,byrow=TRUE)
     
symbols.top.bottom.50[1:num.Ont,(v+(w-1))] <- noquote(area.onegene.List[[(v+(w-1))]]$Symbol[lims.Ont[w,1]:lims.Ont[w,2]])

     } # end sign loop
} # end brain area loop

@

<< >>=
######### ******** Enrichr ontology ********* #############

dbs.negs <- listEnrichrDbs()

dbs.up <- c('GTEx_Tissue_Sample_Gene_Expression_Profiles_up')
dbs.down <- c('GTEx_Tissue_Sample_Gene_Expression_Profiles_down')

#enriched <- enrichr(as.character(symbols.top.bottom.50$pfneg), dbs)
enriched <- enrichr(as.character(pf.specific.up$pf.a[1:50]), dbs.down)

enriched[['GTEx_Tissue_Sample_Gene_Expression_Profiles_down']][1:40,]





@


\end{document}


 
