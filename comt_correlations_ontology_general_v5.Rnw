% NEW based on MB-COMT data

\documentclass[11pt]{article}
\usepackage{graphicx, subfig}
\usepackage{float}
\pagenumbering{arabic}
\usepackage{enumerate}
\usepackage{Sweave}
\usepackage{booktabs}
\usepackage[table]{xcolor}
\usepackage{framed}
\usepackage{longtable}
\usepackage{tablefootnote}
\usepackage{amsmath}
\usepackage{hyperref}


\begin{document}
\SweaveOpts{concordance=TRUE}
\SweaveOpts{keep.source=TRUE} 

\hspace{-1.5em}Gene Network\\
COMT expression correlations in Four Bartin Areas\\
Fall, 2017\\


<<echo=FALSE>>=
#biocLite('enrichR')
library('enrichR')
dbs.Enrichr <- listEnrichrDbs()

library(ggplot2,ggthemes)
library(ggExtra)
library(psych)
library(knitr)
library(Hmisc)
library(openxlsx)
library(xtable)
#library(magrittr)
library(tables)
library(plyr)
library(rlist)
# library(qqman)
# library(manhattanly)
library(Cairo)
library(RColorBrewer)
library(HGNChelper)
library(tools)
library(scales)
library(devtools)
library(utils)
# library(ggman)
library(dplyr)
library(biomaRt)
library(combinat)
library(Rmpfr)
library(stats)
library(stringr)
library(mvtnorm)
library(miscFuncs)
library(reporttools)
library(glm2)
library(reshape2)
library(plotly)
library(gmp)
library(R.utils)
library(curl)
library(igraph)
library(data.tree)
library(gmodels)



### to prepend filename strings to plots
#pre.Name <- c('comt_expression-') #pre-ppended to eps output files

setwd('/Volumes/Macintosh_HD_3/genetics/genenetwork2/')

# RColorBrewer palette
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/squareAxes.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork/histChrfunc.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork/onlycisChr.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork/hypergeom_plot.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/countNA.R') # function num.NA()
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/func_get_match_length.R') #len.match()
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/func.chrom.names.R') # extract Chr names
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/func_get_start_pos.R') # extract and scale start positions
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/commaSep.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/func_myBioCLite.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/nums2genes.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/func_genes_are_nums.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/func_genes_are_locs.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/func_genes2chr.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/func_anyY.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/func_gene_start_end.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/raincloudPlots.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/func_chisq_genesBychr.R')
source('/Volumes/Macintosh_HD_3/genetics/genenetwork2/func_mismatch_hgnc.R')


stand.Col.names <- c('Prefrontal',
                     'Cerebellum',
                     'Temporal',
                     'Pons')
gold.R <- c(1.61803398875)
@

<<include=FALSE, echo=FALSE, results=hide>>=
# Generate a unique ID for this program by path and filename. This unique ID is attached to this file using a tag in the filesystem.
source('unique_id_generator.R')

fname <- c("/Volumes/Macintosh_HD_3/genetics/genenetwork2/comt_correlations_ontology_general_v5.Rnw")

prog.Name <- unique.ID(fname)

prog.Name

reread.Data <- c(TRUE)   # FALSE   # True means load again

sUs <- c(TRUE)  # Applies to biocLite installations sUs = suppress Update status
sAUs <- c(TRUE)  # Applies to biocLite installations sAUs = suppress Auto Update status
@

This program has the unique ID: \Sexpr{prog.Name}.

<<include=FALSE,echo=FALSE,results=hide>>=

# install_github("wjawaid/enrichR")
# library('enrichR')


# install_github("kassambara/easyGgplot2")
# library(easyGgplot2)

# myBioCLite() # This function updates only the packages that need to be updated

#biocLite('topGO')
#libary('topGO')

source("https://bioconductor.org/biocLite.R")
# if (reread.Data) {
#   biocLite(c("GenomicFeatures"),suppressUpdates=sUs, suppressAutoUpdate=sAUs)   
#   biocLite(c("AnnotationDbi"),suppressUpdates=sUs, suppressAutoUpdate=sAUs)   
#   biocLite(c("org.Hs.eg.db"),suppressUpdates=sUs, suppressAutoUpdate=sAUs)   
# }

library("AnnotationHub")
library("GenomicFeatures")
library("org.Hs.eg.db")

#biocLite('TCGAbiolinks')
#library('TCGAbiolinks')


# if (reread.Data) {
#      biocLite(c('hgu95av2.db'),suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }

library('hgu95av2.db')

# if (reread.Data) {
#      biocLite("illuminaHumanv4.db",suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }

# library("illuminaHumanv4.db")

source("https://bioconductor.org/workflows.R")

# if (reread.Data) {
#  workflowInstall("annotation")   
# }

# if (reread.Data) {
#  biocLite("TxDb.Hsapiens.UCSC.hg19.knownGene",suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }

library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene #shorthand (for convenience)   

# if (reread.Data) {
# biocLite("GO.db",suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }
# 
# if (reread.Data) {
# biocLite("topGO",suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }     
# 
# if (reread.Data) {
# biocLite("GOstats",suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# } 
     
library("GO.db")
# library("topGO")
library("GOstats")

# if (reread.Data) {
#      biocLite('EDASeq',suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }

# library('EDASeq')

# if (reread.Data) {
#      biocLite('lumi',suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }

# library(lumi)

# if (reread.Data) {
#      biocLite('lumiHumanIDMapping',suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }

# library(lumiHumanIDMapping)
# 
# # if(reread.Data) {
# #      biocLite('lumiHumanAll.db',suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# # }
# 
# library('lumiHumanAll.db')

# if(reread.Data) {
#      biocLite('rBLAST',suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }

# library(rBLAST)


#      biocLite (c( "beadarray" , "limma" , "GEOquery" , "illuminaHumanv2.db"),
#                suppressUpdates=sUs, suppressAutoUpdate=sAUs)
library(limma)
# 
# if (reread.Data) {
#      biocLite('annotate',suppressUpdates=sUs, suppressAutoUpdate=sAUs)
# }

#  if (reread.Data) {
# #      biocLite("GEOquery",suppressUpdates=sUs, suppressAutoUpdate=sAUs)
#  }

library('annotate')

# library("illuminaHumanv2.db")
# library("beadarray","limma")

options(scipen = 999, digits = 5, width = 60, knitr.table.format = "latex")
opts_chunk$set(include=FALSE,
               echo=FALSE,
               message=FALSE,
               warning=FALSE)
@



{\textit {COMT}} catalyzes degradation of catecholamines including dopamine, norepinephrine and epinephrine.\\ 
<<echo=FALSE, include=FALSE, results=tex>>=
coexpress.URL <- data.frame(site=NA,addr=NA)
coexpress.URL[1,1:2] <- c('COXPRESdb','http://coxpresdb.jp/')
coexpress.URL[2,1:2] <- c('OMICtools','https://omictools.com/')
coexpress.URL[3,1:2] <- c('Coexpedia','http://www.coexpedia.org/search.php')
coexpress.URL[4,1:2] <- c('GeneFriends','http://www.genefriends.org/RNAseq/')
coexpress.URL[5,1:2] <- c('Illumina Probes','http://www.genomequebec.mcgill.ca/compgen/integratedvervetgenomics/transcriptome/Illumina/allprobes.html')
coexpress.URL[6,1:2] <- c('Gibbs Expression Data','https://www.ncbi.nlm.nih.gov/geo/query')
coexpress.URL[7,1:2] <- c('Train Online','https://www.ebi.ac.uk/training/online/course/arrayexpressdiscoverfunctionalgenomicsdataqui/references')
coexpress.URL[8,1:2] <- c('Enrichr','http://amp.pharm.mssm.edu/Enrichr/enrich')

url.Tab <- xtable(coexpress.URL)
url.Table <- latex(url.Tab,file='',
                   caption = c("Gene Coexpression Databases"),
                   caption.loc = c('top'),
                     colname = c('Name','URL'),
                     rowlabel = c(''),
                     colnamesTexCmd="bfseries",
                     booktabs=TRUE,
                     label=c('tabcoexpressurls'),
                     na.blank = TRUE,
                     vbar = FALSE,
                     longtable=TRUE,
                     table.env=TRUE,
                     center=c('center'),
                     continued=c('Gene Coexpression Databases Continued'),
                     first.hline.double = TRUE,
                     append=FALSE
                     )

@


\Sexpr{url.Table}

<<echo=FALSE, results=tex>>=
entrez_object <- org.Hs.egGO    



ensembl <- useMart("ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl")
#ensembl = useEnsembl(biomart="ensembl",dataset = "hsapiens_gene_ensembl")



normal.chroms <- c(1:22, "X", "Y", "M")

 ah <- AnnotationHub()



 orgs <- AnnotationHub::query(ah, "org.Hs.eg.db")



 gene.DB <- orgs[["AH57973"]]


# columns(gene.DB)
# keytypes(gene.DB)


############################################################################
## Bimap interface:
x <- org.Hs.egCHR
# Get the entrez gene identifiers that are mapped to a chromosome
mapped_genes <- mappedkeys(x)
# Convert to a list
xx <- as.list(x[mapped_genes])

@



<<echo=FALSE,include=FALSE,results=hide>>=
### read the data file 


wball <- loadWorkbook('comt_correlations_20000_all_areas_augmentedNew.xlsx')   

# now tell R to read that workbook and which sheet
  prefront.Data <- data.frame(read.xlsx(wball,sheet = "prefrontal"))
  
  cbell.Data <- data.frame(read.xlsx(wball,sheet = "cerebellum"))

  tempor.Data <- data.frame(read.xlsx(wball,sheet = "temporal"))

  pons.Data <- data.frame(read.xlsx(wball,sheet = "pons"))

     

# Get corrected start positions for all genes

# pf.starts <- getBM(attributes = c("illumina_humanref_8_v3", "hgnc_symbol",
#                                          "chromosome_name", "start_position","end_position",
#                                          "entrezgene"), filters = "illumina_humanref_8_v3", 
#                           values = as.character(prefront.Data$Record), mart = ensembl)


chrom.Names <- c(as.character(seq(1,22,1)),'X','Y')

# Use the hgu95av2.db and the hgu95av2CHRLENGTHS data to get the chromosome lengths

yy <- hgu95av2CHRLENGTHS
chrom.Data <- data.frame(chrom=chrom.Names,
                         chrom.Length=yy[chrom.Names]
)

# Some of the gene Symbols have a period in them because they originally had '-' but that caused problems. Need to reinsert the '-' symbol, but have to escape it.

# period.Indx.pf <- grep('\\.',prefront.Data$Symbol)
# prefront.Data$Symbol[c(period.Indx.pf)] <- gsub('\\.','\\-',prefront.Data$Symbol[period.Indx.pf])
# 
# period.Indx.cb <- grep('\\.',cbell.Data$Symbol)
# cbell.Data$Symbol[c(period.Indx.cb)] <- gsub('\\.','\\-',cbell.Data$Symbol[period.Indx.cb])
# 
# period.Indx.tm <- grep('\\.',tempor.Data$Symbol)
# tempor.Data$Symbol[c(period.Indx.tm)] <- gsub('\\.','\\-',tempor.Data$Symbol[period.Indx.tm])
# 
# period.Indx.po <- grep('\\.',pons.Data$Symbol)
# pons.Data$Symbol[c(period.Indx.po)] <- gsub('\\.','\\-',pons.Data$Symbol[period.Indx.po])

### Note to convert r correlations into p values use these transformations
### store the results in a column in the original data frame - without the print statements
# example: r = 0.809, n = 138
# r.test(n = , r12 = )
# out.t <- r.test(n = 138, r12 = 0.809)
# print(out.t$t,digits=10)
# [1] 16.05025766
# pval <- 2*pt(-abs(t),df=n-2)
# pval <- 2*pt(-abs(print(out.t$t,digits=20)),df=136)
# print(pval,digits=10)

@

<< >>=
# Some gene Symbols use upper case XXORFYY and some use lower case XXorfYY. It should be lower case.
# Replace ORF with orf when it is meant to indicate open reading frame because official symbols use
# 'orf'.

# Done March 20, 2018 and wrote out new data files
# prefront.Data$Symbol <- sub('ORF','orf',prefront.Data$Symbol,ignore.case=FALSE)
# cbell.Data$Symbol <- sub('ORF','orf',cbell.Data$Symbol,ignore.case=FALSE)
# tempor.Data$Symbol <- sub('ORF','orf',tempor.Data$Symbol,ignore.case=FALSE)
# pons.Data$Symbol <- sub('ORF','orf',pons.Data$Symbol,ignore.case=FALSE)

@ 


<<include=FALSE, echo=FALSE, results=hide>>=
# There are many rows that have missing ENTREZIDs
# Use the gene SYMBOL to try to get the ENTREZIDs

########### Prefrontal
# no.Entrez.pf.indx <- which(is.na(prefront.Data$ENTREZID))
# no.Entrez.pf.Symbol <- prefront.Data$Symbol[c(no.Entrez.pf.indx)]
# recovered.Entrez.pf <- biomaRt::select(gene.DB,keys=as.character(no.Entrez.pf.Symbol),columns=c('GENENAME','SYMBOL','ENTREZID'),keytype=c('SYMBOL'))
# prefront.Data$ENTREZID[c(no.Entrez.pf.indx)] <- recovered.Entrez.pf$ENTREZID
# Get the indices in the four data frames of the rows where the gene Symbols begin with LOC
     # indx.genes.Are.locs <- genes.Are.locs(prefront.Data$Symbol)
     # no.symbol.pf.entrez <- prefront.Data$ENTREZID[c(indx.genes.Are.locs)]
     # recovered.Symbols.pf <- biomaRt::select(gene.DB,keys=as.character(no.symbol.pf.entrez),columns=c('GENENAME','SYMBOL','ENTREZID'),keytype=c('ENTREZID'))
     # prefront.Data$Symbol[c(indx.genes.Are.locs)] <- recovered.Symbols.pf$SYMBOL


###########

########### Cerebellum
# no.Entrez.cb.indx <- which(is.na(cbell.Data$ENTREZID))
# no.Entrez.cb.Symbol <- cbell.Data$Symbol[c(no.Entrez.cb.indx)]
# recovered.Entrez.cb <- biomaRt::select(gene.DB,keys=as.character(no.Entrez.cb.Symbol),columns=c('GENENAME','SYMBOL','ENTREZID'),keytype=c('SYMBOL'))
# cbell.Data$ENTREZID[c(no.Entrez.cb.indx)] <- recovered.Entrez.cb$ENTREZID
     # indx.genes.Are.locs <- genes.Are.locs(cbell.Data$Symbol)
     # no.symbol.cb.entrez <- cbell.Data$ENTREZID[c(indx.genes.Are.locs)]
     # recovered.Symbols.cb <- biomaRt::select(gene.DB,keys=as.character(no.symbol.cb.entrez),columns=c('GENENAME','SYMBOL','ENTREZID'),keytype=c('ENTREZID'))
     # cbell.Data$Symbol[c(indx.genes.Are.locs)] <- recovered.Symbols.cb$SYMBOL
###########

########### Temporal
# no.Entrez.tm.indx <- which(is.na(tempor.Data$ENTREZID))
# no.Entrez.tm.Symbol <- cbell.Data$Symbol[c(no.Entrez.tm.indx)]
# recovered.Entrez.tm <- biomaRt::select(gene.DB,keys=as.character(no.Entrez.tm.Symbol),columns=c('GENENAME','SYMBOL','ENTREZID'),keytype=c('SYMBOL'))
# tempor.Data$ENTREZID[c(no.Entrez.tm.indx)] <- recovered.Entrez.tm$ENTREZID
     # indx.genes.Are.locs <- genes.Are.locs(tempor.Data$Symbol)
     # no.symbol.tm.entrez <- tempor.Data$ENTREZID[c(indx.genes.Are.locs)]
     # recovered.Symbols.tm <- biomaRt::select(gene.DB,keys=as.character(no.symbol.tm.entrez),columns=c('GENENAME','SYMBOL','ENTREZID'),keytype=c('ENTREZID'))
     # tempor.Data$Symbol[c(indx.genes.Are.locs)] <- recovered.Symbols.tm$SYMBOL
###########

########### Pons
# no.Entrez.po.indx <- which(is.na(pons.Data$ENTREZID))
# no.Entrez.po.Symbol <- pons.Data$Symbol[c(no.Entrez.po.indx)]
# recovered.Entrez.po <- biomaRt::select(gene.DB,keys=as.character(no.Entrez.po.Symbol),columns=c('GENENAME','SYMBOL','ENTREZID'),keytype=c('SYMBOL'))
# pons.Data$ENTREZID[c(no.Entrez.po.indx)] <- recovered.Entrez.po$ENTREZID
     # indx.genes.Are.locs <- genes.Are.locs(pons.Data$Symbol)
     # no.symbol.po.entrez <- pons.Data$ENTREZID[c(indx.genes.Are.locs)]
     # recovered.Symbols.po <- biomaRt::select(gene.DB,keys=as.character(no.symbol.po.entrez),columns=c('GENENAME','SYMBOL','ENTREZID'),keytype=c('ENTREZID'))
     # pons.Data$Symbol[c(indx.genes.Are.locs)] <- recovered.Symbols.po$SYMBOL
###########


@


<<include=FALSE,echo=FALSE,results=hide>>=
# Some of the gene names (Symbols) are just numbers because Excel converted gene names such as MARCH1 into dates then into the integers represneting those dates. Find the numbers, and using the associated ENTREZID, get the correct gene name, then write out the files as discussed below so that they can be imported into Excel with the Symbol column set to text to prevent this error in Excel.

############ Prefrontal
# Get the indices in the four data frames of the rows where the gene Symbols are numbers
     # indx.genes.Are.nums <- genes.Are.nums(prefront.Data$Symbol)
# 
# # Now get the correct gene Symbols for those numbers
     # prefront.Data$Symbol[c(indx.genes.Are.nums)] <- nums2genes(prefront.Data,indx.genes.Are.nums)


gene.Symbol.table.pf <- as.data.frame(table(prefront.Data$Symbol))
# 
# ############ Cerebellum
# # Get the indices in the four data frames of the rows where the gene Symbols are numbers
     # indx.genes.Are.nums <- genes.Are.nums(cbell.Data$Symbol)
# 
# # Now get the correct gene Symbols for those numbers
     # cbell.Data$Symbol[c(indx.genes.Are.nums)] <- nums2genes(cbell.Data,indx.genes.Are.nums)

gene.Symbol.table.cb <- as.data.frame(table(cbell.Data$Symbol))
# 
# ############ Temporal
# # Get the indices in the four data frames of the rows where the gene Symbols are numbers
     # indx.genes.Are.nums <- genes.Are.nums(tempor.Data$Symbol)
# 
# # Now get the correct gene Symbols for those numbers
     # tempor.Data$Symbol[c(indx.genes.Are.nums)] <- nums2genes(tempor.Data,indx.genes.Are.nums)

# Get the indices in the four data frames of the rows where the gene Symbols begin with LOC

gene.Symbol.table.tm <- as.data.frame(table(tempor.Data$Symbol))
# 
# ############ Pons
# # Get the indices in the four data frames of the rows where the gene Symbols are numbers
     # indx.genes.Are.nums <- genes.Are.nums(pons.Data$Symbol)
# 
# # Now get the correct gene Symbols for those numbers
     # pons.Data$Symbol[c(indx.genes.Are.nums)] <- nums2genes(pons.Data,indx.genes.Are.nums)

# Get the indices in the four data frames of the rows where the gene Symbols begin with LOC

gene.Symbol.table.po <- as.data.frame(table(pons.Data$Symbol))

############ End nums2genes #################################
@

<< >>=
# Some of the gene symbols have 2 genes separated by  ' /// '. Split and use the first one 

#### Done March 20, 2018 and wrote out to files.
# for (k in 1:20000) {
#      prefront.Data$Symbol[k] <- strsplit(prefront.Data$Symbol[k],' /// ')[[1]][1]
#      cbell.Data$Symbol[k] <- strsplit(cbell.Data$Symbol[k],' /// ')[[1]][1]
#      tempor.Data$Symbol[k] <- strsplit(tempor.Data$Symbol[k],' /// ')[[1]][1]
#      pons.Data$Symbol[k] <- strsplit(pons.Data$Symbol[k],' /// ')[[1]][1]
# }

# write to files

# Using the extension, .txt, allows these to be imported into excel so that the column with gene Symbols can be set to text, preventing Excel from converting gene Symbols like MARCH1 to date format.
# write.csv(prefront.Data,"/Volumes/Macintosh_HD_3/genetics/genenetwork2/comt_correlations_20000_prefrontal_augmentedNew.csv.txt",row.names=FALSE)
# # #
# write.csv(cbell.Data,"/Volumes/Macintosh_HD_3/genetics/genenetwork2/comt_correlations_20000_cerebellum_augmentedNew.csv.txt",row.names=FALSE)
# # #
# write.csv(tempor.Data,"/Volumes/Macintosh_HD_3/genetics/genenetwork2/comt_correlations_20000_temporal_augmentedNew.csv.txt",row.names=FALSE)
# # #
# write.csv(pons.Data,"/Volumes/Macintosh_HD_3/genetics/genenetwork2/comt_correlations_20000_pons_augmentedNew.csv.txt",row.names=FALSE)

@

<< >>=
# Counts of missing data NOTE: These were subtracted from 20000 so the counts are actually complete
# data
missing.Data <- data.frame(PfCtx = rep(NA,10),
                           Cbell = rep(NA,10),
                           TmpCtx = rep(NA,10),
                           Pons = rep(NA,10)
                           )
row.names(missing.Data) <- c('Complete:',
                              'Symbol',
                             'ChrNum',
                             'Sample.r',
                             'ENTREZID',
                              'Missing:',
                              'mSymbol',
                             'mChrNum',
                             'mSample.r',
                             'mENTREZID')

missing.Data[1,1:4] <- c(rep('',4))

missing.Data[2,1:4] <- 20000 - c(sum(is.na(prefront.Data$Symbol)),
                          sum(is.na(cbell.Data$Symbol)),
                          sum(is.na(tempor.Data$Symbol)),
                          sum(is.na(pons.Data$Symbol))
                          )

missing.Data[3,1:4] <- 20000 - c(sum(is.na(prefront.Data$loc)),
                          sum(is.na(cbell.Data$loc)),
                          sum(is.na(tempor.Data$loc)),
                          sum(is.na(pons.Data$loc))
                          )
missing.Data[4,1:4] <- 20000 - c(sum(is.na(prefront.Data$Sample.r)),
                          sum(is.na(cbell.Data$Sample.r)),
                          sum(is.na(tempor.Data$Sample.r)),
                          sum(is.na(pons.Data$Sample.r))
                          )
missing.Data[5,1:4] <- 20000 - c(sum(is.na(prefront.Data$ENTREZID)),
                          sum(is.na(cbell.Data$ENTREZID)),
                          sum(is.na(tempor.Data$ENTREZID)),
                          sum(is.na(pons.Data$ENTREZID))
                          )

missing.Data[6,1:4] <- c(rep('',4))

missing.Data[7,1:4] <- c(sum(is.na(prefront.Data$Symbol)),
                          sum(is.na(cbell.Data$Symbol)),
                          sum(is.na(tempor.Data$Symbol)),
                          sum(is.na(pons.Data$Symbol))
                          )

missing.Data[8,1:4] <- c(sum(is.na(prefront.Data$loc)),
                          sum(is.na(cbell.Data$loc)),
                          sum(is.na(tempor.Data$loc)),
                          sum(is.na(pons.Data$loc))
                          )
missing.Data[9,1:4] <- c(sum(is.na(prefront.Data$Sample.r)),
                          sum(is.na(cbell.Data$Sample.r)),
                          sum(is.na(tempor.Data$Sample.r)),
                          sum(is.na(pons.Data$Sample.r))
                          )
missing.Data[10,1:4] <- c(sum(is.na(prefront.Data$ENTREZID)),
                          sum(is.na(cbell.Data$ENTREZID)),
                          sum(is.na(tempor.Data$ENTREZID)),
                          sum(is.na(pons.Data$ENTREZID))
                          )

missing.Counts.tab <- xtable(missing.Data,
                             caption=c('Complete and missing data counts in each brain area on four measures per probe. The maximum count for any variable is 20,000.'))

@

The file missing_data_table.pdf show how many pieces of data are missing from each brain area on the variables: Gene Symbol, Chromosome, correlation, and ENTREZID.

<< >>=
# Need to determine for the mismatches whether one or both of the gene symbols are aliases

# The alias2SymbolTable function when given a gene alias, returns the official gene symbol if it has it in its database. If it is given an official gene symbol, it just returns that.
#mismatch.Set.pf <- subset(hold.Symb.mismatches[[1]],hold.Symb.mismatches[[1]]$X2 == 'mismatch')

# Just directly replace gene aliases with hgnc gene symbols in all four of the dataframes

early.area.List <- list()

early.area.List <- list(pf=prefront.Data,
                         cb=cbell.Data,
                         tm=tempor.Data,
                         po=pons.Data
)


for (h in 1:4)    {

     temp.geneSymb <- alias2SymbolTable(c(early.area.List[[h]]$Symbol),species = "Hs")

for (l in 1:dim(early.area.List[[h]])[1])   {
     
     if (!is.na(temp.geneSymb[l]))  {   # don't replace it if alias2Symbol returned NA
          
          early.area.List[[h]]$Symbol[l] <- temp.geneSymb[l]
          
     } else {}
     
}
     
} # end brain area loop


prefront.Data$Symbol <- early.area.List[[1]]$Symbol
cbell.Data$Symbol <- early.area.List[[2]]$Symbol
tempor.Data$Symbol <- early.area.List[[3]]$Symbol
pons.Data$Symbol <- early.area.List[[4]]$Symbol

# Now check again for mismatches in Symbol when ENTREZIDs match

@


<< >>=
# tempor.Data$Symbol is only missing 15/20,000 gene names. Use this to try to recover the missing gene names in the other three brain areas. Use the Illumina probe ID because that is most complete.

# First check the tempor.Data for agreement with the other areas on other available variables.

# Match on ENTREZID, then check other variables for matches
entrez.pftm.match <- match(prefront.Data$ENTREZID,tempor.Data$ENTREZID)
entrez.cbtm.match <- match(cbell.Data$ENTREZID,tempor.Data$ENTREZID)
entrez.potm.match <- match(pons.Data$ENTREZID,tempor.Data$ENTREZID)

num.match <- matrix(rep(0,3),nrow=3)
num.match[1:3] <- c(sum(!is.na(entrez.pftm.match)),  # 18476 
                    sum(!is.na(entrez.cbtm.match)),  # 18216
                    sum(!is.na(entrez.potm.match))  # 18220
                    )


early.area.List.tmLast <- list()

early.area.List.tmLast <- list(pf=prefront.Data,
                         cb=cbell.Data,
                         po=pons.Data,
                         tm=tempor.Data)

entrez.match.List <- list()
entrez.match.List <- list(entrez.pftm.match,
                       entrez.cbtm.match,
                       entrez.potm.match)


# mismatches with tempor.Data$Symbol

hold.Symb.mismatches <- list()

# calls function to do the matching and checking
for (j in 1:3)    {
     
     hold.Symb.mismatches[[j]] <- mismatch.hgnc(early.area.List.tmLast[[j]],
                                           tempor.Data,
                                           entrez.match.List[[j]])
}

temp.Temporal <- tempor.Data[order(tempor.Data$Symbol),]
check.tm.entrez.indx <- match(temp.entrez[,1],temp.Temporal$Symbol)
length(which(temp.Temporal$ENTREZID[check.tm.entrez.indx] != temp.entrez[,2]))


     

@





<< >>=
hold.rs <- data.frame(pf = prefront.Data$Sample.r,
                      cb = cbell.Data$Sample.r,
                      tm = tempor.Data$Sample.r,
                      po = pons.Data$Sample.r)

r.pca <- prcomp(hold.rs,
                 center = TRUE,
                 scale. = TRUE) 

print(r.pca)
plot(r.pca,type = 'l')

summary(r.pca)

library(devtools)
install_github("ggbiplot", "vqv")
 
library(ggbiplot)
g <- ggbiplot(r.pca, obs.scale = 1, var.scale = 1, 
              ellipse = FALSE, 
              circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal', 
               legend.position = 'top')
print(g)




# Work on the gene symbols
miss.match.pf <- data.frame(pfmiss=rep(NA,missing.Data[7,1]),
                            tm.match=rep(NA,missing.Data[7,1]))
     
miss.match.pf[,1]  <-   which(is.na(prefront.Data$Symbol))

miss.match.pf[,2] <- match(prefront.Data$Record[c(miss.pf.indx)],tempor.Data$Record)

#prefront.Data$Symbol[c(miss.pf.indx)] <- tempor.Data$Symbol[c(match.pf.tm.indx)]


@



<<include=FALSE, echo=FALSE, results=hide>>=
#Because some genes have more than one illumina probe, that gives them an advantage in apriori probability terms of ending up in the top (or bottom) 50 or 200 correlated genes. One solution is to use the correlation that corresponds to the maximum expression level for each gene that has more than one probe. Note, the maximum expression levels of both the set of positively correlated probes and the set of negatively correlated probes should be used. There will be a maximum for the + correlations and a maximum for the - correlations (assuming that the complete set of probes has probes that have both + and - correlations with COMT.

max.probes <- max(max(as.numeric(as.data.frame(table(gene.Symbol.table.pf[,2]))[,1])),
    max(as.numeric(as.data.frame(table(gene.Symbol.table.cb[,2]))[,1])),
    max(as.numeric(as.data.frame(table(gene.Symbol.table.tm[,2]))[,1])),
    max(as.numeric(as.data.frame(table(gene.Symbol.table.po[,2]))[,1])))

probecount.List <- list()

probecount.List[[1]] <- as.data.frame(table(gene.Symbol.table.pf[,2]))
probecount.List[[2]] <- as.data.frame(table(gene.Symbol.table.cb[,2]))
probecount.List[[3]] <- as.data.frame(table(gene.Symbol.table.tm[,2]))
probecount.List[[4]] <- as.data.frame(table(gene.Symbol.table.po[,2]))

for (j in 1:4) {
if (dim(probecount.List[[j]])[1] < (max.probes+1)) {
     diff.probe <- max.probes - dim(probecount.List[[j]])[1] + 1
     
          probecount.tmp <- data.frame(np=seq(1,(dim(probecount.List[[j]])[1]+diff.probe),1),
                                   probe.count=rep(0,dim(probecount.List[[j]])[1]+diff.probe))
          probecount.tmp[,2] <- c(probecount.List[[j]][,2],rep(0,diff.probe))
          probecount <- probecount.tmp
          probecount[dim(probecount)[1],2] <- sum(probecount[,2])
          probecount[,1] <- c(seq(1,(dim(probecount)[1]-1),1),'Total')
          probecount.List[[j]] <- probecount
          
} else {}

}

tab.probe.counts <- data.frame('Number of Probes' = probecount.List[[1]][,1],
                               PfCx = probecount.List[[1]][,2],
                               Cereb = probecount.List[[2]][,2],
                               TmpCx = probecount.List[[3]][,2],
                               Pons = probecount.List[[4]][,2])

@

<<include=FALSE,echo=FALSE,results=hide>>=
# Plot the distribution of probes per gene for each area

stacked.data.Form <- stack(tab.probe.counts[1:8,])
stacked.data.Form[,3] <- c(rep(seq(1,8,1),4))
stacked.data.Form[,4] <- sqrt(stacked.data.Form[,1])
colnames(stacked.data.Form) <- c('Frequency','Area','ProbesPerGene','SqrtCount')

area_names <- c('PfCx' = "Prefrontal Cortex",
                    'Cereb' = "Cerebellum",
                    'TmpCx' = "Temporal Cerebral Wall",
                    'Pons' = "Pons"
                    )

p <- ggplot(stacked.data.Form, aes(ProbesPerGene,SqrtCount)) + geom_bar(stat='identity')

p + facet_wrap(~ Area,ncol=2,labeller = as_labeller(area_names)) +
     theme_bw() +
     theme(strip.background=element_rect(fill="gray")) +
     theme(strip.text = element_text(colour = 'black')) +
     
     labs(x = c("Number of Probes per Gene"),
          y = c('Square Root (Frequency)'),
          title = c('Probes per Gene Distribution by Brain Area')) +
     theme(axis.text=element_text(size=7),
        axis.title=element_text(size=9)) +
     theme(plot.title=element_text(size=10,
                                   hjust=0.5)) +
     
     scale_x_discrete(breaks=c('1','2','3','4','5','6','7','8'),
          labels=c('1','2','3','4','5','6','7','8'),
          limits=c('1','2','3','4','5','6','7','8'))
     
@

\includegraphics{probes_per_gene_by_area}

<<include=FALSE, echo=FALSE, results=tex>>=
# Because there are multiple probes for some genes, use the correlation from only one of the probes to ensure that all genes have an equal chance of showing up in the top n correlated genes. According to Miller et al. (2011), it makes sense to use the probe with the highest expression level, then get the correlation for this probe.

# First, order the data.frame in each area by gene Symbol. This will put multiple probes for the same gene in neighboring rows.

area.List <- list()
area.List <- list(major.Area[[1]],
                  major.Area[[2]],
                  major.Area[[3]],
                  major.Area[[4]])

area.List.byGene <- list()

for (h in 1:length(area.List)) {

Data.bygene <- area.List[[h]][order(area.List[[h]]$Symbol),]


grouped.Area.gene <- Data.bygene %>% group_by(Data.bygene$Symbol) 

area.Data.maxExpr <- grouped.Area.gene %>% summarise(

     n = n(),
     maxExpr = round(max(Mean),3)

)

area.Data.maxExpr <- as.data.frame(area.Data.maxExpr)

area.Data.selected <- matrix(rep(NA,dim(area.Data.maxExpr)[1]*dim(Data.bygene)[2]),
                                 nrow=dim(area.Data.maxExpr)[1],
                                 ncol=dim(Data.bygene)[2])

area.Data.selected <- as.data.frame(area.Data.selected)
colnames(area.Data.selected) <- colnames(Data.bygene)
maxExpr.indx <- matrix(rep(NA,dim(area.Data.maxExpr)[1]),
                       nrow=dim(area.Data.maxExpr)[1])

true.Indx.bott = 0
true.Indx.top = 0

num.max <- matrix(rep(NA,dim(area.Data.maxExpr)[1]))

# When there are at least two maximum expression levels that are identical when there are multiple probes per gene, use the probe/row with the maximum abs(r)

select.Rows.mult.max <- c('max.r')   # 'max.r' or 'avg.r'

for (k in 1:dim(area.Data.maxExpr)[1]) {

     true.Indx.bott = true.Indx.top + 1
     true.Indx.top = true.Indx.bott + (area.Data.maxExpr$n[k] -1)
     
     diff.Indx <- true.Indx.top - true.Indx.bott
     
     if (diff.Indx == 0) {
          
          area.Data.selected[k,] <- Data.bygene[true.Indx.top,]
          
     } else if (diff.Indx > 0) {
          
          maxExpr.indx <- which(grouped.Area.gene$Mean[true.Indx.bott:true.Indx.top] == max(grouped.Area.gene$Mean[true.Indx.bott:true.Indx.top]))
          
          num.max[k] <- length(maxExpr.indx)
          
          if (num.max[k] == 1)  {
               
               area.Data.selected[k,] <- Data.bygene[true.Indx.bott + (maxExpr.indx - 1),]
               
          } else if (num.max[k] > 1) {
               
               # avg.r <- sum(Data.bygene$Sample.r[true.Indx.bott + (maxExpr.indx[1:num.max] - 1)])/num.max
               # area.Data.selected[k,] <- Data.bygene[true.Indx.bott + (maxExpr.indx[1] - 1),]
               # area.Data.selected$Sample.r[k] <- avg.r
               
               pick.Max.r.indx <- which(abs(Data.bygene$Sample.r[true.Indx.bott + (maxExpr.indx[1:num.max[k]] - 1)]) == max(abs(Data.bygene$Sample.r[true.Indx.bott + (maxExpr.indx[1:num.max[k]] - 1)])))
               area.Data.selected[k,] <- Data.bygene[true.Indx.bott + (pick.Max.r.indx - 1),]

               
          } else {
               
          }
          
     } else {
          
     }
     
     
}

area.List.byGene[[h]] <- area.Data.selected

} #end loop over the four areas

# write out the data using gene as the unit rather than probe

for (hj in ib)    {

     fname <- paste('gene_as_unit_',stand.Col.names[hj],'.csv.txt')
     write.csv(area.List.byGene[[hj]],fname,row.names=FALSE)
}







################## ************ area.List.byGene now contains the complete set of variables for
### each row, but each gene is represented only once by the probe with the maximum expression level
### or when there were two maximum identical expression levels, then the tie was broken by choosing
### the probe with the maximum absolute correlation, r, with COMT expression.

### All four areas are represented in area.List.byGene, but they are different lengths (rows)

byOne.Gene.dims <- c(dim(area.List.byGene[[1]])[1],
                     dim(area.List.byGene[[2]])[1],
                     dim(area.List.byGene[[3]])[1],
                     dim(area.List.byGene[[4]])[1])

prefront.Data.onegene <- area.List.byGene[[1]]
cbell.Data.onegene <- area.List.byGene[[2]]
tempor.Data.onegene <- area.List.byGene[[3]]
pons.Data.onegene <- area.List.byGene[[4]]

# Order the one gene data by Pval
prefront.by.Pval <- area.List.byGene[[1]][order(area.List.byGene[[1]]$Sample.p.r.,
                                                          decreasing=FALSE),]
cbell.by.Pval <- area.List.byGene[[2]][order(area.List.byGene[[2]]$Sample.p.r.,
                                                          decreasing=FALSE),]
tempor.by.Pval <- area.List.byGene[[3]][order(area.List.byGene[[3]]$Sample.p.r.,
                                                          decreasing=FALSE),]
pons.by.Pval <- area.List.byGene[[4]][order(area.List.byGene[[4]]$Sample.p.r.,
                                                          decreasing=FALSE),]

# In all four areas, the soluble form of COMT had a higher expression level than the membrane 
# bound form. For that reason, the membrane bound form (r = 1) was no longer included in the 
# results.


@

<<include=FALSE, echo=FALSE, results=tex >>=
##### *****  Order by COMT correlation ****** ##########################
# Now get the top 200 correlated genes in each area. Split off later top 50.
# Do this separately by sign of correlation

top.Cut <- c(200)

hold.Largest.corrs <- data.frame(pfPos=rep(NA,top.Cut),
                                 cbPos=rep(NA,top.Cut),
                                 tmPos=rep(NA,top.Cut),
                                 poPos=rep(NA,top.Cut),
                                 pfNeg=rep(NA,top.Cut),
                                 cbNeg=rep(NA,top.Cut),
                                 tmNeg=rep(NA,top.Cut),
                                 poNeg=rep(NA,top.Cut))

     prefront.Data.onegene <- prefront.Data.onegene[order(prefront.Data.onegene$Sample.r,
                                                          decreasing=TRUE),]
     cbell.Data.onegene <- cbell.Data.onegene[order(cbell.Data.onegene$Sample.r,
                                                    decreasing=TRUE),]
     tempor.Data.onegene <- tempor.Data.onegene[order(tempor.Data.onegene$Sample.r,
                                                      decreasing=TRUE),]
     pons.Data.onegene <- pons.Data.onegene[order(pons.Data.onegene$Sample.r,
                                                  decreasing=TRUE),]
     

     hold.Largest.corrs$pfPos <- prefront.Data.onegene$Symbol[1:top.Cut]
     hold.Largest.corrs$cbPos <- cbell.Data.onegene$Symbol[1:top.Cut]
     hold.Largest.corrs$tmPos <- tempor.Data.onegene$Symbol[1:top.Cut]
     hold.Largest.corrs$poPos <- pons.Data.onegene$Symbol[1:top.Cut]
     
     hold.Largest.corrs$pfNeg <- prefront.Data.onegene$Symbol[byOne.Gene.dims[1]:(byOne.Gene.dims[1] - top.Cut + 1)]
     hold.Largest.corrs$cbNeg <- cbell.Data.onegene$Symbol[byOne.Gene.dims[2]:(byOne.Gene.dims[2] - top.Cut + 1)]
     hold.Largest.corrs$tmNeg <- tempor.Data.onegene$Symbol[byOne.Gene.dims[3]:(byOne.Gene.dims[3] - top.Cut + 1)]
     hold.Largest.corrs$poNeg <- pons.Data.onegene$Symbol[byOne.Gene.dims[4]:(byOne.Gene.dims[4] - top.Cut + 1)]

@
<<>>=
# Plot mean expression level per gene by brain area

stacked.area.Data <- rbind(prefront.Data.onegene,
                           cbell.Data.onegene,
                           tempor.Data.onegene,
                           pons.Data.onegene)

labels.area.pf <- c(rep('prefrontal',dim(prefront.Data.onegene)[1]))
labels.area.cb <- c(rep('cerebellum',dim(cbell.Data.onegene)[1]))
labels.area.tm <- c(rep('temporal',dim(tempor.Data.onegene)[1]))
labels.area.po <- c(rep('pons',dim(pons.Data.onegene)[1]))

labels.area <- cbind(t(labels.area.pf),
                     t(labels.area.cb),
                     t(labels.area.tm),
                     t(labels.area.po))

stacked.area.Data$brainArea <- t(labels.area)


rain.plot <- get.raincloud.Plot(stacked.area.Data)

rain.plot

#ggsave('expression_distributions_by_area.pdf', plot = rain.plot, width = 8, height = 5.5)

@


<<include=FALSE, echo=FALSE, results=tex >>=

# Get the statistics on how many gene are in common across pairs of areas and all four areas
     
num.Match <- data.frame(pos50=rep(NA,3),
                        basepos50=rep(NA,3),
                        pos200=rep(NA,3),
                        basepos200=rep(NA,3),
                        neg50=rep(NA,3),
                        baseneg50=rep(NA,3),
                        neg200=rep(NA,3),
                        baseneg200=rep(NA,3))



# Given the top 50 or 200 +/- correlations in prefrontal, how many of those probes
# appear in the other three brain areas' data? In other words, how many of those 50
# or 200 could possibly have shown up in the top 50 or 200 in each of the other three areas?

num.available.Genes <- matrix(rep(NA,12),ncol=4)     
          
# top 50     POSITIVE ONLY
### Note: available.Genes.pfcb50 are actually the n genes out of 50 in prefrontal cortex that also
### show up in the complete list of cbell genes
available.Genes.pfcb50 <- hold.Largest.corrs$pfPos[na.omit(match(cbell.Data.onegene$Symbol,hold.Largest.corrs$pfPos[1:50]))]

num.available.Genes[1,1] <- length(available.Genes.pfcb50)

available.Genes.pftm50 <- hold.Largest.corrs$pfPos[na.omit(match(tempor.Data.onegene$Symbol,hold.Largest.corrs$pfPos[1:50]))]

num.available.Genes[2,1] <- length(available.Genes.pftm50)

available.Genes.pfpo50 <- hold.Largest.corrs$pfPos[na.omit(match(pons.Data.onegene$Symbol,hold.Largest.corrs$pfPos[1:50]))]

num.available.Genes[3,1] <- length(available.Genes.pfpo50)

# top 200
available.Genes.pfcb200 <- hold.Largest.corrs$pfPos[na.omit(match(cbell.Data.onegene$Symbol,hold.Largest.corrs$pfPos))]

num.available.Genes[1,2] <- length(available.Genes.pfcb200)

available.Genes.pftm200 <- hold.Largest.corrs$pfPos[na.omit(match(tempor.Data.onegene$Symbol,hold.Largest.corrs$pfPos))]

num.available.Genes[2,2] <- length(available.Genes.pftm200)

available.Genes.pfpo200 <- hold.Largest.corrs$pfPos[na.omit(match(pons.Data.onegene$Symbol,hold.Largest.corrs$pfPos))]

num.available.Genes[3,2] <- length(available.Genes.pfpo200)

##### For this analysis, use only the top (+/-) genes in Prefrontal Cortex that COULD have also
##### have been in the top 50 or 200 because they were actually measured in each of the other areas
##### For example: if out of the 50 top positively correlated genes in Prefrontal Cortex, only 42 
##### of them also had expression levels measured in Cerebellum, then when looking for overlap 
##### among the top 50 genes in both of those areas, only use the 42 that could potentially
##### have matched.

# 50 +r
overlap50.pospf.cb <- available.Genes.pfcb50[which(available.Genes.pfcb50 %in% hold.Largest.corrs$cbPos[1:50])]
overlap50.pospf.tm <- available.Genes.pfcb50[which(available.Genes.pfcb50 %in% hold.Largest.corrs$tmPos[1:50])]
overlap50.pospf.po <- available.Genes.pfcb50[which(available.Genes.pfcb50 %in% hold.Largest.corrs$poPos[1:50])]


# 200 +r
overlap200.pospf.cb <- available.Genes.pfcb200[which(available.Genes.pfcb200 %in% hold.Largest.corrs$cbPos)]
overlap200.pospf.tm <- available.Genes.pfcb200[which(available.Genes.pfcb200 %in% hold.Largest.corrs$tmPos)]
overlap200.pospf.po <- available.Genes.pfcb200[which(available.Genes.pfcb200 %in% hold.Largest.corrs$poPos)]
############ End positive only

############ Negative

# top 50
### Note: available.Genes.pfcb50 are actually the n genes out of 50 in prefrontal cortex that also
### show up in the complete list of cbell genes
available.Genes.pfcb50.neg <- hold.Largest.corrs$pfNeg[na.omit(match(cbell.Data.onegene$Symbol,hold.Largest.corrs$pfNeg[1:50]))]

num.available.Genes[1,3] <- length(available.Genes.pfcb50.neg)

available.Genes.pftm50.neg <- hold.Largest.corrs$pfNeg[na.omit(match(tempor.Data.onegene$Symbol,hold.Largest.corrs$pfNeg[1:50]))]

num.available.Genes[2,3] <- length(available.Genes.pftm50.neg)

available.Genes.pfpo50.neg <- hold.Largest.corrs$pfNeg[na.omit(match(pons.Data.onegene$Symbol,hold.Largest.corrs$pfNeg[1:50]))]

num.available.Genes[3,3] <- length(available.Genes.pfpo50.neg)

# top 200
available.Genes.pfcb200.neg <- hold.Largest.corrs$pfNeg[na.omit(match(cbell.Data.onegene$Symbol,hold.Largest.corrs$pfNeg))]

num.available.Genes[1,4] <- length(available.Genes.pfcb200.neg)

available.Genes.pftm200.neg <- hold.Largest.corrs$pfNeg[na.omit(match(tempor.Data.onegene$Symbol,hold.Largest.corrs$pfNeg))]

num.available.Genes[2,4] <- length(available.Genes.pftm200.neg)

available.Genes.pfpo200.neg <- hold.Largest.corrs$pfNeg[na.omit(match(pons.Data.onegene$Symbol,hold.Largest.corrs$pfNeg))]

num.available.Genes[3,4] <- length(available.Genes.pfpo200.neg)

##### For this analysis, use only the top (+/-) genes in Prefrontal Cortex that COULD have also
##### have been in the top 50 or 200 because they were actually measured in each of the other areas
##### For example: if out of the 50 top positively correlated genes in Prefrontal Cortex, only 42 
##### of them also had expression levels measured in Cerebellum, then when looking for overlap 
##### among the top 50 genes in both of those areas, only use the 42 that could potentially
##### have matched.

# 50 -r
overlap50.negpf.cb <- available.Genes.pfcb50.neg[which(available.Genes.pfcb50.neg %in% hold.Largest.corrs$cbNeg[1:50])]
overlap50.negpf.tm <- available.Genes.pfcb50.neg[which(available.Genes.pfcb50.neg %in% hold.Largest.corrs$tmNeg[1:50])]
overlap50.negpf.po <- available.Genes.pfcb50.neg[which(available.Genes.pfcb50.neg %in% hold.Largest.corrs$poNeg[1:50])]


# 200 -r
overlap200.negpf.cb <- available.Genes.pfcb200.neg[which(available.Genes.pfcb200.neg %in% hold.Largest.corrs$cbNeg)]
overlap200.negpf.tm <- available.Genes.pfcb200.neg[which(available.Genes.pfcb200.neg %in% hold.Largest.corrs$tmNeg)]
overlap200.negpf.po <- available.Genes.pfcb200.neg[which(available.Genes.pfcb200.neg %in% hold.Largest.corrs$poNeg)]
############ End negative only

# Get the numbers overlapping with prefrontal

overlap.with.Prefrontal <- data.frame(common50pos=rep(NA,3),
                                      common200pos=rep(NA,3),
                                      common50neg=rep(NA,3),
                                      common200neg=rep(NA,3))

overlap.with.Prefrontal$common50pos[1:3] <- c(length(overlap50.pospf.cb),
                                           length(overlap50.pospf.tm),
                                           length(overlap50.pospf.po))

overlap.with.Prefrontal$common200pos[1:3] <- c(length(overlap200.pospf.cb),
                                           length(overlap200.pospf.tm),
                                           length(overlap200.pospf.po))

overlap.with.Prefrontal$common50neg[1:3] <- c(length(overlap50.negpf.cb),
                                           length(overlap50.negpf.tm),
                                           length(overlap50.negpf.po))

overlap.with.Prefrontal$common200neg[1:3] <- c(length(overlap200.negpf.cb),
                                           length(overlap200.negpf.tm),
                                           length(overlap200.negpf.po))

percent.Overlap <- round(100*overlap.with.Prefrontal/num.available.Genes,1)


summary.Gene.overlap <- cbind(overlap.with.Prefrontal,
                              num.available.Genes,
                              percent.Overlap)

summary.Gene.overlap <- summary.Gene.overlap[c(1,5,9,
                                               2,6,10,
                                               3,7,11,
                                               4,8,12)]

summary.Gene.overlap <- cbind(summary.Gene.overlap,matrix(rep('  ',9),ncol=3))
summary.Gene.overlap <- summary.Gene.overlap[c(1,2,3,13,
                                               4,5,6,14,
                                               7,8,9,15,
                                               10,11,12)]


row.names(summary.Gene.overlap) <- c(rep(NULL,3))
colnames(summary.Gene.overlap) <- c(rep('',15))

summary.Gene.overlap[,3] <- paste(summary.Gene.overlap[,3],'%',sep='')
summary.Gene.overlap[,7] <- paste(summary.Gene.overlap[,7],'%',sep='')
summary.Gene.overlap[,11] <- paste(summary.Gene.overlap[,11],'%',sep='')
summary.Gene.overlap[,15] <- paste(summary.Gene.overlap[,15],'%',sep='')

summary.Gene.overlap[,2] <- paste('(',summary.Gene.overlap[,2],')*',sep='')
summary.Gene.overlap[,6] <- paste('(',summary.Gene.overlap[,6],')',sep='')
summary.Gene.overlap[,10] <- paste('(',summary.Gene.overlap[,10],')',sep='')
summary.Gene.overlap[,14] <- paste('(',summary.Gene.overlap[,14],')',sep='')


summary.Gene.overlap.tab <- xtable(summary.Gene.overlap)

#row.names(num.Match) <- c('Cerebellum','Temporal Cerebral Wall','Pons')
col.Groups <- c('Positive','Negative')
add.col.Groups <- c('','50','','','',' 200','','','',' 50','','','',' 200','','')
#extra.Col.names <- rep(c('Shared','Base PFC'),4)
bottom.Note <- c('*Not all of the genes whose expression levels were measured in Prefrontal Cortex were also measured in each of the other brain areas. The number in parentheses shows how many of the 50/200 most strongly correlated genes in Prefrontal Cortex were also measured in the corresponding brain area. It is used as the denominator in calculating the percentage of genes overlapping with those in Prefrontal Cortex.')


summary.Gene.overlap.ltx <- latex(summary.Gene.overlap.tab,file='',
                   caption = paste0('Number and percent of the most strongly correlated genes in common by brain area with the 50 or 200 most strongly positively and negatively ',"\\textit{COMT}",'-correlated genes in Prefrontal Cortex',sep=''),
                     caption.loc = c('top'),
                     cgroup = col.Groups,
                     n.cgroup = c(8,7),
                     colheads = add.col.Groups,
#                   extracolheads = extra.Col.names,
                     rowlabel = '\n Brain Area',
                     rowname = stand.Col.names[2:4],
                     colnamesTexCmd="bfseries",
                     booktabs=TRUE,
                     label=c('tab:numsharedgenes'),
                     na.blank = TRUE,
                     vbar = FALSE,
                     longtable=TRUE,
                     table.env=TRUE,
#                     center=c('center'),
                     continued=c('Number of Genes in Common Continued'),
                     first.hline.double = FALSE,
                     append=FALSE,
                     insert.bottom = bottom.Note,
                     insert.bottom.width = c('6in')
                     )

@

\Sexpr{summary.Gene.overlap.ltx}

The data show that\\
\begin{enumerate}
     \item The proportion of highly correlated genes in common between prefrontal cortex and the other three brain areas is approximately twice as large for positively correlated genes as for negatively correlated genes.
     \item Regardless of the sign of the correlation, there are approximately 1.5 to 2 times as many genes in common between prefrontal cortex and the temporal cerebral wall as between the other two areas.
     \item The proportion of genes in common between PFC and cerebellum and pons is approximately the same.
\end{enumerate}

<<include=FALSE, echo=FALSE, results=tex>>=
# Write out the top 200 +/- correlated genes in each area as csv files

file.Adds <- c('prefrontal',
               'cerebellum',
               'temporal',
               'pons')
# Positive
for (j in 1:4) {
     
fname <- paste('top_200_pos_genes_',file.Adds[j],'.csv')
     mtrx.top.Pos <- matrix(hold.Largest.corrs[,j],ncol=4)
     colnames(mtrx.top.Pos) <- c('num1_50',
                                 'num51_100',
                                 'num101_150',
                                 'num151_200')
     write.csv(mtrx.top.Pos,fname,row.names=FALSE)
}

# Negative
for (j in 5:8) {
     
fname <- paste('top_200_neg_genes_',file.Adds[j-4],'.csv')
     mtrx.top.Neg <- matrix(hold.Largest.corrs[,j],ncol=4)
     colnames(mtrx.top.Neg) <- c('num1_50',
                                 'num51_100',
                                 'num101_150',
                                 'num151_200')
     write.csv(mtrx.top.Neg,fname,row.names=FALSE)
}

# Now write them out 200 per column by area (columns)

top_200_pos_by_area <- data.frame(pf=hold.Largest.corrs[,1],
                                  cb=hold.Largest.corrs[,2],
                                  tm=hold.Largest.corrs[,3],
                                  po=hold.Largest.corrs[,4])

colnames(top_200_pos_by_area) <- stand.Col.names

write.csv(top_200_pos_by_area,'top_200_pos_by_area.csv',row.names=FALSE)

top_200_neg_by_area <- data.frame(pf=hold.Largest.corrs[,5],
                                  cb=hold.Largest.corrs[,6],
                                  tm=hold.Largest.corrs[,7],
                                  po=hold.Largest.corrs[,8])

colnames(top_200_neg_by_area) <- stand.Col.names

write.csv(top_200_neg_by_area,'top_200_neg_by_area.csv',row.names=FALSE)

# Put the top 200 pos and neg into latex tables

top.200.pos.area.tab <- xtable(top_200_pos_by_area)
top.200.neg.area.tab <- xtable(top_200_neg_by_area)

top.200.pos.area.ltx <- latex(top.200.pos.area.tab,file='',
                   caption = paste0('Two hundred genes whose expression levels were most strongly positively correlated with the expression of ',"\\textit{COMT}",'by brain area',sep=''),
                     caption.loc = c('top'),
#                    cgroup = col.Groups,
#                   n.cgroup = c(2,2),
#                     colheads = add.col.Groups,
#                   extracolheads = extra.Col.names,
#                     rowlabel = '\n Brain Area',
                     colnamesTexCmd="bfseries",
                     booktabs=TRUE,
                     label=c('tab:top200pos'),
                     na.blank = TRUE,
                     vbar = FALSE,
                     longtable=TRUE,
                     table.env=TRUE,
#                     center=c('center'),
                     continued=c('Top 200 positively correlated genes continued'),
                     first.hline.double = FALSE,
                     append=FALSE
                     )

top.200.neg.area.ltx <- latex(top.200.neg.area.tab,file='',
                   caption = paste0('Two hundred genes whose expression levels were most strongly negatively correlated with the expression of ',"\\textit{COMT}",' by brain area',sep=''),
                     caption.loc = c('top'),
#                    cgroup = col.Groups,
#                   n.cgroup = c(2,2),
#                     colheads = add.col.Groups,
#                   extracolheads = extra.Col.names,
#                     rowlabel = '\n Brain Area',
                     colnamesTexCmd="bfseries",
                     booktabs=TRUE,
                     label=c('tab:top200neg'),
                     na.blank = TRUE,
                     vbar = FALSE,
                     longtable=TRUE,
                     table.env=TRUE,
#                     center=c('center'),
                     continued=c('Top 200 negatively correlated genes continued'),
                     first.hline.double = FALSE,
                     append=FALSE
                     )


@

\Sexpr{top.200.pos.area.ltx}
\Sexpr{top.200.neg.area.ltx}


<<include=FALSE, echo=FALSE, results=tex >>=


####################### Get promoter sequences; write out in FASTA format

# get -1000 (upstream) to +600 (downstream) promoter sequences of top 50 +/- correlated genes
# The returned sequence is in the 5' to 3' direction. The start position in measuring
# upstream and downstream is the transcription start site of the gene (TSS).

# entrez.list <- list()
#      entrez.list <- list(prefront.Data.onegene$ENTREZID[1:51],
#                       prefront.Data.onegene$ENTREZID[dim(prefront.Data.onegene)[1]:(dim(prefront.Data.onegene)[1] - 50 -1) ],
#                       cbell.Data.onegene$ENTREZID[1:51],
#                       cbell.Data.onegene$ENTREZID[dim(cbell.Data.onegene)[1]:(dim(cbell.Data.onegene)[1] - 50 -1) ],
#                       tempor.Data.onegene$ENTREZID[1:51],
#                       tempor.Data.onegene$ENTREZID[dim(tempor.Data.onegene)[1]:(dim(tempor.Data.onegene)[1] - 50 -1) ],
#                       pons.Data.onegene$ENTREZID[1:51],
#                       pons.Data.onegene$ENTREZID[dim(pons.Data.onegene)[1]:(dim(pons.Data.onegene)[1] - 50 -1) ])
# 
# 
# fasta_files <- c('fasta_50_pos_promoter_seq_pf.txt',
#                  'fasta_50_neg_promoter_seq_pf.txt',
#                  'fasta_50_pos_promoter_seq_cb.txt',
#                  'fasta_50_neg_promoter_seq_cb.txt',
#                  'fasta_50_pos_promoter_seq_tm.txt',
#                  'fasta_50_neg_promoter_seq_tm.txt',
#                  'fasta_50_pos_promoter_seq_po.txt',
#                  'fasta_50_neg_promoter_seq_po.txt')
# 
# area.abbrv <- c('pf',
#      'pf',
#      'cb',
#      'cb',
#      'tm',
#      'tm',
#      'po',
#      'po')
# 
# for (u in seq(1,7,2)) {
# 
#      # ############ DEBUG
#      # u <- c(1)
#      # ##################
#      
# entrez <- entrez.list[[u]]
# entrez.neg <- entrez.list[[u+1]]
# 
# ### Positive
# promoterUp.pos50 <- getSequence(id = entrez, 
#             type="entrezgene",
#             seqType="coding_gene_flank",
#             upstream=1000,
#             mart=ensembl)
# 
# promoterDown.pos50 <- getSequence(id = entrez, 
#             type="entrezgene",
#             seqType="coding_gene_flank",
#             downstream=600,
#             mart=ensembl)
# 
# match.E.pos.Up <- match(entrez,promoterUp.pos50[,2])
# match.E.pos.Down <- match(entrez,promoterDown.pos50[,2])
# 
# promoter.pos50 <- as.character(paste(promoterUp.pos50[c(match.E.pos.Up),1],promoterDown.pos50[match.E.pos.Down,1],sep=''))
# promoter.pos50 <- data.frame(entrezgene = promoterUp.pos50[c(match.E.pos.Up),2],
#                                 prom.Seq = promoter.pos50,stringsAsFactors = FALSE)
# 
# # To get FASTA format
# 
# promoter.pos50$entrezgene <- paste('>',as.character(promoter.pos50$entrezgene),sep='')
# 
# # write.table(promoter.pos50, file = fasta_files[u], sep = "\n",
# #                     row.names = FALSE,col.names=FALSE,quote=FALSE)
# 
# # write out in csv format
# 
# promoter.pos50.long <- comma.Sep(promoter.pos50)
# 
# write.csv(file=c(paste('promoter_seq_pos_',area.abbrv[u],'.csv',sep='')),
#           promoter.pos50.long,row.names = FALSE)
# 
# 
# 
# # match.E.pos.Up and match.E.pos.Down are the indices in promoterUp.pos50 and 
# # promoterDown.pos50 for which the entrezgene identifiers match. They are perfectly in order:
# # the entrezgene for promoterUp.pos50[1:50,2] equals the entrezgene for 
# # promoterDown.pos50[1:50,2]. Therefore, the 1000 bp sequence upstream can be pasted directly
# # onto the 600 bp downstream sequence.
# 
# ### Negative
# promoterUp.neg50 <- getSequence(id = entrez.neg, 
#             type="entrezgene",
#             seqType="coding_gene_flank",
#             upstream=1000,
#             mart=ensembl)
# 
# promoterDown.neg50 <- getSequence(id = entrez.neg, 
#             type="entrezgene",
#             seqType="coding_gene_flank",
#             downstream=600,
#             mart=ensembl)
# 
# 
# match.E.neg.Up <- match(entrez.neg,promoterUp.neg50[,2])
# match.E.neg.Down <- match(entrez.neg,promoterDown.neg50[,2])
# 
# promoter.neg50 <- as.character(paste(promoterUp.neg50[c(match.E.neg.Up[1:50]),1],promoterDown.neg50[c(match.E.neg.Down[1:50]),1],sep=''))
# promoter.neg50 <- data.frame(entrezgene = promoterUp.neg50[c(match.E.neg.Up[1:50]),2],
#                                 prom.Seq = promoter.neg50,stringsAsFactors = FALSE)
# 
# # To get FASTA format
# 
# promoter.neg50$entrezgene <- paste('>',as.character(promoter.neg50$entrezgene),sep='')
# 
# # write.table(promoter.neg50, file = fasta_files[u+1], sep = "\n",
# #                     row.names = FALSE,col.names=FALSE,quote=FALSE)
# 
# # write out in csv format
# 
# promoter.neg50.long <- comma.Sep(promoter.neg50)
# 
# write.csv(file=c(paste('promoter_seq_neg_',area.abbrv[u+1],'.csv',sep='')),
#           promoter.neg50.long,row.names = FALSE)
# 
# 
# } # end brain area loop

############## END get promoter sequences and writing out FASTA formatted files

@

<< >>=

# This is used below in the ontology analysis section.

# Which genes show the largest variance in COMT-correlation coefficients across brain areas?
# Need to find out which genes were measured in all four brain areas - do this using the onegene 
# data

all.Areas.symbols <- na.omit(intersect(intersect(intersect(na.omit(prefront.Data.onegene$Symbol),na.omit(cbell.Data.onegene$Symbol)),na.omit(tempor.Data.onegene$Symbol)),na.omit(pons.Data.onegene$Symbol)))

# This leaves 10636 genes in common across the brain areas
pf.common.Genes.indx <- match(all.Areas.symbols,prefront.Data.onegene$Symbol)
cb.common.Genes.indx <- match(all.Areas.symbols,cbell.Data.onegene$Symbol)
tm.common.Genes.indx <- match(all.Areas.symbols,tempor.Data.onegene$Symbol)
po.common.Genes.indx <- match(all.Areas.symbols,pons.Data.onegene$Symbol)
# 
area.colwise <- data.frame(pf.a = prefront.Data.onegene$Symbol[pf.common.Genes.indx],
           cb.a = cbell.Data.onegene$Symbol[cb.common.Genes.indx],
           tm.a = tempor.Data.onegene$Symbol[tm.common.Genes.indx],
           po.a = pons.Data.onegene$Symbol[po.common.Genes.indx],
           pf.m = prefront.Data.onegene$Mean[pf.common.Genes.indx],
           cb.m = cbell.Data.onegene$Mean[pf.common.Genes.indx],
           tm.m = tempor.Data.onegene$Mean[pf.common.Genes.indx],
           po.m = pons.Data.onegene$Mean[pf.common.Genes.indx],
           pf.r = prefront.Data.onegene$Sample.r[pf.common.Genes.indx],
           cb.r = cbell.Data.onegene$Sample.r[cb.common.Genes.indx],
           tm.r = tempor.Data.onegene$Sample.r[tm.common.Genes.indx],
           po.r = pons.Data.onegene$Sample.r[po.common.Genes.indx])
# 
area.colwise$ENTREZID <- prefront.Data.onegene$ENTREZID[pf.common.Genes.indx]
# 
# 

# Determine for each gene whether the correlation with COMT expression was above or
# below the average correlation WITHIN a brain area

# First use Fisher's Z-transformation to convert the correlations to z scores.

r2Z <- function (r.in) 0.5*(log(1.0 + r.in) - log(1.0 - r.in))    # Fisher's r to Z

fix.dim <- dim(area.colwise)[2]
area.colwise[,(fix.dim + 1:4)] <- r2Z(area.colwise[,(fix.dim - 4:1)])
colnames(area.colwise)[(fix.dim + 1:4)] <- c('pf.Z','cb.Z','tm.Z','po.Z')

area.colwise$pf.z <- scale(area.colwise$pf.Z,center=TRUE,scale=TRUE) 
area.colwise$cb.z <- scale(area.colwise$cb.Z,center=TRUE,scale=TRUE)
area.colwise$tm.z <- scale(area.colwise$tm.Z,center=TRUE,scale=TRUE)
area.colwise$po.z <- scale(area.colwise$po.Z,center=TRUE,scale=TRUE)

fix.dim <- dim(area.colwise)[2]
area.colwise[,(fix.dim + 1:4)] <- sign(area.colwise[,(fix.dim - 3:0)])

fix.dim <- dim(area.colwise)[2]
colnames(area.colwise)[(fix.dim - 3:0)] <- c('pf.zsign','cb.zsign','tm.zsign','po.zsign')

fix.dim <- dim(area.colwise)[2]
sign.tab <- table(area.colwise[,(fix.dim - 3:0)])
 
summary(sign.tab)
sign.tab2 <- data.frame(sign.tab)

sign.tab3 <- structable(area.colwise[,22:25])


@

March 19, 2018\\
Using the following steps:
\begin{enumerate}
     \item All {\textit {COMT}}-correlations are Z transformed using Fisher's formula.
     \item Within a brain region, these Fisher Z scores are z-scored (x - m)/s.
     \item These z-scores are then converted to signs (+ or -).
     \item A plus sign means that gene in that brain area had a correlation that was above the average correlation for all genes in that brain area.
     \item A minus sign means that gene in that brain area had a correlation that was below the average correlation for all genes in that brain area.
\end{enumerate}

Using this order for brain areas: Prefrontal, Cerebellum, Temporal, Pons - the following sign patterns are indicative of:
\begin{enumerate}
     \item Tissue {\textit {non-specific}} expression regulation: +1, +1, +1, +1 or -1, -1, -1, -1
     \item Prefrontal-specific regulation: -1, +1, +1, +1 or +1, -1, -1, -1
     \item Cerebellum-specific regulation: +1, -1, +1, +1 or -1, +1, -1, -1
     \item Temporal-specific regulation: +1, +1, -1, +1 or -1, -1, +1, -1
     \item Pons-specific regulation: +1, +1, +1, -1 or -1, -1, -1, +1
\end{enumerate}

The table in the file zsign_tab.pdf shows that a very large proportion of the genes exhibited the first pattern above indicating tissue {\textit {non-specific}} expression regulation. There were, however, nontrivial numbers of genes who showed one of the other four patterns. By classifying the genes into the other four categories above, it should be possible to do ontology to discover what networks or functions those genes might exhibit.

<< >>=
# Classify genes into one of the four tissue specific regulation patterns, or the tissue nonspecific pattern.

hold.binary <- matrix(rep(0,5*dim(area.colwise)[1]),ncol=5)
hold.binary[,1:4] <- c((area.colwise$pf.zsign + 1)/2,
                       (area.colwise$cb.zsign + 1)/2,
                       (area.colwise$tm.zsign + 1)/2,
                       (area.colwise$po.zsign + 1)/2
                       )
hold.binary[,5] <- (hold.binary[,1])*(2^3) + (hold.binary[,2])*(2^2) + (hold.binary[,3])*(2^1) + (hold.binary[,4])*(2^0)

# hold.binary[,5] holds the numbers 0:15. Pairs of numbers represent different types of expression regulation: 4 pairs represent area-specific regulation, and 1 pair represents area (tissue) nonspecific regulation. For example the numbers 0 and 15 represent area nonspecific regulation because the correlations in all four brain areas are above the average correlation in their respective brain areas or all of them are below.

area.colwise$signClass <- hold.binary[,5]

pf.specific.up <- subset(area.colwise,area.colwise$signClass == 8)
pf.specific.down <- subset(area.colwise,area.colwise$signClass == 7)
pf.specific <- subset(area.colwise,area.colwise$signClass == 7 | area.colwise$signClass == 8)
pf.specific$shuffSymb <- sample(pf.specific$pf.a,dim(pf.specific)[1],replace=FALSE)





@




<< >>=
# 
# # Do the same analysis for mean expression level
# ############************ First z-score the mean expression levels to remove between probeset effects
# 
# area.colwise$zscorepf <- scale(area.colwise$pf.m,center=T,scale=T)
# area.colwise$zscorecb <- scale(area.colwise$cb.m,center=T,scale=T)
# area.colwise$zscoretm <- scale(area.colwise$tm.m,center=T,scale=T)
# area.colwise$zscorepo <- scale(area.colwise$po.m,center=T,scale=T)
# 
# # Now calculate mean and variance
# 
# avg.expr <- rowMeans(area.colwise[,14:17])
# 
# var.expr <- rowVars(as.matrix(area.colwise[,14:17]))
# 
# # Now calculate the coefficient of variation for the correlation coefficient
# 
# coeff.Var.expr <- sqrt(var.expr)/abs(avg.expr)
# 
# # Now add columns to area.colwise
# 
# area.colwise$avg.expr <- avg.expr
# area.colwise$varnc.expr <- var.expr
# area.colwise$coeffVar.expr <- coeff.Var.expr
# 
# # Order by expression CV
# area.colwise <- area.colwise[order(area.colwise$coeffVar.expr,decreasing=TRUE),]
# 
# area.colwise[1:20,1]

@ 


% latex table generated in R 3.4.3 by xtable 1.8-2 package
% Wed Feb 21 08:07:04 2018
\begin{table}[ht]
\centering
%\begin{tabular}{lllllll}
\begin{tabular}{l >{\itshape}l >{\itshape}l >{\itshape}l >{\itshape}l >{\itshape}l >{\itshape}l }
  \hline
&  &  &  &  & \\ 
  \hline
{\bfseries{Cerebellum}} &   &   &   &   \\ 
& GPM6B & PMP22 & CPQ & COMT & MYO6 \\ 
& GPM6B & SEC22C & CAT & ATRAID & PPIB \\
{\bfseries{Temporal Cerebral Wall}} &   &   &   &   \\ 
& GPM6B & NTSR2 & PMP22 & EDNRB & PKM \\ 
& GATM & CDC14B & PTTG1IP & ECH1 & HSCB \\ 
& GPM6B & SEC22C & DTYMK & TSPO & CSTB \\ 
& MGLL & SLC3A2 & COMT & MEGF10 & ACY1 \\ 
& CAT & PLPP3 & CLDN10 & FGFR3 &   \\ 
{\bfseries{Pons}} &   &   &   &   \\ 
& GPM6B & SEC22C & GPM6B & GATM & CLU \\ 
& C2ORF28 & COMT & PMP22 & CAT & MEGF10 \\ 
   \hline
\end{tabular}
\caption{Genes having the strongest positively correlated expression with \textit{COMT} in each area also among the 50 most strongly \textit{COMT}-correlated genes in Prefrontal Cortex} 
\end{table}



<<include=FALSE, echo=FALSE, results=tex>>=
# How are the genes in the top 200 +/- distributed over chromosomes?

map.Chrname.Chrnum <- data.frame(chrname = as.character(c(1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,                                             2, 20, 21, 22,  3,  4,  5,  6,  7, 8,  9,  'X', 'Y' )),
                                 chrnum = as.character(c(seq(1:22),'X','Y')))

chrname2num <- match(map.Chrname.Chrnum$chrnum,map.Chrname.Chrnum$chrname)

area.onegene.List <- list()
area.onegene.List <- list(prefront.Data.onegene,
                          prefront.Data.onegene,
                          cbell.Data.onegene,
                          cbell.Data.onegene,
                          tempor.Data.onegene,
                          tempor.Data.onegene,
                          pons.Data.onegene,
                          pons.Data.onegene)


pos.neg.Lims <- matrix(c(1,201,
                       dim(prefront.Data.onegene)[1],(dim(prefront.Data.onegene)[1] -200 +1),
                       1,201,
                       dim(cbell.Data.onegene)[1],(dim(cbell.Data.onegene)[1] -200 +1),
                       1,201,
                       dim(tempor.Data.onegene)[1],(dim(tempor.Data.onegene)[1] -200 +1),
                       1,201,
                       dim(pons.Data.onegene)[1],(dim(pons.Data.onegene)[1] -200 +1)),
                       nrow=8,ncol=2,byrow=TRUE)

sign.Names <- rep(c('positively','negatively'),4)

chsq.genes.byChr <- vector(mode = "list", length = 8)

area.ltx.tab <- vector(mode = "list", length = 8)

for (b in 1:8)   {

     ######### DEBUG
#     b <- c(2)
     
     genes.By.chr.tab <- genesBychrom(area.onegene.List[[b]],chrname2num,pos.neg.Lims[b,1],
                                      pos.neg.Lims[b,2])
# positive and negative alternate within area
     chsq.genes.byChr[[b]] <- chisq.genes.By.chr(area.onegene.List[[b]],genes.By.chr.tab,chrname2num,
                                            pos.neg.Lims[b,1],pos.neg.Lims[b,2])

# chsq.genes.byChr.PF <- chisq.test(genes.By.chr.tab$Frequency, y = NULL, correct = FALSE,
#            p = genes.By.chr.percent.noY, rescale.p = FALSE,
#            simulate.p.value = FALSE, B = 2000)


topgene.By.chr.tab <- xtable(genes.By.chr.tab,
                             caption=paste0('Distribution of the top 200 ',sign.Names[b]," \\textit{COMT}",'-correlated genes by \\\\ Chromosome: ',rep(stand.Col.names,each=2)[b],sep=''),
                             digits=c(0,0,0,1,2,5))

area.ltx.tab[[b]] <- print.xtable(topgene.By.chr.tab,
                                  file=paste('table_top_200_',sign.Names[b],'_',
                                   rep(stand.Col.names,each=2)[b],'.tex',sep=''),
                         type='latex',
                         floating=FALSE,
                         caption.placement='top',
                         tabular.environment='longtable',
                         caption.width ='0.5\\textwidth',
                         hline.after=c(-1,0,nrow(topgene.By.chr.tab)),
                         include.rownames=FALSE,
                         print.results=TRUE,
                         booktabs=TRUE,
                         comment=TRUE
                         )

#### The Expected column in this table shows how many genes would be expected to be in the top 200 for each chromosome based on the proportion of genes across the entire sample on each chromosome. The P value is a binomial test using z = (freq - expected)/sd where sd = sqrt(200*expectedProp*(1-expectedProp)). The Bonferroni corrected pval would be 0.05/23 == 0.002. None of the deviations individually are significant.


} # end brain area loop

@

<<include=FALSE,echo=TRUE,results=tex >>=
# Generate a table that summarizes the chi-square results


summary.Chisq <- matrix(rep(NA,40),nrow=8,ncol=5)
summary.Chisq <- data.frame(summary.Chisq)
colnames(summary.Chisq) <- c('Area','Sign','Chi-square','df','p')

summary.Chisq$Area <- c('Prefrontal Cortex',
                                   '',
                                   'Cerebellum',
                                   '',
                                   'Temporal Cerebral Wall',
                                   '',
                                   'Pons',
                                   '')

summary.Chisq$Sign <- rep(c('positive','negative'),4)

summary.Chisq$`Chi-square` <- c(chsq.genes.byChr[[1]]$statistic,
                                        chsq.genes.byChr[[2]]$statistic,
                                        chsq.genes.byChr[[3]]$statistic,
                                        chsq.genes.byChr[[4]]$statistic,
                                        chsq.genes.byChr[[5]]$statistic,
                                        chsq.genes.byChr[[6]]$statistic,
                                        chsq.genes.byChr[[7]]$statistic,
                                        chsq.genes.byChr[[8]]$statistic)

summary.Chisq$df <- c(chsq.genes.byChr[[1]]$parameter,
                                        chsq.genes.byChr[[2]]$parameter,
                                        chsq.genes.byChr[[3]]$parameter,
                                        chsq.genes.byChr[[4]]$parameter,
                                        chsq.genes.byChr[[5]]$parameter,
                                        chsq.genes.byChr[[6]]$parameter,
                                        chsq.genes.byChr[[7]]$parameter,
                                        chsq.genes.byChr[[8]]$parameter)

summary.Chisq$p <- round(c(chsq.genes.byChr[[1]]$p.value,
                                        chsq.genes.byChr[[2]]$p.value,
                                        chsq.genes.byChr[[3]]$p.value,
                                        chsq.genes.byChr[[4]]$p.value,
                                        chsq.genes.byChr[[5]]$p.value,
                                        chsq.genes.byChr[[6]]$p.value,
                                        chsq.genes.byChr[[7]]$p.value,
                                        chsq.genes.byChr[[8]]$p.value),6)


summary.Chisq.tab <- xtable(summary.Chisq,
                            caption=c(paste('Chi-square summaries testing the hypothesis that the distribution of the number of the 200 most strongly '," \\textit{COMT}",'\ correlated genes across chromosomes reflects the overall proportions of genes per chromosome in the complete sample.',sep='')),digits=c(0,0,0,3,0,6))

chisq.Summary <- print.xtable(summary.Chisq.tab,
                         file=paste('chi_square_genes_per_chr_200.tex',sep=''),
                         type='latex',
                         floating=FALSE,
                         caption.placement='top',
                         tabular.environment='longtable',
                         caption.width ='0.5\\textwidth',
                         hline.after=c(-1,0,nrow(summary.Chisq.tab)),
                         include.rownames=FALSE,
                         print.results=TRUE,
                         booktabs=TRUE,
                         comment=TRUE
                         )


@


The Chi-square tests showed that only for the 200 most strongly negatively {\textit {COMT}}\den correlated genes in Prefrontal and Temporal Cortex did the distribution of the 200 genes across chromosomes differ significantly from the overall proportions of genes per chromosome for the complete sample.\\

Examination of the distributions of these 200 genes in Prefrontal and Temporal Cortex using binomial tests that in both of these areas only on Chromosome 5 did the number of the most strongly negatively correlated genes deviate significantly from what would have been expected based on the overall proportions of genes per chromosome in the entire sample. In both cases, the observed number of strongly negatively correlated genes on Chromosome 5 far exceeded the number expected by chance.\\

<<include=FALSE, echo=False, results=tex >>=
# Generate tables that show which genes were most strongly positively or negatively correlated with COMT expression on a per chromosome basis.

for (b in 1:8)  {
########## DEBUG 

#b <- c(2)

########## END DEBUG

temp.Hold <- area.onegene.List[[b]][pos.neg.Lims[b,1]:pos.neg.Lims[b,2],]

temp.Hold2 <- temp.Hold[order(temp.Hold$loc),]

temp.tab <- table(temp.Hold2$loc)

temp.tab.seq <- matrix(rep(0,46),nrow=23)
temp.tab.seq[1,1:2] <- c(1,temp.tab[1])

for (i in 2:23) {
     temp.tab.seq[i,1] <- temp.tab.seq[i-1,2] + 1
     temp.tab.seq[i,2] <- temp.tab.seq[i,1] + temp.tab[i] -1
                       
}

fname <- paste0('topgenes_by_chr_',sign.Names[b],'_',rep(stand.Col.names,each=2)[b],'.txt',sep='')
fnameinput <- paste0('readable_topgenes_by_chr_',sign.Names[b],'_',rep(stand.Col.names,each=2)[b],'.csv',sep='')
write(paste(rep(stand.Col.names,each=2)[b],' ',sign.Names[b],'\n',sep=''),file=fname,append=FALSE)

for (j in 1:23)     {
     # Human readable
     write(print(paste('Chromosome ',map.Chrname.Chrnum$chrnum[j],sep=''),quote=FALSE),append=TRUE,
           ncolumns=8,file=fname,sep='\t')
     write(print(temp.Hold2[temp.tab.seq[chrname2num[j],1]:temp.tab.seq[chrname2num[j],2],3],rownames=FALSE,quote=FALSE),append=TRUE,ncolumns=8,file=fname,sep='\t')
     write(print(''),file=fname,append=TRUE)
     
     # R readable csv
     hold.Genes <- c(temp.Hold2[temp.tab.seq[chrname2num[j],1]:temp.tab.seq[chrname2num[j],2],3])
     hold.Genes[2:(length(hold.Genes) + 1)] <- hold.Genes
     hold.Genes[1] <- as.character(map.Chrname.Chrnum$chrnum[j])
     # write(print(temp.Hold2[temp.tab.seq[chrname2num[j],1]:temp.tab.seq[chrname2num[j],2],3],rownames=FALSE,quote=FALSE),append=TRUE,ncolumns=8,file=fnameinput,sep=', ')
     
     write(print(hold.Genes,rownames=FALSE,quote=FALSE),ncolumns=30,append=TRUE,file=fnameinput,sep=', ')

}

} # end brain area x sign loop 
@ 

<<include=FALSE, echo=FALSE, results=tex>>=
# Because only prefrontal negative and temporal negative showed significant chi-squares when
# comparing the observed distribution of 200 genes across chromosomes to the expected distribution
# based on the overall sample of genes whose expression levels were measured, and because 
# Chromosome 5 for both brain areas was the area that showed significantly more genes than would have # been expected (binomial tests), determine which genes on chromosome 5 among the 200 most strongly
# negatively coprrelated genes were in common across the two brain areas.

wbgc <- loadWorkbook('readabletopgenes_by_chr.xlsx')   

# now tell R to read that workbook and which sheet
  pf.Neg <- read.xlsx(wbgc,sheet = "pfneg",colNames=FALSE,rowNames=TRUE,na.strings=NA)
  tm.Neg <- read.xlsx(wbgc,sheet = "tmneg",colNames=FALSE,rowNames=TRUE,na.strings=NA)

  num.Genes.neg.Chr5 <- data.frame(area=c('Prefrontal','Temporal'),
                                   number=c(length(pf.Neg[5,]),length(tm.Neg[5,])))
  
genes.Shared.neg.chr5 <- tm.Neg[5,c(na.omit(match(pf.Neg[5,],tm.Neg[5,])))]

common.genes.Chr5.neg <- list()
common.genes.Chr5.neg[[1]] <- num.Genes.neg.Chr5   # Number of genes in top 200 not the shared ones
common.genes.Chr5.neg[[2]] <- sub(' ','',genes.Shared.neg.chr5)

# Get the ENTREZIDs for the genes in common

common.neg.Chr5.entrez <- matrix(rep(NA,length(common.genes.Chr5.neg[[2]])),
                                 ncol=1)

for (w in 1:length(common.genes.Chr5.neg[[2]])) {
    
           
    common.neg.Chr5.entrez[w]  <- area.List.byGene[[1]]$ENTREZID[(which(area.List.byGene[[1]]$Symbol == common.genes.Chr5.neg[[2]][w]))]
    
}
common.genes.Chr5.neg[[3]] <- common.neg.Chr5.entrez
common.neg.Genes.Chr5 <- data.frame(genes=common.genes.Chr5.neg[[2]],
                                    ENTREZID=common.genes.Chr5.neg[[3]])

########### *************** Transcriptiopn factors analysis using PFAM
temp.start.pos <- getBM(attributes = c('hgnc_symbol',"start_position",'entrezgene',"refseq_mrna"), 
                                        filters = "entrezgene",
                                        values = as.character(common.neg.Genes.Chr5$ENTREZID), 
                                        mart = ensembl)
comt.getBM <- getBM(attributes = c('hgnc_symbol',"start_position",'entrezgene',"refseq_mrna"), 
                                        filters = "hgnc_symbol",
                                        values = as.character('COMT'), 
                                        mart = ensembl)

wbts <- loadWorkbook('tsfactors_shared_8_and_comt_pscan.xlsx')
# wbhsa2 <- loadWorkbook('comt_coex_list_500_hsa2.xlsx')
# wbhsa3 <- loadWorkbook('comt_coex_list_500_hsa3.xlsx')

shared8.tfacts <- data.frame(read.xlsx(wbts,         # now tell R to read that workbook and which sheet
                                  sheet = "shared_8"))

comt.tfacts <- data.frame(read.xlsx(wbts,         # now tell R to read that workbook and which sheet
                                  sheet = "comt"))

shared8.comt.tsfactors.indx <- match(comt.tfacts$TF.NAME,shared8.tfacts$TF.NAME)
shared8.tfacts[shared8.comt.tsfactors.indx[1:10],]

one.genelims.pf <- c(rep(NA,2))
one.genelims.pf[1] <- length(prefront.Data.onegene$Symbol)
one.genelims.pf[2] <- length(prefront.Data.onegene$Symbol) - 199

na.omit(match(prefront.Data.onegene$Symbol[one.genelims.pf[1]:one.genelims.pf[2]],comt.tfacts$TF.NAME))

na.omit(match(prefront.Data.onegene$Symbol[1:200],comt.tfacts$TF.NAME))
################## END Transcription factor analysis ##########################


gene.Output.order <- match(common.neg.Genes.Chr5$genes,temp.start.pos$hgnc_symbol)

common.neg.Genes.Chr5$startpos <- temp.start.pos$start_position[c(gene.Output.order)]/1000000.

# order by start position
common.neg.Genes.Chr5 <- common.neg.Genes.Chr5[order(common.neg.Genes.Chr5$startpos,
                                                     decreasing=FALSE),]
common.neg.Genes.Chr5$placehold <- c(0,
                                     0,
                                     0.04,
                                     0,
                                     0.04,
                                     0.08,
                                     0.12,
                                     0)



genes8.chr5.Plt <-   ggplot(data=common.neg.Genes.Chr5, aes(x=round(startpos,2),
                                                            y=placehold),
                                                            label=genes) +
              geom_point(color = "black",size=1.5,shape=25,fill='black') + 
              geom_text(aes(label=genes),hjust=1.2, vjust = 0.5,
                        size=1.8) +

    #            theme(aspect.ratio=1) +
    scale_y_continuous(name='',
                       limits=c(0,0.9)) +
    scale_x_continuous(name='Gene Start Position (Mb)',
                       breaks = pretty_breaks(n = 8),
                       limits=c(40,round(chrom.Data$chrom.Length[5]/1000000.,0))
                       ) +
     
    labs(title="Strongly Negatively Correlated Genes in Common between Prefrontal Cortex and Temporal Cortex") 

#    theme_minimal() + 
    theme_classic() + 
    theme(aspect.ratio=0.4) +
    theme(axis.line.x = element_line(colour = "black",size=0.25)) +
     theme(axis.line.y = element_line(colour = "white",size=0.25),               
           axis.ticks.y = element_blank()) +
#    theme(plot.title = '') + 
    theme(axis.title = element_text(color="black",
                                    size=10,
                                    margin = margin(t = 4, r = 4, b = 0, l = 0)
                                    )) +
    theme(axis.text.x = element_text(size=10,
                                     margin = margin(t = 4, r = 0, b = 0, l = 0)),
          axis.text.y = 'none') + 

annotate("text", x = 160,
             y = 0.5,
             label = "cd949340d2d8b03116818001a9139944", 
             parse=FALSE,
             color="gray30",
             size=1.0,
         angle=0)    +
     
     annotate("text", x = 160,
             y = 0.6,
             label = "Nearly overlapping positions have been \n displaced vertically for clarity.", 
             parse=FALSE,
             color="gray30",
             size=2.0,
         angle=0)    +
     
     annotate("text", x = 110,
             y = 0.42,
             label = c('Start Positions of the Eight Genes on Chromosome 5 in Common in both  Prefrontal Cortex and Temporal Cortex among the 200 Most Strongly Negatively Correlated Genes'), 
             parse=FALSE,
             color="black",
             size=3.5,
             fontface='bold')


genes8.chr5.Plt

# save plots to file
     
     # ggsave(c('start_positions_8_on_chr5.pdf'), 
     #        plot = genes8.chr5.Plt, device = NULL, path = NULL,
     #              scale = 1, width = 8, height = 4, units = c("in"),
     #              dpi = 1200, limitsize = TRUE)

@

There were \Sexpr{common.genes.Chr5.neg[[1]][1,2]} and \Sexpr{common.genes.Chr5.neg[[1]][2,2]} genes on Chromosome 5 in \Sexpr{common.genes.Chr5.neg[[1]][1,1]} cortex and \Sexpr{common.genes.Chr5.neg[[1]][2,1]} cortex, respectively that were among the 200 most strongly negatively {\textit {COMT}}-correlated genes. There were \Sexpr{length(common.genes.Chr5.neg[[2]])} genes in common in these two sets of \Sexpr{common.genes.Chr5.neg[[1]][1,2]} genes.\\


Here is the plot of the starting positions of those 8 genes:\\

\includegraphics{start_positions_8_on_chr5}\vspace{3em}

The file transcription_factors_shared8_chr5-coExpressed-genes.txt was produced by the web site genefriends.org. It shows transcription factors that are co\den expressed with the eight shared genes on Chromosome 5. The first line of the file shows that the transcription factor SLC30A9, is shared by 6 of these 8 genes.

<<>>=
# Dendrogram plots of the relations between the 8 shared genes on Chr 5
# For MR
MR.dat <- read.delim("LocLocMR.tbl")
MR.dat <- MR.dat[,2:9]
MR.dist <- as.dist(log10(MR.dat))
MR.hc <- hclust(MR.dist, method="complete")
plot (MR.hc, hang=-1)
# For COR
COR.dat <- read.delim("LocLocCOR.tbl")
COR.dat <- COR.dat[,2:9]
COR.dist <- as.dist(1 - COR.dat)
COR.hc <- hclust(COR.dist, method="complete")
plot (COR.hc, hang=-1)


@


\vspace{-1em}\hspace{2em}
{\tiny{Note: Chr 23 = X and Chr 24 = Y}}\\


Plot of Number of genes per chromosome by chromosome length\\
\begin{figure}[H]
\begin{center}
<<label=plotChrcountvsLength, fig=TRUE,  echo = FALSE, include=FALSE >>= , pdf=FALSE, eps=TRUE 

area.Plot <- list()

for (k in c(1,3,5,7)) { 
     kalt <- as.integer((k/2) + 0.5)
 
     ########## DEBUG
#     k <- c(1)
     ################
     raw.Chr.count <- matrix(rep(NA,72),ncol=3)
     raw.Chr.count <- as.data.frame(raw.Chr.count)
     colnames(raw.Chr.count) <- c('ChrLabel','Gene.Count','Chromosome.Length')
     raw.Chr.count$ChrLabel <- c(as.character(c(1:22)),'X','Y')
     raw.Chr.count$Chromosome.Length <- chrom.Data$chrom.Length/1000000.

     raw.Chr.count$Gene.Count <- c(table(area.onegene.List[[k]]$loc)[c(mapIndx[1:24])])
     corval <- round(cor(raw.Chr.count$Chromosome.Length,raw.Chr.count$Gene.Count,
                      method=c('pearson')),2)


numgenesvslength.Plt <-   ggplot(raw.Chr.count, aes(x=(Chromosome.Length),y=Gene.Count,
                                                     label=ChrLabel)) +
              geom_point(color = "blue",size=1.0) + 
              geom_text(aes(label=ChrLabel),hjust=.5, vjust=-.75,
                        size=2.5) +
              stat_smooth(method=lm,   # Add linear regression line
                se=FALSE,
                color="red",
                size = 0.5,
                fullrange=TRUE)  +  # Don't add shaded confidence region
    #            theme(aspect.ratio=1) +
    scale_y_continuous(name='Number of Genes',
                       limits=c(0,1.1*max(raw.Chr.count$Gene.Count))) +
    scale_x_continuous(name='Length of Chromosome (Mb)',
                       limits=c(25,275),
                       breaks = pretty_breaks(n = 8)) +
    ggtitle('Number of Genes by Chromosome versus Chromosome Length') + 
#    theme_minimal() + 
    theme_classic() + 
    theme(aspect.ratio=1/(gold.R^2)) +
    theme(axis.line = element_line(colour = "black",size=0.25)) +
    theme(plot.title = element_text(color="black",
                                    face="bold",
                                    size=10,
                                    hjust=0.5)) +
    theme(axis.title = element_text(color="black",
                                    size=10,
                                    margin = margin(t = 4, r = 4, b = 0, l = 0)
                                    )) +
    theme(axis.text.x = element_text(size=10,
                                     margin = margin(t = 4, r = 0, b = 0, l = 0)),
          axis.text.y = element_text(size=10,
                                     margin = margin(t = 0, r = 2, b = 0, l = 0))) + 
    annotate("text", x = c(50),
             y = c(1600),
             label = c(paste('r = ',toString(corval),sep='')),
             color="black",
             size=3) +
     
     annotate("text", x = c(52),
             y = c(1720),
             label = stand.Col.names[kalt],
             color="black",
             size=3)
  
area.Plot[[kalt]] <- numgenesvslength.Plt

area.Plot[[kalt]]

} # end area loop

# save plots to file
     
     # genesvlength <- paste('plot_Chrcount_vs_Length_',stand.Col.names[4],'.eps',sep='')
     #      setEPS()
     #      postscript(genesvlength,width=8,height=6)
     #      area.Plot[[4]]
     #      dev.off()


@

\includegraphics[width=\textwidth]{plot_Chrcount_vs_Length_Prefrontal.eps}\vspace{3em}
\includegraphics[width=\textwidth]{plot_Chrcount_vs_Length_Cerebellum.eps}\vspace{3em}
\includegraphics[width=\textwidth]{plot_Chrcount_vs_Length_Temporal.eps}\vspace{3em}
\includegraphics[width=\textwidth]{plot_Chrcount_vs_Length_Pons.eps}\vspace{3em}

\end{center}
\end{figure}

<<include=FALSE, echo=FALSE, results=hide>>=
# Histogram of top 200 +/- genes starting positions on Chromosome 22: the Chr that holds 
# MB-COMT

# Get the length of the COMT gene

comt.Specs <- getBM(attributes = c("illumina_humanref_8_v3", "hgnc_symbol",
                                         "chromosome_name", "start_position","end_position",
                                         "entrezgene"), 
                                         filters = "illumina_humanref_8_v3", 
                          values = as.character('ILMN_1810941'), mart = ensembl)
comt.Length <- round((comt.Specs$end_position - comt.Specs$start_position)/1000000.,3)

i <- c(4)

chr.22 <- subset(area.List.byGene[[i]],area.List.byGene[[i]]$loc=='22')

medr.Pos <- median(as.numeric(subset(chr.22,chr.22$corsign == '1')$Sample.r))
medr.Neg <- median(as.numeric(subset(chr.22,chr.22$corsign == '-1')$Sample.r))

# sign.bp <-  data.frame(direct=chr.22.pf$corsign,
#                                startLoc=chr.22.pf$bp)

phist <- ggplot(data=chr.22, aes(as.numeric(chr.22$bp))) + geom_histogram() +
     
     geom_vline(data=chr.22,aes(xintercept=as.numeric(prefront.Data$bp[1])),
                color='red') +
     stat_bin(binwidth=c(1))
     
     to_string <- as_labeller(c(`-1` = "negative", `1` = "positive"))
     
phista <- phist +  facet_wrap(~ corsign,nrow=2,labeller = to_string) +
          
     scale_y_continuous(name='Frequency',
                       limits=c(0,30)) +     
          
     theme_bw() +
     theme(strip.background=element_rect(fill="gray90")) +
     theme(strip.text = element_text(colour = 'black')) +
     
     labs(x = c("Gene Starting Position (Mb)"),
          y = c('Frequency'),
          title = c(paste('Distribution of Gene Transcription Start Positions \n',
                          stand.Col.names[i],sep=''))) +
     theme(axis.text=element_text(size=7),
        axis.title=element_text(size=9)) +
     theme(plot.title=element_text(size=10,
                                   hjust=0.5)) +
          
          annotate("text", x = 0.90*as.numeric(prefront.Data$bp[1]),
             y = c(28),
             label = "MB-italic(COMT)", 
             parse=TRUE,
             color="black",
             size=2)

 phista
     # save plots to file
     
     # hist.22 <- paste('histogram_start_positions_Chr22_',stand.Col.names[i],'.eps',sep='')
     #      setEPS()
     #      postscript(hist.22,width=8,height=6)
     #      phista
     #      dev.off()

# Plot correlation vs. starting position for all genes on Chr 22 

comt.Extent <- data.frame(xmin=(comt.Specs$start_position/1000000.), 
                          xmax = (comt.Specs$end_position/1000000.),   
                          ymin = -1.0, 
                          ymax = 1.0) 
 

cor.Vs.start <- ggplot(data=chr.22, aes(x=as.numeric(chr.22$bp),y=as.numeric(chr.22$Sample.r),
                                        color=chr.22$Sample.r)) +

          geom_point(size=0.75) +
     
     geom_rug(sides="r",alpha=1/2,size=0.25)   +

     geom_rect(data=comt.Extent,mapping=aes(xmin=xmin,
                                         ymin=ymin,
                                         xmax=xmax,
                                         ymax=ymax),
                    stat='identity',
                    fill='red',
                    alpha=c(0.85),inherit.aes = FALSE) +
     
     scale_color_gradient2(low = cbPalette[2], mid = "gray50",
               high = "blue", midpoint = 0, space = "Lab",
               na.value = "grey50", guide = FALSE,                            # "colorbar",
               limits=c(-1, 1)) +
     
     # geom_vline(data=chr.22,aes(xintercept=as.numeric(prefront.Data$bp[1])),
     #            color=muted('green'),size=0.4,
     #            linetype='dashed') +
     
     
     geom_hline(data=chr.22,aes(yintercept=medr.Pos),
                color='black',size=0.5,
                linetype='dotted') +
     
     geom_hline(data=chr.22,aes(yintercept=medr.Neg),
                color='black',size=0.5,
                linetype='dotted') +
     
          
     scale_y_continuous(name='Correlation Coefficient, r',
                       limits=c(-1,1)) +  
          
     theme_bw() +
     
     labs(color = "Correlation", size=9) +

     labs(x = c("Gene Starting Position (Mb)"),
          y = c('Correlation Coefficient, r'),
          title = c(paste('Correlation Coefficient vs Gene Start Position \n',
                          'on Chromosome 22: ',stand.Col.names[i],sep=''))) +
     theme(axis.text=element_text(size=7),
        axis.title=element_text(size=9)) +
     theme(plot.title=element_text(size=10,
                                   hjust=0.5)) +
     
     # theme(legend.text = element_text(colour="black", size=7))     +
     # 
     # theme(legend.title = element_text(colour="black", size=9))    +
          
          # annotate("text", x = 0.92*(as.numeric(comt.Specs$start_position/1000000.)),
          #    y = c(1.0),
          #    label = "MB-italic(COMT)", 
          #    parse=TRUE,
          #    color="black",
          #    size=2) +

annotate("text", x = 0.92*(as.numeric(comt.Specs$start_position/1000000.)),
             y = as.numeric(chr.22$Sample.r[which(chr.22$Symbol == 'COMT')]),
             label = "S-italic(COMT)", 
             parse=TRUE,
             color="black",
             size=2)  +

annotate("text", x = 51,
             y = -0.7,
             label = "cd949340d2d8b03116818001a9139944", 
             parse=FALSE,
             color="gray30",
             size=1.0,
         angle=-90)    +

annotate("text", x = 45,
             y = 1.0,
             label = "Note: dotted lines are medians.\n Red rect is extent of COMT gene.", 
             parse=FALSE,
             color="gray30",
             size=2.0)

cor.Vs.start


     # save plots to file pdf   - plots already saved
     
          ggsave(c(paste('corr_vs_start_positions_Chr22_',stand.Col.names[i],'.pdf',sep='')), plot =                   cor.Vs.start, device = NULL, path = NULL,
                  scale = 1, width = 8, height = 5, units = c("in"),
                  dpi = 300, limitsize = TRUE)


@

\begin{figure}
\begin{center}



\includegraphics[width=4cm, height=3cm]{histogram_start_positions_Chr22_Prefrontal.eps}\vspace{3em}
\includegraphics[width=4cm, height=3cm]{histogram_start_positions_Chr22_Cerebellum.eps}\vspace{3em}
\includegraphics[width=4cm, height=3cm]{histogram_start_positions_Chr22_Temporal.eps}\vspace{3em}
\includegraphics[width=4cm, height=3cm]{histogram_start_positions_Chr22_Pons.eps}\vspace{3em}

The next plots show for each brain area correlations plotted against starting positions for all measured genes on Chromosome 22. The dotted lines are median positive and negative correlations, and the vertical dashed line is the transcription start position for MB-{\textit {COMT}}. There do not appear to be any gaps either in the positive or the negative correlations near the position of the MB-{\textit {COMT}} gene.

\includegraphics[width=4cm, height=3cm]{corr_vs_start_positions_Chr22_Prefrontal.pdf}\vspace{3em}
\includegraphics[width=4cm, height=3cm]{corr_vs_start_positions_Chr22_Cerebellum.pdf}\vspace{3em}
\includegraphics[width=4cm, height=3cm]{corr_vs_start_positions_Chr22_Temporal.pdf}\vspace{3em}
\includegraphics[width=4cm, height=3cm]{corr_vs_start_positions_Chr22_Pons.pdf}\vspace{3em}

\end{center}
\end{figure}

<<results=tex>>=
# Use the hypergeometric distribution to determine the probability that 8 of 21 genes that were in the top 200 negatively correlated genes in Temporal Cortex on Chr 5, would also show up among the (partially different) 21 genes on Chr 5 in Prefrontal cortex.
          
# Number of genes measured in full sample on Chr 5
          
     num.Genes.neg.Chr5$total[1] <- dim(subset(prefront.Data.onegene,prefront.Data.onegene$loc == '5'))[1] 
     num.Genes.neg.Chr5$total[2] <- dim(subset(tempor.Data.onegene,tempor.Data.onegene$loc == '5'))[1]
     num.Genes.neg.Chr5$common[1] <- length(common.genes.Chr5.neg[[2]])
     num.Genes.neg.Chr5$common[2] <- length(common.genes.Chr5.neg[[2]])
     
     # Of the 20 genes in the top 200 negatively correlated genes in Prefrontal Cortex on Chromosome 5, how many of those were also measured in Temporal Cortex? In other words, if a particular gene were among the set of 20 in PfCtx, it could not possibly also be among the set of 21 in TempCtx unless it was in the set of all genes measured in TempCtx.
     
# poss.Matches shows that all 20 of the genes in the top set in PfCtx on Chr 5 were also measured in TempCtx.
          poss.Matches <- length(match(pf.Neg[5,1:20],tempor.Data.onegene$Symbol))
     
     # Genes measured in Prefrontal on Chr 5
     genes.Chr5.pf <- subset(prefront.Data.onegene,prefront.Data.onegene$loc == '5')  # n = 715
     genes.Chr5.tm <- subset(tempor.Data.onegene,tempor.Data.onegene$loc == '5')    # n = 729

# 567 genes were measured both in PfCtx and TempCtx     
     same.Measured.pftm  <- intersect(genes.Chr5.pf$Symbol,genes.Chr5.tm$Symbol)
     num.genes.Common.pftm <- length(same.Measured.pftm)   # n = 567
     
# Number of ways to choose 21 genes from 715 genes meqasured on Chr 5 in Prefrontal
     A.pf <- 20
     B.pf <- (num.Genes.neg.Chr5$total[1] - A.pf)
     k.pf <- c(8:A.pf) #number of matching genes 8 or more
     
     # num.Choose.pf = 383288337264708946651341363588328903560
     num.Choose.pf <- chooseZ((A.pf + B.pf),A.pf)
     
# Number of ways to choose 21 genes from 729 genes meqasured on Chr 5 in Temporal
     A.tm <- 21
     B.tm <- (num.Genes.neg.Chr5$total[2] - A.tm)
     k.tm <- c(8:A.tm) #number of matching genes  8 or more
     
     # num.Choose.pf = 19170760017547961871654036186294130436130
     num.Choose.tm <- chooseZ((A.tm + B.tm),A.tm)

# What is the probability that both of these samples of genes of sizes 20 and 21, respectively, would contain 8 or more genes in common? Keep in mind that while 715 genes were measured in PfCtx and 729 in TempCtx, only 567 genes were measured in both places. So there are genes that could show up in the sample of 20 from PfCtx that could not show up in the sample of 21 from TempCtx and vice versa.

     # Once the 20 have been specified from PfCtx, how many different combinations of 8 genes are possible in the set of 20 genes that were specified in PfCtx?

     # 125970 different sets of 8 genes any one of which could be the one that is also in the set of 21 from TempCtx. But it should be 8 or more.     
     comb.8ormore.20.pf <- as.bigq(chooseZ(A.pf,k.pf)) 
     
      # Once the 21 have been specified from TempCtx, how many different combinations of 8 genes are possible in the set of 21 genes that were specified in TempCtx?

     # 203490 different sets of 8 genes any one of which could be the one that is also in the set of 20 from PfCtx.     
     comb.8ormore.21.tm <- as.bigq(chooseZ(A.tm,k.tm))  
     
     # If there are 383288337264708946651341363588328903560 ways to choose 20 genes randomly from 715 genes, and if for each of these ways there are 125970 different sets of 8 genes, nnn sets of 9 genes, nnn sets of 10 genes, etc., that increases the possibility that any set of 8 or 9 or 10 etc genes will overlap in both areas because it could be this set of 8 or that set of 8 or that set of 8, etc. Therefore, multiply the probability of getting a particular set of 20 genes by the number of different sets of 8 that could match in that set. Do this for all numbers from 8 to 20 and sum the probabilities.
     
     prob.8ormore.20.matchpf <- asNumeric(sum(comb.8ormore.20.pf*(1.00/(num.Choose.pf))))
     
     # Same logic for TempCtx
     
     prob.8ormore.21.matchtm <- asNumeric(sum(comb.8ormore.21.tm*(1.00/(num.Choose.tm))))
          
@


% {\bfseries {Using the hypergeometric distribution to test for randomness in the number of probes shared in common between the reference area and another area.}}\\
% 
% Testing for probe matches between a reference and a test brain area involves the {\bfseries {hypergeometric}} distribution.\\ The computation of probabilities when sampling without replacement is based on the following pdf:
% 
% \href{http://people.wku.edu/david.neal/109/Unit2/SamplingWO.pdf}{c('MATH 109 Sampling without Replacement)}
% 
% Here is the description of the calculation: \\
% 
% {\bfseries {Sampling Without Regard to Order}}\\
% Now  suppose  we  have  a  population  of N elements  that  are  divided  into  two  types: Type I  which has A elements,  and Type II which has B elements, where $A + B == N$.\\  
% 
% For  example,  a  standard  deck  of  $N == 52$  playing  cards  can  be  divided  in  many  ways. Type  I  could  be  “Hearts”  and  Type  II    could  be  “All  Others.”    Then  there  are   $A == 13$ Hearts and  $B == 39$ Others.\\
% 
% In analogy to the genes/probes problem, $N == 20,000$ probes,  $A == 50$ or 200, as in the top 50 or the top 200 most strongly positively/negatively {\textit {COMT}}-correlated probes. Thus B is either 19,950 ($A == 50 $) or B is 19,800 ( $A == 200$). 
% 
% There are two other parameters: $n == $the number of probes randomnly sampled without replacement, and  $k = $ the number of negatively correlated genes in the sample of size n that also are contained in A. The calculation for the probability that a sample of size n will contain k negatively correlated genes:\\
% $$
% p = \frac{\binom{A,k}*\binom{B,(n-k)}}{\binom{N,n}}
% $$


<<include=FALSE, echo=FALSE, results=tex>>=
################################################
### Select the top 200 by p-value to determine which genes expression levels (by chromosome) are most highly correlated with COMT expression.
################################################


# These are ordered by pvalue regardless of sign
data.by.Pval.area <- list()
data.by.Pval.area[[1]] <- prefront.by.Pval
data.by.Pval.area[[2]] <- cbell.by.Pval
data.by.Pval.area[[3]] <- tempor.by.Pval
data.by.Pval.area[[4]] <- pons.by.Pval

n <- c(200)     # sample of 200 genes

summ.Sign.area <- matrix(rep(0,32),nrow=8)
summ.Sign.area <- data.frame(summ.Sign.area) 
colnames(summ.Sign.area) <- stand.Col.names

summ.Sign.area[3,] <- c(n)

mdat <- matrix(c(rep(0,(3*5)),0,rep(3,4),rep(0,(2*5)),0,rep(3,(1*4)),
                 0,rep(3,(1*4))),
                 nrow = 8, ncol=5, byrow=TRUE)


# summ.Sign.area <- data.frame(samp=rep(0,4),
#                              expect=rep(0,4),
#                              size=rep(200,4),
#                              prop.samp=rep(0,4),
#                              num.neg=rep(0,4),
#                              total=rep(0,4),
#                              prop.total=rep(0,4),
#                              Pval=rep(0,4))

# For each brain area, use the hypergeometric distribution to determine the probability of obtaining
# the observed number of negative correlations (or fewere) given the proportion of negative 
# correlations in the complete sample

for (j in 1:4)    {
     
     if (exists('prob.N')) {rm(prob.N)}

     ############ DEBUG
#     j <- c(1)
     ##################
          
total.Corsign.tab <- table(data.by.Pval.area[[j]]$corsign)
samp.Corsign.tab <- table(data.by.Pval.area[[j]]$corsign[1:200])

summ.Sign.area[1,j] <- samp.Corsign.tab[1]     # samp
summ.Sign.area[5,j] <- total.Corsign.tab[1]    # num.neg
summ.Sign.area[4,j] <- round(samp.Corsign.tab[1]/summ.Sign.area[3,j],3)


# Sampling without replacement

     num.Genes <- length(data.by.Pval.area[[j]]$Symbol)
     summ.Sign.area[6,j] <- num.Genes
     N <- num.Genes
     A <- total.Corsign.tab[1]   # number of genes with negative correlations in full sample
     B <- N - A         # number of genes with positive correlations

     summ.Sign.area[7,j] <- round(summ.Sign.area[5,j]/summ.Sign.area[6,j],3)
     summ.Sign.area[2,j] <- round(summ.Sign.area[3,j]*summ.Sign.area[7,j],1)
     

# prob.N will hold the discrete probability distribution for k matches from a sample size of n = 200.


#     prob.N[k+1] <- (chooseMpfr(A,k)*chooseMpfr(B,(n-k)))/chooseMpfr(N,n)
     
     # Use built in hypergeometric distribution in R
     prob.N <- log10(phyper(samp.Corsign.tab[1],A,B,200,lower.tail=TRUE,log.p=FALSE))

summ.Sign.area[8,j] <- prob.N

}

row.names(summ.Sign.area) <- c('Number of negative correlations',
                              'Expected number of negative correlations',
                              'Sample size',
                              'Proportion of negative correlations: sample',
                              'Total number of negative correlations',
                              'Total number of genes',
                              'Proportion negative correlations: total',
                              'Log10(probability)')

summ.Sign.area.tab <- xtable(summ.Sign.area,
                             caption=c(paste('Observed, expected number of negative correlations and associated hypergeometric p-values by brain area for the 200 genes whose '," \\textit{COMT}",
' expression correlations had the smallest p values.',sep='')),
                             digits=mdat,
                              label=c('tab:hypergeom'))

# the table has been saved
print.xtable(summ.Sign.area.tab,
                         file=paste('top_200_ranked_by_pval_hypergeom.tex',sep=''),
                         type='latex',
                         floating=FALSE,
                         caption.placement='top',
                         tabular.environment='longtable',
                         caption.width ='0.5\\textwidth',
                         hline.after=c(-1,0,nrow(summ.Sign.area.tab)),
                         include.rownames=TRUE,
                         print.results=TRUE,
                         booktabs=TRUE,
                         comment=TRUE,
                         digits=mdat
                         )


@

The analysis of the proportion of negative correlations among the 200 genes with the smallest p-values showed that for all four brain areas, the observed number of negative correlations was significantly smaller (all p-values $< 10^{-30}$) than would have been expected based on the proportion of negative p-values in the total sample. In fact, while approximately 62\% of the correlations in the complete sample were negative, no more than 22\% of the correlations were negative among the 200 genes whose correlations with MB-{\textit {COMT}} were smallest.\\

This is in keeping with previous work that has shown that the strongest co-expressed genes tend to have positive correlations (need ref).\\

\input{top_200_ranked_by_pval_hypergeom}  % if \input doesn't work, use \include
%\include{top_200_ranked_by_pval_hypergeom}



<<results=hide>>=
# Get the distributions of + and - correlations, positive-only, and negative-only for the 
# onegene data by brain area

stand.Col.names.aug <- c(paste(stand.Col.names[1],' Cortex',sep=''),
                         paste(stand.Col.names[2],'',sep=''),
                         paste(stand.Col.names[3],' Cortex',sep=''),
                         paste(stand.Col.names[4],'',sep=''))


#for (b in 1:4)   {
     
     ############## DEBUG
     b <- c(1)
     ####################

 phisto <- ggplot(data=area.onegene.List[[b]], aes(as.numeric(area.onegene.List[[b]]$Sample.r))) +    #          geom_density(stat='density',fill='gray90') +
          
          
          stat_density(data = area.onegene.List[[b]], 
                       aes(as.numeric(area.onegene.List[[b]]$Sample.r)),geom = "area",
                       position = "stack", ..., bw = "nrd0", adjust = 1, kernel = "gaussian",
                       n = 1024, trim = FALSE, na.rm = FALSE, show.legend = NA,
                       inherit.aes = TRUE) +
    
     scale_x_continuous(name=c(paste("Correlation of expression with "," \\textit{COMT}",sep='')),
                               limits=c(-1.0,1.0)) +
          
     theme_bw() +
     theme(strip.background=element_rect(fill="gray70")) +
     theme(strip.text = element_text(colour = 'black')) +
     
     labs(x = c(paste("Correlation of expression with "," \\textit{COMT}",sep='')),
          y = c('Frequency'),
          title = c(paste('Distribution of Correlation Coefficients in ',stand.Col.names.aug[b],sep=''))) +
     theme(axis.text=element_text(size=7),
        axis.title=element_text(size=9)) +
     theme(plot.title=element_text(size=10,
                                   hjust=0.5)) 
          
          # annotate("text", x = 0.90*as.numeric(prefront.Data$bp[1]),
          #    y = c(28),
          #    label = "MB-italic(COMT)", 
          #    parse=TRUE,
          #    color="black",
          #    size=2)
     
     phisto

#} # end area loop

# phista
     # save plots to file
     
     # hist.22 <- paste('histogram_start_positions_Chr22_',stand.Col.names[i],'.eps',sep='')
     #      setEPS()
     #      postscript(hist.22,width=8,height=6)
     #      phista
     #      dev.off()







@


<<label=top10percent, echo=FALSE, results=tex>>=
################################################
### Select the top 200 by p-value to determine which genes expression levels (by chromosome) are most highly correlated with COMT expression.
### Done separately for positive and negative correlations
################################################

total.Corsign.tab <- table(prefront.by.Pval$corsign)
samp.Corsign.tab <- table(prefront.by.Pval$corsign[1:200]) 



##### Positive correlations with COMT expression only #####################
full.Count <- table(manhat.Posr$CHR)
order.by.P.pos <- manhat.Posr[order(manhat.Posr$P), ]
num.Pos <- dim(order.by.P.pos)[1]
ten.percent.Pos <- floor(0.10*num.Pos)
top.10percent.pos <- order.by.P.pos[1:ten.percent.Pos, ]
top10.pos.Count <- table(top.10percent.pos[,1])

# scaled.Props <- as.numeric(full.Count)/num.Pos
# scaled.top10.Props <- as.numeric(top10.pos.Count)/sum(as.numeric(top10.pos.Count))

## This scales the number of probes in the top 10% inversely by the fitted number of probes from the regression of number of probes by chromosome length. It also preserves the absolute number of probes found in the top 10% (~886)
fit.inverse.Scaled <- as.numeric(top10.pos.Count)/(adjust.By.fit[1:23]/sum(adjust.By.fit[1:23]))
fit.inverse.Scaled <- round((fit.inverse.Scaled*(sum(top10.pos.Count)/sum(fit.inverse.Scaled))),0)


# ratio.top10.pos <- data.frame(ratio=scaled.top10.Props/scaled.Props[1:23])
# ratio.top10.pos$chr <- c(1:23)
# ratio.top10.pos <- ratio.top10.pos[c(2,1)]
# scaled.Ratio <- data.frame(prop=ratio.top10.pos[,2]/sum(ratio.top10.pos[,2]))
# scaled.Ratio$chr <- c(1:23)
# scaled.Ratio$chr <- scaled.Ratio[c(2,1)]
# 
# num2get <- top10.pos.Count*scaled.Ratio$prop
num2get2 <- data.frame(n = as.numeric(fit.inverse.Scaled))
num2get2$chr <- as.numeric(c(1:23))
num2get2 <- num2get2[c(2,1)]

hold.pos <- data.frame(CHR=rep(NA,sum(num2get2$n)),
                       BP=rep(NA,sum(num2get2$n)),
                       P=rep(NA,sum(num2get2$n)),
                       GENE=rep(NA,sum(num2get2$n))
)
hold.pos$GENE <- as.character(hold.pos$GENE)
hold.pos$CHR <- as.numeric(hold.pos$CHR)
hold.pos$P <- as.numeric(hold.pos$P)

### hold.pos holds the top 883 positively correlated genes inversely weighted for the number of probes per # chromosome
### So the choice of the top genes is within chromosome, but the number of genes is inversely normalized by the fitted number of probes for that chromosome as regressed against chromosome length as well as the absolute rank of those genes against all the other genes
lims.Count <- matrix(c(0,0),nrow=1)                               
for (ig in 1:23) {
  lims.Count[1] <- lims.Count[2] + 1
  lims.Count[2] <- lims.Count[1] + num2get2$n[ig] - 1
  hold.pos[lims.Count[1]:lims.Count[2],1:4] <-data.frame(subset(manhat.Posr,manhat.Posr$CHR == ig)[1:num2get2$n[ig], ])
}

colnames(hold.pos) <- c('CHR','BP','P','GENE')

### Put this into a latex table sorted by chromosome number

top.Pos.ltx <- latex(hold.pos,file='top.Pos_genes.tex',
                      insert.top=('Top positively correlated genes normalized for number of probes per chromosome ordered by P value within chromosome'),
                      booktabs=TRUE,
                      label=c('top.Pos'),
#                      cgroup = c('Genes'),
#                      n.cgroup = c(4),
                      na.blank = TRUE,
                      vbar = FALSE,
                      longtable=TRUE,
                      table.env=FALSE,
                      continued=c('Top positively correlated genes continued'),
                      first.hline.double = TRUE,
                      size=c('tiny'),
                      append=FALSE
                      )
top.Pos.ltx

### Put this into a latex table sorted by p-value
hold.pos.byP <- hold.pos[order(hold.pos$P),]
hold.pos.byP$GENE <- as.character(hold.pos.byP$GENE)

top.PosbyP.ltx <- latex(hold.pos.byP,file='top.Pos_genes_by_P.tex',
                      insert.top=('Top positively correlated genes normalized for number of probes per chromosome ordered by P-value'),
                      booktabs=TRUE,
                      label=c('top.PosP'),
#                      cgroup = c('Genes'),
#                      n.cgroup = c(4),
                      na.blank = TRUE,
                      vbar = FALSE,
                      longtable=TRUE,
                      table.env=FALSE,
                      continued=c('Top positively correlated genes continued'),
                      first.hline.double = TRUE,
                      size=c('tiny'),
                      append=FALSE
                      )
top.PosbyP.ltx

############ End positive only ########################
  
##### Negative correlations with COMT expression only #####################
full.Count <- table(manhat.Negr$CHR)
order.by.P.neg <- manhat.Negr[order(manhat.Negr$P), ]
num.Neg <- dim(order.by.P.neg)[1]
ten.percent.Neg <- floor(0.10*num.Neg)
top.10percent.neg <- order.by.P.neg[1:ten.percent.Neg, ]
top10.neg.Count <- table(top.10percent.neg[,1])

scaled.Props <- as.numeric(full.Count)/num.Pos
scaled.top10.Props <- as.numeric(top10.neg.Count)/sum(as.numeric(top10.neg.Count))

## This scales the number of probes in the top 10% inversely by the fitted number of probes from the regression of number of probes by chromosome length. It also preserves the absolute number of probes found in the top 10% (~886)
fit.inverse.Scaled <- as.numeric(top10.neg.Count)/(adjust.By.fit[1:23]/sum(adjust.By.fit[1:23]))
fit.inverse.Scaled <- round((fit.inverse.Scaled*(sum(top10.neg.Count)/sum(fit.inverse.Scaled))),0)


# ratio.top10.neg <- data.frame(ratio=scaled.top10.Props/scaled.Props[1:23])
# ratio.top10.neg$chr <- c(1:23)
# ratio.top10.neg <- ratio.top10.neg[c(2,1)]
# scaled.Ratio <- data.frame(prop=ratio.top10.neg[,2]/sum(ratio.top10.neg[,2]))
# scaled.Ratio$chr <- c(1:23)
# scaled.Ratio <- scaled.Ratio[c(2,1)]
# 
# num2get <- top10.neg.Count*scaled.Ratio$prop
num2get2 <- data.frame(n = as.numeric(fit.inverse.Scaled))
num2get2$chr <- as.numeric(c(1:23))
num2get2 <- num2get2[c(2,1)]

hold.neg <- data.frame(CHR=rep(NA,sum(num2get2$n)),
                               BP=rep(NA,sum(num2get2$n)),
                               P=rep(NA,sum(num2get2$n)),
                               GENE=rep(NA,sum(num2get2$n))
)
hold.neg$GENE <- as.character(hold.neg$GENE)
manhat.Negr$GENE <- as.character(manhat.Negr$GENE)
hold.neg$CHR <- as.numeric(hold.neg$CHR)
hold.neg$P <- as.numeric(hold.neg$P)

### hold.neg holds the top 909 positively correlated genes weighted inversely for the number of probes per chromosome as determined from the fitted value when number of probes is regressed against chr length.
### So the choice of the top genes is within chromosome, but the number of genes inversely reflects the fitted number of probes used for that chromosome as well as the absolute rank of those genes against all the other genes
lims.Count <- matrix(c(0,0),nrow=1)                               
for (ig in 1:23) {
  lims.Count[1] <- lims.Count[2] + 1
  lims.Count[2] <- lims.Count[1] + num2get2$n[ig] - 1
  hold.neg[lims.Count[1]:lims.Count[2],1:4 ] <-data.frame(subset(manhat.Negr,manhat.Negr$CHR == ig)[1:num2get2$n[ig], ])
}

colnames(hold.neg) <- c('CHR','BP','P','GENE')


### Put this into a latex table sorted by chromosome number
top.Neg.ltx <- latex(hold.neg,file='top.Neg_genes.tex',
                      insert.top=('Top negatively correlated genes normalized for number of probes per chromosome ordered by P-value within chromosome'),
                      booktabs=TRUE,
                      label=c('top.Neg'),
#                      cgroup = c('Genes'),
#                      n.cgroup = c(4),
                      na.blank = TRUE,
                      vbar = FALSE,
                      longtable=TRUE,
                      table.env=FALSE,
                      continued=c('Top negatively correlated genes continued'),
                      first.hline.double = TRUE,
                      size=c('tiny'),
                      append=FALSE
                      )
top.Neg.ltx

### Put this into a latex table sorted by p-value
hold.neg.byP <- hold.neg[order(hold.neg$P),]
hold.neg.byP$GENE <- as.character(hold.neg.byP$GENE)

top.NegbyP.ltx <- latex(hold.neg.byP,file='top.Neg_genes_by_P.tex',
                      insert.top=('Top negatively correlated genes normalized for number of probes per chromosome ordered by P-value'),
                      booktabs=TRUE,
                      label=c('top.NegP'),
#                      cgroup = c('Genes'),
#                      n.cgroup = c(4),
                      na.blank = TRUE,
                      vbar = FALSE,
                      longtable=TRUE,
                      table.env=FALSE,
                      continued=c('Top positively correlated genes continued'),
                      first.hline.double = TRUE,
                      size=c('tiny'),
                      append=FALSE
                      )
top.NegbyP.ltx

############ End negative only ########################

@


<<include=FALSE, echo=FALSE, results=tex>>=
dim.areas <- matrix(c(dim(prefront.Data)[1],
                    dim(cbell.Data)[1],
                    dim(tempor.Data)[1],
                    dim(pons.Data)[1]),
                    nrow=4)

have.ENTREZ <- data.frame(indpf=c(1:dim.areas[1]),
                          ENTREZIDpf=rep(NA,dim.areas[1]),
                          ILMNpf=prefront.Data$Record,
                          indcb=c(1:dim.areas[1]),
                          ENTREZIDcb=rep(NA,dim.areas[2]),
                          ILMNcb=cbell.Data$Record,
                          indtm=c(1:dim.areas[1]),
                          ENTREZIDtm=rep(NA,dim.areas[3]),
                          ILMNtm=tempor.Data$Record,
                          indpo=c(1:dim.areas[1]),
                          ENTREZIDpo=rep(NA,dim.areas[4]),
                          ILMNpo=pons.Data$Record
                          )

# First determine which rows have the loc(Chromosome) listed as 'Un'. That is done below with
# the variables where.Un.pf, where.Un.cb, where.Un.tm, where.Un.po

# On an area by area basis separately, retrieve the ENTREZIDs for each Illumina probe.
have.Ent.pf <-na.omit(unlist(mget(x = prefront.Data$Record,envir=illuminaHumanv2ENTREZID)))   # n = 18724 of 20,000
have.Ent.cb <- na.omit(unlist(mget(x = cbell.Data$Record,envir=illuminaHumanv2ENTREZID)))      # n = 18726 of 20,000
have.Ent.tm <- na.omit(unlist(mget(x = tempor.Data$Record,envir=illuminaHumanv2ENTREZID)))     # n = 18698 of 20,000
have.Ent.po <- na.omit(unlist(mget(x = pons.Data$Record,envir=illuminaHumanv2ENTREZID)))       # n = 18713 of 20,000

# eliminate duplicates - these vectors show the unique ENTREZIDs in each brain area's data
# There are duplicates because there can be multiple ILMN probes for the same gene (ENTREZID)

############# Don't eliminate duplicates because the retention of rows will be done on the basis
############# of Illumina probe IDs which are unique
# notdups.pf <- which(!duplicated(have.Ent.pf))
# have.Ent.pf <- have.Ent.pf[c(notdups.pf),1]     
# 
# notdups.cb <- which(!duplicated(have.Ent.cb))
# have.Ent.cb <- have.Ent.cb[c(notdups.cb),1]
# 
# notdups.tm <- which(!duplicated(have.Ent.tm))
# have.Ent.tm <- have.Ent.tm[c(notdups.tm),1]
# 
# notdups.po <- which(!duplicated(have.Ent.po))
# have.Ent.po <- have.Ent.po[c(notdups.po),1]

entrez.By.area <- data.frame(num.entrez=c(length(have.Ent.pf),
                                          length(have.Ent.cb),
                                          length(have.Ent.tm),
                                          length(have.Ent.po)),
                             miss.entrez=c((20000 - length(have.Ent.pf)),
                                           (20000 -length(have.Ent.cb)),
                                           (20000 -length(have.Ent.tm)),
                                           (20000 -length(have.Ent.po)))
)

colnames(entrez.By.area) <- c('Number of Rows with ENTREZIDs','Number of Rows Missing ENTREZIDs')
row.names(entrez.By.area) <- c('Prefrontal Cortex',
                              'Cerebellum',
                              'Temporal Cortical Wall',
                              'Pons')

entrez.Area.tab <- xtable(entrez.By.area,
                         caption='Number of Unique ENTREZIDs in the Expression data\n for Each Brain Area. ENTREZIDs retrieved using ILMN identifiers.')

print(entrez.Area.tab)
@

\Sexpr{entrez.Area.tab}\\


<<include=FALSE, echo=FALSE, results=tex>>=

# The vectors above hold only the rows with ENTREZIDs in each area.
# NAs have been eliminated, and there are no duplicates.

# Attach a column with the ENTREZIDs to each of the 20,000 rows data frames
# Don't eliminate the NAs
prefront.Data$ENTREZID <- unlist(mget(x = prefront.Data$Record,envir=illuminaHumanv2ENTREZID))   # n = 18724 without NA; 1276 with NA
cbell.Data$ENTREZID <- unlist(mget(x = cbell.Data$Record,envir=illuminaHumanv2ENTREZID))      # n = 18726 withput NA, 1274 with NA
tempor.Data$ENTREZID <- unlist(mget(x = tempor.Data$Record,envir=illuminaHumanv2ENTREZID))     # n = 18698 without NA, 1302 with NA
pons.Data$ENTREZID <- unlist(mget(x = pons.Data$Record,envir=illuminaHumanv2ENTREZID))       # n = 18713 without NA, 1287 with NA

# Use the Illumina Human ref 8 v 2 bead chip reference file to try to find additional ENTREZIDs
# data.frame illumina.Data

# Get the list of ILMN probes for each data.frame that do not have ENTREZIDs
no.Entrez.pf <- prefront.Data$Record[c(which(is.na(prefront.Data$ENTREZID)))]
no.Entrez.pf.indx <- which(is.na(prefront.Data$ENTREZID))

no.Entrez.cb <- cbell.Data$Record[c(which(is.na(cbell.Data$ENTREZID)))]
no.Entrez.cb.indx <- which(is.na(cbell.Data$ENTREZID))

no.Entrez.tm <- tempor.Data$Record[c(which(is.na(tempor.Data$ENTREZID)))]
no.Entrez.tm.indx <- which(is.na(tempor.Data$ENTREZID))

no.Entrez.po <- pons.Data$Record[c(which(is.na(pons.Data$ENTREZID)))]
no.Entrez.po.indx <- which(is.na(pons.Data$ENTREZID))

# Get the indices in the illumina.Data$ilmn vector for which the entry matches a probe in 
# no.Entrez.xx that does not have an ENTREZID attached

extra.ILMN.pf <- match(no.Entrez.pf,illumina.Data$ilmn)
extra.ILMN.cb <- match(no.Entrez.cb,illumina.Data$ilmn)
extra.ILMN.tm <- match(no.Entrez.tm,illumina.Data$ilmn)
extra.ILMN.po <- match(no.Entrez.po,illumina.Data$ilmn)


# The lengths of these vactors show that every ILMN with a missing ENTREZID has a match
# in the ilumina.Data$ilmn vector. This doesn't necessarily mean that the ENTREZID is there
# as well

# These hold the ENTREZIDs that were missing from the original data set, but were found in the Illumina data set
extra.Entrez.pf <- illumina.Data$entrez[c(extra.ILMN.pf)]
# num.NA(extra.Entrez.pf) = 0; all of the missing ENTREZIDs were recovered for prefrontal
extra.Entrez.cb <- illumina.Data$entrez[c(extra.ILMN.cb)]
# num.NA(extra.Entrez.cb) = 0; all of the missing ENTREZIDs were recovered for cerebellum
extra.Entrez.tm <- illumina.Data$entrez[c(extra.ILMN.tm)]
# num.NA(extra.Entrez.cb) # = 0; all of the missing ENTREZIDs were recovered for temporal
extra.Entrez.po <- illumina.Data$entrez[c(extra.ILMN.po)]
# num.NA(extra.Entrez.cb) # = 0; all of the missing ENTREZIDs were recovered for pons

# a. Set up a correspondence matrix that holds the index in the Illumina file of the probes for which there was not an ENTREZID in the <area>.Data$ENTREZID column
# b. With the index in the Illumina data file that has a probe ID that matches one listed as not having an ENTREZID (a.)
correspond.Data.ILMN.pf <- matrix(c(no.Entrez.pf.indx,extra.ILMN.pf),
                               ncol=2)
correspond.Data.ILMN.cb <- matrix(c(no.Entrez.cb.indx,extra.ILMN.cb),
                               ncol=2)
correspond.Data.ILMN.tm <- matrix(c(no.Entrez.tm.indx,extra.ILMN.tm),
                               ncol=2)
correspond.Data.ILMN.po <- matrix(c(no.Entrez.po.indx,extra.ILMN.po),
                               ncol=2)
corresp.Data.ILM <- list(correspond.Data.ILMN.pf,
                         correspond.Data.ILMN.cb,
                         correspond.Data.ILMN.tm,
                         correspond.Data.ILMN.po)


# For example, corresp.Data.ILM[[1]][1,1] = 7
# corresp.Data.ILM[[1]][1,2] = 6147
# Thus, prefront.Data$ENTREZID[7] has an ILMN of "ILMN_1683883" and is missing and ENTREZID
# illumina.Data[6147,] has an ILMN of "ILMN_1683883" and it has a corresponding entrez = 95
# The illumina.Data$entrez[6147] = 95 can be used to fill in the missing ENTREZID in
# prefront.Data$ENTREZID[7]

# use the indices in extra.ILMN.xx to fill in the missing ENTREZID values
#Both sides have lengths of 20000. There are NAs in te ENTREZID columns
prefront.Data$ENTREZID <- as.character(prefront.Data$ENTREZID)
illumina.Data$entrez <- as.character(illumina.Data$entrez)

prefront.Data$ENTREZID[c(corresp.Data.ILM[[1]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[1]][,2])]

cbell.Data$ENTREZID <- as.character(cbell.Data$ENTREZID)
cbell.Data$ENTREZID[c(corresp.Data.ILM[[2]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[2]][,2])]

tempor.Data$ENTREZID <- as.character(tempor.Data$ENTREZID)
tempor.Data$ENTREZID[c(corresp.Data.ILM[[3]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[3]][,2])]

pons.Data$ENTREZID <- as.character(pons.Data$ENTREZID)
pons.Data$ENTREZID[c(corresp.Data.ILM[[4]][,1])] <- illumina.Data$entrez[c(corresp.Data.ILM[[4]][,2])]

# All 20,000 rows in each areal data.frame have ENTREZIDs (no NAs)
# This means also that all Illumina probe IDs also have identifiers that are mapped to a gene (ENTREZID)
# All of the ENTREZIDs are unique - not duplicated.
# This doesn't mean that the set of ENTREZIDs for each <area>.Data data.frame is the same
# In other words, because the <area>.Data correlation files with 20,000 correlations were
# obtained ranked by the p-values of the correlations, and because there are more than
# 20,000 Illumina probes, the sets of probes do not have to correspond
num.NA(prefront.Data$ENTREZID)    # n = 510 NA
num.NA(cbell.Data$ENTREZID)   # n = 229 NA
num.NA(tempor.Data$ENTREZID)  # n = 45 NA
num.NA(pons.Data$ENTREZID)    # n = 237 NA


# Next, intersect on the basis of ENTREZID (which is necessary to look up missing chromosomes;
# the ones that are listed as 'Un'). This will store only the ENTREZIDs that are in common
# across all four brain areas


all.areas.ENTREZID <- intersect(pons.Data$ENTREZID,intersect(tempor.Data$ENTREZID,intersect(prefront.Data$ENTREZID,cbell.Data$ENTREZID)))    # length = 13027

# all.areas.ENTREZID now holds all of the ENTREZIDs shared across all four brain areas


# Before finding the set of common Illumina probes across all areas, first try to find the 
# missing Chromosomes for each <area>.Data separately.
# Leverage the fact that the set of Illumina probes differs across areas, and some could be
# missing a chromosome name in one area while the same probe has the Chromosome in another area.

# Get the union of all Illumina probes across areas. First extract the probes, entrezids 
# and chromosomes into a data frame for each area

illum.entr.chr.pf <- data.frame(illum=prefront.Data$Record,
                                entrez=prefront.Data$ENTREZID,
                                chr=prefront.Data$loc)
illum.entr.chr.cb <- data.frame(illum=cbell.Data$Record,
                                entrez=cbell.Data$ENTREZID,
                                chr=cbell.Data$loc)
illum.entr.chr.tm <- data.frame(illum=tempor.Data$Record,
                                entrez=tempor.Data$ENTREZID,
                                chr=tempor.Data$loc)
illum.entr.chr.po <- data.frame(illum=pons.Data$Record,
                                entrez=pons.Data$ENTREZID,
                                chr=pons.Data$loc)

# Next get the union of all Illumina probes across the four areas

union.Illum.pfcb <- union(illum.entr.chr.pf$illum,illum.entr.chr.cb$illum)   # length 22016
union.Illum.pfcbtm <- union(union.Illum.pfcb,illum.entr.chr.tm$illum)     # length 22151
union.Illum.all <- union(union.Illum.pfcbtm,illum.entr.chr.po$illum)   # length 22180
# There are 22180 different probes across all four areas

diff.Probe.num <- matrix(c(rep(0,6)),nrow=6)
# Get the number of probe differences between each area
diff.Probe.num[1] <- length(setdiff(illum.entr.chr.pf$illum,illum.entr.chr.cb$illum))
diff.Probe.num[2] <- length(setdiff(illum.entr.chr.pf$illum,illum.entr.chr.tm$illum))
diff.Probe.num[3] <- length(setdiff(illum.entr.chr.pf$illum,illum.entr.chr.po$illum))
diff.Probe.num[4] <- length(setdiff(illum.entr.chr.cb$illum,illum.entr.chr.tm$illum))
diff.Probe.num[5] <- length(setdiff(illum.entr.chr.cb$illum,illum.entr.chr.po$illum))
diff.Probe.num[6] <- length(setdiff(illum.entr.chr.tm$illum,illum.entr.chr.po$illum))

row.names(diff.Probe.num) <- c('Prefrontal Cortex vs. Ceberebellum',
                               'Prefrontal Cortex vs. Temporal Cerebral Wall',
                               'Prefrontal Cortex vs. Pons',
                               'Cerebellum vs. Temporal Cerebral Wall',
                               'Cerebellum vs. Pons',
                               'Temporal Cerebral Wall vs. Pons'
                               )
colnames(diff.Probe.num) <- c('Number of Illumina Probe Differences')

diff.Probe.tab <- xtable(diff.Probe.num,
                         caption='Number of Illumina Probe Differences Between Brain Areas:\n Base of 20,000 Probes per Area',digits=0)

print(diff.Probe.tab)

@

\Sexpr{diff.Probe.tab}\\


<<include=FALSE,echo=FALSE,results=tex>>=
############# ********** Compare the top 50 and top 200 +/- correlations in Prefrontal with those
### in the other three areas






@


<<echo=FALSE, include=FALSE, results=hide>>=
### Create a data.frame with all areas, but only those variables necessary to find the top N genes averaged across all four areas. Use Alexander's (1990) method for averaging correlations.

### The relevant variables are:
#### area: prefront, cbell, tempcort, pons
#### Chr number
#### Gene Symbol
#### Correlation of expression with COMT expressiomn in that area
#### P-value of correlation

# dimensions of data sets
dim.Area <- data.frame(area=c('prefront', 'cbell','tempor','pons'),
                       len=rep(0,4), wid=rep(0,4))
# prefrontal
dim.Area$len[1] <- dim(prefront.Meanbothr)[1]
dim.Area$wid[1] <- dim(prefront.Meanbothr)[2]

#cerebellum
dim.Area$len[2] <- dim(cbell.Data)[1]
dim.Area$wid[2] <- dim(cbell.Data)[2]

#temporal cortex
dim.Area$len[3] <- dim(tempor.Data)[1]
dim.Area$wid[3] <- dim(tempor.Data)[2]

#pons
dim.Area$len[4] <- dim(pons.Data)[1]
dim.Area$wid[4] <- dim(pons.Data)[2]

@

<<include=FALSE,echo=FALSE,results=hide>>=

all.Area.dat <- data.frame(areapf=rep(NA,dim.Area$len[1]),
                           chrpf=rep(NA,dim.Area$len[1]),
                           genepf=rep(NA,dim.Area$len[1]),
                           corrpf=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpf=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpf=rep(NA,dim.Area$len[1]),
                           areacb=rep(NA,dim.Area$len[1]),
                           chrcb=rep(NA,dim.Area$len[1]),
                           genecb=rep(NA,dim.Area$len[1]),
                           corrcb=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalcb=as.numeric(rep(NA,dim.Area$len[1])),
                           illumcb=rep(NA,dim.Area$len[1]),
                           areatc=rep(NA,dim.Area$len[1]),
                           chrtc=rep(NA,dim.Area$len[1]),
                           genetc=rep(NA,dim.Area$len[1]),
                           corrtc=as.numeric(rep(NA,dim.Area$len[1])),
                           pvaltc=as.numeric(rep(NA,dim.Area$len[1])),
                           illumtc=rep(NA,dim.Area$len[1]),
                           areapo=rep(NA,dim.Area$len[1]),
                           chrpo=rep(NA,dim.Area$len[1]),
                           genepo=rep(NA,dim.Area$len[1]),
                           corrpo=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpo=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpo=rep(NA,dim.Area$len[1])
                           )




prefront.Ess <- data.frame(area=rep('prefront',dim.Area$len[1]),
                      loc=prefront.Meanbothr$chr,
                      Symbol=prefront.Meanbothr$gene,
                      Sample.r=prefront.Meanbothr$corr,
                      Sample.p.r=prefront.Meanbothr$pval,
                      Record=prefront.Meanbothr$record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(prefront.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
prefront.Ess <- prefront.Ess[c(sort.Ind$ix),]


cbell.Ess <- data.frame(area=rep('cbell',dim.Area$len[1]),
                      loc=cbell.Data$loc,
                      Symbol=cbell.Data$Symbol,
                      Sample.r=cbell.Data$Sample.r,
                      Sample.p.r=cbell.Data$Sample.p.r.,
                      Record=cbell.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(cbell.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
cbell.Ess <- cbell.Ess[c(sort.Ind$ix),]


tempor.Ess <- data.frame(area=rep('tempor',dim.Area$len[1]),
                      loc=tempor.Data$loc,
                      Symbol=tempor.Data$Symbol,
                      Sample.r=tempor.Data$Sample.r,
                      Sample.p.r=tempor.Data$Sample.p.r.,
                      Record=tempor.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(tempor.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
tempor.Ess <- tempor.Ess[c(sort.Ind$ix),]


pons.Ess <- data.frame(area=rep('pons',dim.Area$len[1]),
                      loc=pons.Data$loc,
                      Symbol=pons.Data$Symbol,
                      Sample.r=pons.Data$Sample.r,
                      Sample.p.r=pons.Data$Sample.p.r.,
                      Record=pons.Data$Record)

# Sort by sign and magnitude of correlation
sort.Ind <- sort(pons.Ess$Sample.r,decreasing=TRUE,index.return=TRUE)
pons.Ess <- pons.Ess[c(sort.Ind$ix),]

all.Area.dat[,1:6] <- prefront.Ess
all.Area.dat[,7:12] <- cbell.Ess
all.Area.dat[,13:18] <- tempor.Ess
all.Area.dat[,19:24] <- pons.Ess

cols.Corr <- c(4,10,16,22)
cols.Gene <- c(3,9,15,21)

ind.Ill <- matrix(rep(NA,4*dim.Area$len[1]),ncol=4)
for (i in 1:dim.Area$len[1]) {
     
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumcb)) {
               ind.Ill[i,2] <- which(as.character(all.Area.dat$illumcb)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,2] <- c(NA)
     }         
               
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumtc)) {            ind.Ill[i,3] <- which(as.character(all.Area.dat$illumtc)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,3] <- c(NA)
     }         
               
     if (as.character(all.Area.dat$illumpf[i]) %in% as.character(all.Area.dat$illumpo)) {
          ind.Ill[i,4] <- which(as.character(all.Area.dat$illumpo)  == as.character(all.Area.dat$illumpf[i]))
     } else {
               ind.Ill[i,4] <- c(NA)
     } 
          
          }

ind.Ill[,1] <- seq(1,dim.Area$len[1],1)     

#### ******* In all.Area.dat, each area's columns, are sorted separately by area on the correlation. ind.Ill shows where each probe is (index) by area


# This orders the data independently in each brain area by a particular variable
# all.Area.dat[,1:6] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[1]]),decreasing=FALSE),c(1:6)]
# all.Area.dat[,7:12] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[2]]),decreasing=FALSE),c(7:12)]
# all.Area.dat[,13:18] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[3]]),decreasing=FALSE),c(13:18)]
# all.Area.dat[,19:24] <- all.Area.dat[order(as.character(all.Area.dat[,cols.Gene[4]]),decreasing=FALSE),c(19:24)]

@

<<include=FALSE, echo=FALSE, results=tex>>=
# Calculate average correlation with COMT expression of each probe's expression
# Use Alexander (1990) to average correlations
# ind.Ill holds the indices for cerebellum, temporal cortex and pons of each probe on prefrontal cortex.

hold.Corrs <- data.frame(illum=rep(NA,dim.Area$len[1]),
                         gene=rep(NA,dim.Area$len[1]),
                         corpf=rep(0,dim.Area$len[1]),
                         corcb=rep(0,dim.Area$len[1]),
                         cortc=rep(0,dim.Area$len[1]),
                         corpo=rep(0,dim.Area$len[1])
                         )

##### ***** The next code sorts hold.Corrs by the sorted correlations in the prefrontal cortex
##### ***** In other words, the correlations are no longer sorted separately by area, but ###### instead the probeID order in prefrontal cortex after having been sorted by pf
##### correlation determines the correlations shown in that row in the other three areas
# For example, just making up a scenario, whatever probeID has the second strongest expression correlation with COMT in prefrontal cortex might have a correlation of r=.65 in the cerebellum. That is the correlation that would show up in the second row for the cerebellum

hold.Corrs$illum <- all.Area.dat$illumpf
hold.Corrs$gene <- all.Area.dat$genepf
hold.Corrs$corpf <- all.Area.dat$corrpf
hold.Corrs$corcb <- all.Area.dat$corrcb[c(ind.Ill[,2])]
hold.Corrs$cortc <- all.Area.dat$corrtc[c(ind.Ill[,3])]
hold.Corrs$corpo <- all.Area.dat$corrpo[c(ind.Ill[,4])]

# average these four correlations and put them into a new column
# Use Alexander (1990) to average

ki <- c(4)
n.subj <- c(144,144,144,144)

# Calculate in parts then put together

sum.corr <- matrix(rep(0,dim.Area$len[1]),ncol=1)
for (l in 1:dim.Area$len[1]) {
     
     sum.corr[l] <-sum((((n.subj[1:4] - 1))/(sum(n.subj) - ki))*(hold.Corrs[l,3:6] + (hold.Corrs[l,3:6]*(1 - hold.Corrs[l,3:6]^2))/(2*(n.subj[1:4] - 3))))
     
hold.Corrs$avgCorr[l] <- sum.corr[l]
}

@

<<include=FALSE, echo=FALSE, results=tex>>=

## Leave columns sorted by correlation in prefrontal cortex

top200_pos_ordered_by_pf_corr <- xtable(hold.Corrs[1:cut.Part,],
                           caption=paste('Correlations of expression with COMT in each brain area for the ',cut.Part,' probes that show the strongest positive correlations in prefrontal cortex',sep=''))


write.table(hold.Corrs[1:cut.Part,],file=paste('top',cut.Part,'_pos_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,
            quote=FALSE)
write.table(hold.Corrs[1:cut.Part,1:3],file=paste('top',cut.Part,'_pos_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,
            quote=FALSE)



top200_neg_ordered_by_pf_corr <- xtable(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-200),],
                           caption=paste('Correlations of expression with COMT in each brain area for the ',cut.Part,' probes that show the strongest negative correlations in prefrontal cortex',sep=''))

# Note that these are written in reverse order because they are negative: 20,000:19800
write.table(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-200),],file=paste('top',cut.Part,'_neg_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,quote=FALSE)
write.table(hold.Corrs[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]-200),1:3],file=paste('top',cut.Part,'_neg_ordered_by_pf_corr.csv',sep=''),sep=', ',row.names = FALSE,quote=FALSE)


@



<<include=FALSE, echo=FALSE, results=tex>>=
# Tally the chromosome numbers of the top 200 + and top 200 - in each brain area separately
# Are (+) correlated genes more likely to be on the same chromosome than (-) correlated genes?
# Do this both for the top 200 as well as for all 20000 probes.
# Use the data.frame dfsort
# colnames(dfsort)
#[1] "chr"     "corsign" "freq"
# dfsort is already in tabular form

corsign.By.chr <- dfsort
corsign.By.chr$pm <- factor(rep(c('minus','plus'),each=24))
corsign.By.chr <- corsign.By.chr[,c(1,4,3)]

colnames(corsign.By.chr) <- c('chr','corsign','count')

xtabs.ChrCorsign <- xtabs(count ~ chr + corsign,data=corsign.By.chr)

chisq.ChrCorsign.out <- chisq.test(xtabs.ChrCorsign)
print(chisq.ChrCorsign.out)

@

The chi-square test of independence shows that the number of genes showing positive versus negative correlations with COMT is not independent of Chromosome number in prefrontal cortex.\\

Next, use the binomial distribution to determine if the distribution on Chr 22 where COMT is differs from the distribution on all other chromosomes.\\

<<include=FALSE, echo=FALSE, results=tex>>=
# First get the numbers of plus and minus correlations aggregated across all chromosomes except Chr 22.
# Get total probes/genes on Chr 22

pm.Sans22 <- c(rep(0,2))
pm.Sans22[1] <- sum(xtabs.ChrCorsign[,1]) - xtabs.ChrCorsign[22,1]
pm.Sans22[2] <- sum(xtabs.ChrCorsign[,2]) - xtabs.ChrCorsign[22,2]

counts.22 <- sum(xtabs.ChrCorsign[22,])
counts.Sans22 <- sum(pm.Sans22)

obs.Minus.22 <- xtabs.ChrCorsign[22,1]

p.minus.22 <- obs.Minus.22/counts.22


# probability of negative correlations across all chromosomes except Chr 22
p.minus <- pm.Sans22[1]/counts.Sans22

# get the binomial distribution with p = p.minus and the sample size of the number of probes on Chr 22
d.minus <- dbinom(seq(0,counts.22,1),counts.22,p.minus)

d.minus <- data.frame(num.minus = seq(0,counts.22,1),prob=d.minus)

# Now get the probability of xtabs.ChrCorsign[22,1] minuses or fewer given counts.22 probes. In this case
# p(k <= 286 minuses) with Binomial(N=19171, p = 0.63888)

cumul.d.minus <- sum(d.minus[1:(obs.Minus.22 + 1),2])

binom.test(obs.Minus.22, counts.22, p = p.minus,
           alternative = c("less"),
           conf.level = 0.95)

binom.test(obs.Minus.22, counts.22, p = p.minus,
           alternative = c("two.sided"),
           conf.level = 0.95)


# The proportion of negatively COMT-correlated genes in prefrontal cortex, 0.54806, is significantly lower than the proportion aggregated across all the other chromosomes, 0.63888.
@

The proportion genes with negative correlations mwith MB-COMT on Chr 22, \Sexpr{p.minus.22}, is signficantly lower than the proportion aggregated across all of the other chromosomes, \Sexpr{p.minus}.\\ 

<<include=FALSE, echo=FALSE, fig=TRUE, pdf=TRUE>>=

vcut <- data.frame(x1=(obs.Minus.22 + 0.5), x2=(obs.Minus.22 + 0.5), y1=-0.00075, y2=0.02)
p.low.d.minus <- subset(d.minus,d.minus$num.minus < (obs.Minus.22 + 1))

minus.plot <- ggplot() +
          
          geom_point(data=d.minus, aes(x=num.minus,y=prob,group=1),
                     size=0.6,color='blue',shape=1) +
     
          geom_point(data=p.low.d.minus, aes(x=num.minus,y=prob,group=1),
                     size=0.6,color='red',shape=1) +
     
          geom_segment(data=vcut, aes(x=x1,xend=x2,y=y1,yend=y2), color='red',size=0.5)  +
          
          scale_y_continuous(breaks = seq(0,0.05,0.01),
                             labels = comma(seq(0,0.05,0.01), digits = 2)) +
          
          scale_x_continuous(name='Number of Negative Correlations (k)',
                             limits=c(0,round((counts.22 + 5),0)),
                             breaks=seq(0,round((counts.22 + 5),0),200)) +
          
          theme_classic() +
          
          
          ggtitle('Probability of Negative Correlations Based on All Chromosomes Except Chr 22' ) +
          
          ylab('Probability density') + 
          theme(aspect.ratio=1/gold.R) + 
          theme(plot.title = element_text(color="black",
                                          size=8.5,
                                          hjust=0.5)) +
          theme(axis.title = element_text(color="black",
                                          size=10,
                                          vjust=1
          )) +

               theme(axis.text.x = element_text(size=8),
                axis.text.y = element_text(size=8)) +
          
          annotate("text", x = (obs.Minus.22 - 65),
                   y = 0.005,
                   label = c(paste('p(k < ',(obs.Minus.22 + 1),') = ',
                                   round(cumul.d.minus,8),sep='')),
                   color="black",
                   size=3.0)    +
     
          annotate("text", x = 0.10*(round((counts.22 + 5),0)),
                   y = 1.10*max(d.minus$prob),
                   label = c(paste('unique ID: ',prog.Name,sep='')),
                   parse=FALSE,
                   color="gray20",
                   size=1.5) 

file1.pdf <- c('p_binomial_mb_comt.pdf')
   ggsave(file1.pdf, plot = minus.plot, width = 8, height = 5.5)

minus.plot

@

%\includegraphics[width=0.5\textwidth]{p_binomial_comt_s.eps}\\

<<include=FALSE, echo=FALSE, results=tex>>=
#Get the mean and sd of the top 200 positives and negatives in each area

mean.sd.By.areaPos <- psych::describe(all.Area.dat[2:(cut.Part+1),cols.Corr])
mean.sd.By.areaNeg <- psych::describe(all.Area.dat[dim(hold.Corrs)[1]:(dim(hold.Corrs)[1]- cut.Part),cols.Corr])


@





<<include=FALSE, echo=FALSE, results=TEX>>= 
# Test the hypothesis that the rank order of the most negatively correlated genes changes more across brain area than do the rank orders of the most highly positively correlated genes.

# Rank the genes on their correlations separately by area, then compare the ranks of specific genes across areas to determine if there are greater differences among negatively correlated genes than among positively correlated genes.

### Do this with the all.Area.dat which has the strongest correlations in each brain area separately. Have to use ind.Ill to find out what those probes are in each area.

hold.Area.dat <- data.frame(areapf=rep(NA,dim.Area$len[1]),
                           chrpf=rep(NA,dim.Area$len[1]),
                           genepf=rep(NA,dim.Area$len[1]),
                           corrpf=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpf=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpf=rep(NA,dim.Area$len[1]),
                           areacb=rep(NA,dim.Area$len[1]),
                           chrcb=rep(NA,dim.Area$len[1]),
                           genecb=rep(NA,dim.Area$len[1]),
                           corrcb=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalcb=as.numeric(rep(NA,dim.Area$len[1])),
                           illumcb=rep(NA,dim.Area$len[1]),
                           areatc=rep(NA,dim.Area$len[1]),
                           chrtc=rep(NA,dim.Area$len[1]),
                           genetc=rep(NA,dim.Area$len[1]),
                           corrtc=as.numeric(rep(NA,dim.Area$len[1])),
                           pvaltc=as.numeric(rep(NA,dim.Area$len[1])),
                           illumtc=rep(NA,dim.Area$len[1]),
                           areapo=rep(NA,dim.Area$len[1]),
                           chrpo=rep(NA,dim.Area$len[1]),
                           genepo=rep(NA,dim.Area$len[1]),
                           corrpo=as.numeric(rep(NA,dim.Area$len[1])),
                           pvalpo=as.numeric(rep(NA,dim.Area$len[1])),
                           illumpo=rep(NA,dim.Area$len[1])
                           )
     
cols.Corr <- c(4,10,16,22)
cols.Gene <- c(3,9,15,21)     
     
hold.Area.dat[,1:6] <- all.Area.dat[order(all.Area.dat[,cols.Corr[1]],decreasing=TRUE),c(1:6)]
hold.Area.dat[,7:12] <- all.Area.dat[order(all.Area.dat[,cols.Corr[2]],decreasing=TRUE),c(7:12)]
hold.Area.dat[,13:18] <- all.Area.dat[order(all.Area.dat[,cols.Corr[3]],decreasing=TRUE),c(13:18)]
hold.Area.dat[,19:24] <- all.Area.dat[order(all.Area.dat[,cols.Corr[4]],decreasing=TRUE),c(19:24)]

@


<<include=FALSE, echo=FALSE, results=tex>>=
# now for the 200 genes with the largest negative correlations in Prefrontal Cortex, find their ranks in the other three areas



rank.Stab.neg <- matrix(rep(0,4*cut.Part),ncol=4)

# First do negative correlations
for (h in 1:cut.Part) {
     
     rank.Stab.neg[h,1] <-(20000 - (cut.Part -h))
     
     if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumcb)) {
          rank.Stab.neg[h,2] <- which(as.character(hold.Area.dat$illumcb) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,2] <-  c(NA)  
          
     }    
     
     if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumtc)) {
          rank.Stab.neg[h,3] <- which(as.character(hold.Area.dat$illumtc) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,3] <-  c(NA)  
          
     }
     
    if (as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]) %in% as.character(hold.Area.dat$illumpo)) {
          rank.Stab.neg[h,4] <- which(as.character(hold.Area.dat$illumpo) == as.character(hold.Area.dat$illumpf[(20000 - (cut.Part -h))]))
     
     } else {
       
          rank.Stab.neg[h,4] <-  c(NA)  
          
     }
     
}

colnames(rank.Stab.neg) <- c('rankpf','rankcb','ranktc','rankpo')
rank.Stab.neg <- data.frame(rank.Stab.neg)
rank.Stab.neg$illum <- hold.Area.dat$illumpf[(20000 - (cut.Part -1)):20000]
rank.Stab.neg$gene <- hold.Area.dat$genepf[(20000 - (cut.Part -1)):20000]
rank.Stab.neg <- rank.Stab.neg[,c(5,6,1:4)]

overlap.Area <- list()

# [[1]] pf vs cb
# [[2]] pf vs tc
# [[3]] pf vs po
# [[4]] cb vs tc
# [[5]] cb vs po
# [[6]] tc vs po

overlap.Area[[1]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$rankcb)
overlap.Area[[2]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$ranktc)
overlap.Area[[3]] <- intersect(rank.Stab.neg$rankpf,rank.Stab.neg$rankpo)
overlap.Area[[4]] <- intersect(rank.Stab.neg$rankcb,rank.Stab.neg$ranktc)
overlap.Area[[5]] <- intersect(rank.Stab.neg$rankcb,rank.Stab.neg$rankpo)
overlap.Area[[6]] <- intersect(rank.Stab.neg$ranktc,rank.Stab.neg$rankpo)

perc.Overlap <- data.frame(compare=(rep(NA,6)),num=c(rep(0,6)),percentage=c(rep(0,6)),
                           n.base=c(rep(0,6)),ofn=c(rep(NA,6)))
perc.Overlap$compare <- c('prefrontal cortex vs. cerebellum',
                         'prefrontal cortex vs. temporal cortex',
                         'prefrontal cortex vs. pons',
                         'cerebellum vs. temporal cortex',
                         'cerebellum vs. pons',
                         'temporal cortex vs. pons')

for (g in 1:6) {
     
    perc.Overlap$n.base[g]  <- cut.Part - length(which(is.na(rank.Stab.neg[,g])))
     perc.Overlap$num[g]  <- length(overlap.Area[[g]]) 
    perc.Overlap$percentage[g]  <- paste(round(100*(perc.Overlap$num[g])/(perc.Overlap$n.base[g]),0),'%',sep='')
}

perc.Overlap.neg <- perc.Overlap
perc.Overlap.neg$ofn <- paste(perc.Overlap$num,' (',perc.Overlap$n.base,')',sep='')

colnames(perc.Overlap.neg) <- c('Comparison','number shared','Percentage','base n',
                                'Shared Genes (N)')
overlap.Neg <- xtable(perc.Overlap.neg[,c(1,5,3)],
                         caption=c('Of the genes with the strongest negative correlations with COMT expression,\n the percentage of genes found in both areas'))

overlap.Neg


@

<<include=FALSE, echo=FALSE, results=tex>>=
# now for the 200 genes with the largest positive correlations in Prefrontal Cortex, find their ranks in the other three areas


#cut.Part <- c(200)
rank.Stab.pos <- matrix(rep(0,4*cut.Part),ncol=4)

# Now do positive correlations
for (h in 1:cut.Part) {
     
     rank.Stab.pos[h,1] <- h
     
     if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumcb)) {
          rank.Stab.pos[h,2] <- which(as.character(hold.Area.dat$illumcb) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.pos[h,2] <-  c(NA)  
          
     }    
     
     if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumtc)) {
          rank.Stab.pos[h,3] <- which(as.character(hold.Area.dat$illumtc) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.pos[h,3] <-  c(NA)  
          
     }
     
    if (as.character(hold.Area.dat$illumpf[h]) %in% as.character(hold.Area.dat$illumpo)) {
          rank.Stab.pos[h,4] <- which(as.character(hold.Area.dat$illumpo) == as.character(hold.Area.dat$illumpf[h]))
     
     } else {
       
          rank.Stab.pos[h,4] <-  c(NA)  
          
     }
     
}



colnames(rank.Stab.pos) <- c('rankpf','rankcb','ranktc','rankpo')
rank.Stab.pos <- data.frame(rank.Stab.pos)
rank.Stab.pos$illum <- hold.Area.dat$illumpf[1:cut.Part]
rank.Stab.pos$gene <- hold.Area.dat$genepf[1:cut.Part]
rank.Stab.pos <- rank.Stab.pos[,c(5,6,1:4)]

overlap.Area <- list()

# [[1]] pf vs cb
# [[2]] pf vs tc
# [[3]] pf vs po
# [[4]] cb vs tc
# [[5]] cb vs po
# [[6]] tc vs po

overlap.Area[[1]] <- intersect(rank.Stab.pos$rankpf,rank.Stab.pos$rankcb)
overlap.Area[[2]] <- intersect(rank.Stab.pos$rankpf,rank.Stab.pos$ranktc)
overlap.Area[[3]] <- intersect(rank.Stab.pos$rankpf,rank.Stab.pos$rankpo)
overlap.Area[[4]] <- intersect(rank.Stab.pos$rankcb,rank.Stab.pos$ranktc)
overlap.Area[[5]] <- intersect(rank.Stab.pos$rankcb,rank.Stab.pos$rankpo)
overlap.Area[[6]] <- intersect(rank.Stab.pos$ranktc,rank.Stab.pos$rankpo)


perc.Overlap <- data.frame(compare=(rep(NA,6)),num=c(rep(0,6)),percentage=c(rep(0,6)),
                           n.base=c(rep(0,6)),ofn=c(rep(NA,6)))
perc.Overlap$compare <- c('prefrontal cortex vs. cerebellum',
                         'prefrontal cortex vs. temporal cortex',
                         'prefrontal cortex vs. pons',
                         'cerebellum vs. temporal cortex',
                         'cerebellum vs. pons',
                         'temporal cortex vs. pons')

for (g in 1:6) {
     
    perc.Overlap$n.base[g]  <- cut.Part - length(which(is.na(rank.Stab.pos[,g])))
     perc.Overlap$num[g]  <- length(overlap.Area[[g]]) 
    perc.Overlap$percentage[g]  <- paste(round(100*(perc.Overlap$num[g])/(perc.Overlap$n.base[g]),0),'%',sep='')
}

perc.Overlap.pos <- perc.Overlap
perc.Overlap.pos$ofn <- paste(perc.Overlap$num,' (',perc.Overlap$n.base,')',sep='')

colnames(perc.Overlap.pos) <- c('Comparison','number shared','Percentage','base n',
                                'Shared Genes (N)')
overlap.Pos <- xtable(perc.Overlap.pos[,c(1,5,3)],
                         caption=c('Of the genes with the strongest positive correlations with COMT expression,\n the percentage of genes found in both areas'))

overlap.Pos


@


% {\bfseries {Using the hypergeometric distribution to test for randomness in the number of probes shared in common between the reference area and another area.}}\\
% 
% Testing for probe matches between a reference and a test brain area involves the {\bfseries {hypergeometric}} distribution.\\ The computation of probabilities when sampling without replacement is based on the following pdf:
% 
% \href{http://people.wku.edu/david.neal/109/Unit2/SamplingWO.pdf}{c('MATH 109 Sampling without Replacement)}
% 
% Here is the description of the calculation: \\
% 
% {\bfseries {Sampling Without Regard to Order}}\\
% Now  suppose  we  have  a  population  of N elements  that  are  divided  into  two  types: Type I  which has A elements,  and Type II which has B elements, where $A + B == N$.\\  
% 
% For  example,  a  standard  deck  of  $N == 52$  playing  cards  can  be  divided  in  many  ways. Type  I  could  be  “Hearts”  and  Type  II    could  be  “All  Others.”    Then  there  are   $A == 13$ Hearts and  $B == 39$ Others.\\
% 
% In analogy to the genes/probes problem, $N == 20,000$ probes,  $A == 50$ or 200, as in the top 50 or the top 200 most strongly positively/negatively {\textit {COMT}}-correlated probes. Thus B is either 19,950 ($A == 50 $) or B is 19,800 ( $A == 200$). 
% 
% There are two other parameters: $n == $the number of probes randomnly sampled without replacement, and  $k = $ the number of probes in the sample of size n that also are contained in A. The calculation for the probability that a sample of size n will contain k probes in common with the set in A is:\\
% $$
% p = \frac{\binom{A,k}*\binom{B,(n-k)}}{\binom{N,n}}
% $$


<<include=FALSE, echo=FALSE, results=tex>>=
# Conditional on the 50 probes with expression levels most strongly positively and negatively correlated with COMT expression, find the probability of n of 50 matching

# Sampling without replacement


     num.Probes <- length(unique(hold.Area.dat$illumpf))
     N <- num.Probes
     A <- cut.Part   # number of probes in the reference area that could be matched
     B <- N - A         # number of prtobes not in slected set in reference area
n <- A     # sample of 50 probes
# then k ranges from 0 to A matches

###*** Note ***#####
# The average NUMBER of matches to the top 50 probes expected with a sample of 50 randomly
# selected genes in another area will be n x A/N or 200(200/20000) = 0.125 <- This is not a proportion; it is the expected number of matches - much less than 1 probe should match by chance.

# prob.N will hold the discrete probability distribution for k matches from a sample size either of 50 or 200.

prob.N <- mpfr(matrix(rep(0,(A+1))),precBits=50)
for (k in 1:A) {
     
     prob.N[k+1] <- (chooseMpfr(A,k)*chooseMpfr(B,(n-k)))/chooseMpfr(N,n)
}


prob.N[1] <- 1.0 - sum(prob.N[2:(A+1)])


     prob.N.200 <- data.frame(n.match=seq(0,cut.Part,1),prob=as.numeric(log10(prob.N)))
     write.table(prob.N.200,file=paste('hypergeometric_probability_table_',cut.Part,'.csv',sep=''),sep=', ',row.names=FALSE)



@


<<include=FALSE, echo=FALSE>>=  # , fig=TRUE, pdf=TRUE
# For plotting purposes, the last probability in each frame is 0, so leave that out
# also because it is a discrete distribution, only plot every 5th or 10th point

     
# Using <<- instead of <- allows the variable to used globally
     # Do this when prob.N.200 is first set up in another program
#prob.N.200.plot <- prob.N.200[c(seq(1,200,10)),]
     # Call the hyperplot.R function to plot the hypergeometric distributions
loLim <- c(50)
hiLim <- c(200)
limitseq <- c(0,200,25)

# Using <<- instead of <- allows the variable to used globally
     # Do this when prob.N.200 is first set up in another program

#     p.plot <- hyper.plot(prob.N.50,prob.N.200,loLim,hiLim,limitseq,prog.Name)     



# file.eps <- c('hypergeometric_distributions_50_200.pdf')
#   postscript(file=file.eps,horiz=FALSE,onefile=FALSE,width=8.0,height=5.5,paper='letter')
# 
# p.plot

@

The hypergeometric distributions using the parameters described above are shown in the next figure.\\

%\includegraphics[width=0.5\textwidth]{hypergeometric_matching_genes_diagram.pdf}\\


<<include=FALSE, echo=FALSE, results=tex>>=
############## This needs to be changed to reflect the two prob.N as prob.N.50 and prob.N.200 and the fact that the probabilities are already represented as log10

genes.In.common <- cbind(perc.Overlap.pos[,c(1,5,3)],perc.Overlap.neg[,c(5,3)])



     genes.In.common$logp.valpos <- round(as.numeric(prob.N.200[(perc.Overlap.pos[,2]+1),2]),1)
     genes.In.common$logp.valneg <- round(as.numeric(prob.N.200[(perc.Overlap.neg[,2]+1),2]),1)

     
genes.In.common <- genes.In.common[,c(1:3,6,4,5,7)]

genes.In.common.tab <- xtable(genes.In.common,
                   caption = c(paste("Percentages of the ",cut.Part," Most Strongly Correlated Genes Shared in Common Between Two Brain Areas",sep="")))


genes.In.common.ltx <- latex(genes.In.common.tab,file='',
                   caption = c(paste("Percentages of the ",cut.Part," Most Strongly Correlated Genes Shared in Common Between Two Brain Areas",sep="")),
                     caption.loc = c('top'),
#                     colname = c('Name','URL'),
                     rowlabel = NULL,
                     colnamesTexCmd="bfseries",
                     booktabs=TRUE,
                     label=c('tab:sharedgenes'),
                     na.blank = TRUE,
                     vbar = FALSE,
                     longtable=TRUE,
                     table.env=TRUE,
                     center=c('center'),
                     continued=c('Genes Shared Across Areas Continued'),
                     first.hline.double = TRUE,
                     append=FALSE
                     )
                  
print(genes.In.common.ltx)

write.table(genes.In.common,paste('shared_perc_',cut.Part,'_posneg.csv',sep=', '),row.names = FALSE)

@


<<echo=FALSE, results=tex>>=
################################################
### Select the top 200 by p-value to determine which genes expression levels (by chromosome) are most highly correlated with COMT expression.
### Done separately for positive and negative correlations
### Inversely normalized by fitted number of probes from the regression on chr length, but weighted by proportion of each chromosome in the top 200. 
################################################

##### Positive correlations with COMT expression only #####################
num.Sel <- cut.Part
full.Count <- table(manhat.Posr.pf$CHR)
order.by.P.pos <- manhat.Posr.pf[order(manhat.Posr.pf$P), ]

order.by.P.pos$P <- -log10(order.by.P.pos$P)
colnames(order.by.P.pos)[3] <- c('-log10p')
xtable(order.by.P.pos[1:num.Sel,],caption=c(paste(cut.Part,' Genes with Strongest Positive Correlations with COMT in Prefrontal Cortex',sep='')))

############ End positive only ########################
  
##### Negative correlations with COMT expression only #####################
full.Count <- table(manhat.Negr.pf$CHR)
order.by.P.neg <- manhat.Negr.pf[order(manhat.Negr.pf$P), ]
order.by.P.neg$P <- -log10(order.by.P.neg$P)
colnames(order.by.P.neg)[3] <- c('-log10p')

xtable(order.by.P.neg[1:num.Sel,],caption=c(paste(cut.Part,' Genes with Strongest Negative Correlations with COMT in Prefrontal Cortex',sep='')))

############ End negative only ########################

@

{\bfseries {Gene ontology analysis}}\\

<<echo=FALSE, include=FALSE, results=tex>>=

if (!exists('ensembl')) {
 ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")   
}

normal.chroms <- c(1:22, "X", "Y", "M")

if (!exists('ah')) {
 ah <- AnnotationHub()   
}

if (!exists('orgs')) {
 orgs <- AnnotationHub::query(ah, "org.Hs.eg.db")   
}

if (!exists('gene.DB')) {
 gene.DB <- orgs[["AH57973"]]   
}

# columns(gene.DB)
# keytypes(gene.DB)




# input entrez ID output gene symbol
# temp.Gene <- c('COMT',   'PHGDH',  'DDR1',   'SCAMP2', 'ZFAND3', 'NECAP2', 'HDAC1',  'FTL', 'TST',    'CRYL1')
# 

topplusr.Data$GENE <- gsub(" ", "", topplusr.Data$GENE)
topminusr.Data$GENE <- gsub(" ", "", topminusr.Data$GENE)

twohundred_comt_plus <- na.omit(biomaRt::select(gene.DB,keys=as.character(topplusr.Data$GENE[2:51]),columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL')))

write.table(twohundred_comt_plus,file='twohundred_comt_plus_corr.csv',sep=', ',quote=FALSE)


twohundred_comt_minus <- na.omit(biomaRt::select(gene.DB,keys=as.character(topminusr.Data$GENE[2:51]),columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL')))

write.table(twohundred_comt_minus,file='twohundred_comt_minus_corr.csv',sep=', ',quote=FALSE)


     

     top200.Pos <- biomaRt::select(gene.DB,keys=order.by.P.pos$GENE[1:num.Sel],columns=c('GENENAME','SYMBOL','ENTREZID'),keytype=c('SYMBOL'))
     
#          top.Pos <- top200.Pos
     top.Pos <- twohundred_comt_plus
          
     top200.Neg <- biomaRt::select(gene.DB,keys=order.by.P.neg$GENE[1:num.Sel],columns=c('GENENAME','SYMBOL','ENTREZID'                    ),keytype=c('SYMBOL'))
     


#          top.Neg <- top200.Neg
          top.Neg <- twohundred_comt_minus


pos.Tab <- xtable(top.Pos,caption=c(paste('Top ',cut.Part,' Positively Correlated Genes with COMT in Prefrontal Cortex',sep='')))

pos.Tab

neg.Tab <- xtable(top.Neg,caption=c(paste('Top ',cut.Part,' Negatively Correlated Genes with COMT in Prefrontal Cortex',sep='')))

neg.Tab

@

<<include=FALSE, echo=FALSE, results=tex>>=

#org.Hs.egGO is an R object that provides
#mappings between entrez gene identifers and the GO
#identifers that they are directly associated with
entrez_object <- org.Hs.egGO    # 


# *********** Ontology on various ranking criteria:
# a. most strongly correlated (co-expressed) genes
# b. highest variance across brain areas in correlations with COMT
# c. highest coefficient of variatiopn (CV) across brain areas in correlations with COMT
# d. highest variance across brain areas in mean expression on a per gene basis
# e. highest coefficient of variatiopn (CV) across brain areas in mean expression on a per gene basis

top.Num <- c(50)
skip.CV <- c(1)

one.genelims <- matrix(rep(NA,4),ncol=2)
one.genelims[1,1:2] <- c(skip.CV,(skip.CV + top.Num -1))

dtop <- c(1)
for (d in 1:dtop) {
     
     for (q in 1:2)   {
     
### onegene data set ordered by correlation (+ to -)
one.genelims[2,1] <- length(area.onegene.List[[d]]$Symbol)
one.genelims[2,2] <- length(area.onegene.List[[d]]$Symbol) - (top.Num - 1)

gene.Set <- as.character(area.onegene.List[[d]]$ENTREZID[one.genelims[q,1]:one.genelims[q,2]])

universe <- as.character(unique(area.onegene.List[[d]]$ENTREZID))
#################################################################
          
##### Coefficient of variation - correlation   
          
# one.genelims[2,1] <- length(area.colwise$coeffVar.expr)
# one.genelims[2,2] <- length(area.colwise$coeffVar.expr) - (top.Num - 1)
# 
# gene.Set <- as.character(area.colwise$ENTREZID[one.genelims[q,1]:one.genelims[q,2]])
# 
# universe <- as.character(unique(area.colwise$ENTREZID))
########################################################


params <- new('GOHyperGParams',                          #
              geneIds=gene.Set,
              universeGeneIds=universe,
              ontology='BP',
              pvalueCutoff=0.001,
              conditional=F,
              testDirection='over',
              annotation="org.Hs.eg.db"
             )
bp.ontol <- hyperGTest(params)
bp.ontology.results <- summary(bp.ontol)

# Now get the genes that matched each ontology term
ontol.genes <- list()
max.Count <- 0
for (i in 1:dim(bp.ontology.results)[1]) {

     allgos <- geneIdUniverse(bp.ontol)[[i]]
     mygos <- geneIds(bp.ontol)[geneIds(bp.ontol) %in% allgos]
#mygos
# "93664" "22930" "6456"  "9581"  "6860"  "8618"

     # goid.and.term <- data.frame(gobpid=bp.ontology.results$GOBPID[i],
     #                        term=bp.ontology.results$Term[i])
     gene.Symbols <- getBM(c("hgnc_symbol"),
                             filters = c("entrezgene"),
                             values = list(entrezgene=mygos),
                             mart = ensembl)
# temp.list <- list(goid.and.term,
#                   gene.Symbols)
     if (bp.ontology.results$Count[i] > max.Count) {
          max.Count <- bp.ontology.results$Count[i]
     } else {}
     
ontol.genes[[i]] <- list(bp.ontology.results[i,],
                            gene.Symbols)

}

num.ontol <- dim(bp.ontology.results)[1]

fname_ontology <- c(paste('genes_by_ontolTerm',sign.Names[q],'_',stand.Col.names[d],'.csv',
                          sep=''))

# fname_ontology <- c(paste('genes_by_ontolTerm_CVzexpr.csv',
#                           sep=''))

for (k in 1:num.ontol)  {
     
   write(print(unlist(ontol.genes[[k]]),rownames=FALSE,quote=FALSE),ncolumns=(7+max.Count),append=TRUE,file=fname_ontology,sep=',')       
}

ontology.tab <- xtable(bp.ontology.results,
                                caption=c('Ontology for the 50 genes with the strongest positive (negative) COMT-correlations'),
                                digits=c(0,0,9,2,2,0,0,0))

} # end sign loop
} # end area loop

print.xtable(ontology.tab,
             file=c(paste('ontology_50_',sign.Names[q],'_',stand.Col.names[d],'.tex',sep='')),
                         type='latex',
                         floating=FALSE,
                         caption.placement='top',
                         tabular.environment='longtable',
                         caption.width ='0.5\\textwidth',
                         hline.after=c(-1,0,nrow(ontology.tab)),
                         include.rownames=FALSE,
                         print.results=TRUE,
                         booktabs=TRUE,
                         comment=TRUE
                         )


@

The above analyses show that for the most part, ordering the genes by the largest correlation-variancle or z(expression)-variance or by the corresponding coefficients of variation (CV), and doing ontology on the 20 highest ranking genes, produces little significance in almost all areas of ontology.\\

Ranking by these measures would reveal the genes whose correlations or mean expression levels changed the most across brain areas. Thus, these would not necessarily be the genes co-expressed with COMT, but rather those that in some brain areas could have been strongly co-expressed with COMT while in others, those same genes were not or were negatively co-expressed.\\

In contrast, ranking on the correlation coefficient alone (split by sign) tended to produce more significant ontology results.\\

<< results=tex>>=
# Ontology on 50 most strongly negatively correlated genes in ********Cerebellum***********

gene.Set <- as.character(cbell.Data.onegene$ENTREZID[length(cebll.Data.onegene$ENTREZID):(length(cbell.Data.onegene$ENTREZID) - 49)])

universe <- as.character(unique(cbell.Data.onegene$ENTREZID))

params <- new('GOHyperGParams',                          #
              geneIds=gene.Set,
              universeGeneIds=universe,
              ontology='BP',
              pvalueCutoff=0.001,
              conditional=F,
              testDirection='over',
              annotation="org.Hs.eg.db"
             )
bp.ontol <- hyperGTest(params)
bp.ontology.results <- summary(bp.ontol)


# Now get the genes that matched each ontology term
neg50.ontol.pf <- list()
max.Count <- 0
for (i in 1:dim(bp.ontology.results)[1]) {

     allgos <- geneIdUniverse(bp.ontol)[[i]]
     mygos <- geneIds(bp.ontol)[geneIds(bp.ontol) %in% allgos]
#mygos
# "93664" "22930" "6456"  "9581"  "6860"  "8618"

     # goid.and.term <- data.frame(gobpid=bp.ontology.results$GOBPID[i],
     #                        term=bp.ontology.results$Term[i])
     gene.Symbols <- getBM(c("hgnc_symbol"),
                    filters = c("entrezgene"),
                    values = list(entrezgene=mygos),
                    mart = ensembl)
# temp.list <- list(goid.and.term,
#                   gene.Symbols)
     if (bp.ontology.results$Count[i] > max.Count) {
          max.Count <- bp.ontology.results$Count[i]
     } else {}
     
neg50.ontol.pf[[i]] <- list(bp.ontology.results[i,],
                            gene.Symbols)

}

num.ontol <- dim(bp.ontology.results)[1]

fname_ontology <- c('genes_by_ontolTerm_negpf.csv')
for (k in 1:num.ontol)  {
     
   write(print(unlist(neg50.ontol.pf[[k]]),rownames=FALSE,quote=FALSE),ncolumns=(7+max.Count),append=TRUE,file=fname_ontology,sep=',')       
}


pf.neg50.ontology.tab <- xtable(bp.ontology.results,
                                caption=c('Ontology for the 50 most strongly negatively correlated genes in Prefrontal Cortex'),
                                digits=c(0,0,9,2,2,0,0,0))

print.xtable(pf.neg50.ontology.tab,
                                  file=c('ontology_prefrontal_neg_50.tex'),
                         type='latex',
                         floating=FALSE,
                         caption.placement='top',
                         tabular.environment='longtable',
                         caption.width ='0.5\\textwidth',
                         hline.after=c(-1,0,nrow(pf.neg50.ontology.tab)),
                         include.rownames=FALSE,
                         print.results=TRUE,
                         booktabs=TRUE,
                         comment=TRUE
                         )



temp.refseq <- getBM(c("hgnc_symbol"),
                    filters = c("entrezgene"),
                    values = list(entrezgene=mygos),
                    mart = ensembl)



@

<<>>=
# Instead, use the actual Illumina probes converted to ENTREZIDs in the data set
# Get the ENTREZ ID for all of the probes in the original data
# universe.Probes <- data.frame(ENTREZID=na.omit(unlist(mget(x = prefront.Data$Record,envir=illuminaHumanv2ENTREZID))))

universe.Genes.entrez <- as.character(prefront.Data.onegene$ENTREZID)


# universe.Probes$ENTREZID now holds all of the ENTREZIDs for all of the ILMN probes

# Convert to a list
#entrez_to_go <- as.list(entrez_object[mapped_genes])
entrez_to_go <- as.list(entrez_object[universe.Probes$ENTREZID])


#map GO terms to Entrez gene ids
go_object <- as.list(org.Hs.egGO2EG)


# axon_gene <- go_object['GO:0007411']
# length(unlist(axon_gene, use.names=F))
# 
# axon_gene <- unique(unlist(axon_gene, use.names=F))
# head(axon_gene)

shared_genes_plus.pfpo.entrezid <- unique(entrez.Shared50.pfpo)

my_genes_plus <- unique(top.Pos$ENTREZID)
my_genes_minus <- unique(top.Neg$ENTREZID)
#universe <- mapped_genes


universe <- unique(universe.Probes$ENTREZID)
length(universe)

params <- new('GOHyperGParams',
              geneIds=unique(prefront.Data.onegene$ENTREZID[1:200]),
              universeGeneIds=unique(universe.Genes.entrez),
              ontology='BP',
              pvalueCutoff=0.001,
              conditional=F,
              testDirection='over',
              annotation="org.Hs.eg.db"
             )
bpOver.plus <- hyperGTest(params)
bp.ontology.results.plus <- summary(bpOver.plus)

params <- new('GOHyperGParams',
              geneIds=unique(prefront.Data.onegene$ENTREZID[dim(prefront.Data.onegene)[1]:(dim(prefront.Data.onegene)[1] - 200 + 1)]),
              universeGeneIds=unique(universe.Genes.entrez),
              ontology='BP',
              pvalueCutoff=0.001,
              conditional=F,
              testDirection='over',
              annotation="org.Hs.eg.db"
             )
bpOver.neg <- hyperGTest(params)
bp.ontology.results.neg <- summary(bpOver.neg)






ontology.200.plusA <- xtable(ontology.results.200Plus[,1:6],
                            caption='Ontology analysis results with top 200 positive correlations (p less than .001)')

ontology.200.plusB <- xtable(data.frame(ontology.results.200Plus[,7]),
                            caption='Ontology analysis significantly enriched GO terms with top 200 positive correlations (p less than .001)')

# results_GO <- go_object[results$GOBPID]
# go_object['GO:0051589']


params <- new('GOHyperGParams',
              geneIds=my_genes_minus,
              universeGeneIds=universe,
              ontology='BP',
              pvalueCutoff=0.001,
              conditional=F,
              testDirection='over',
              annotation="org.Hs.eg.db"
             )
hgOver.minus <- hyperGTest(params)
ontology.results.200Minus <- summary(hgOver.minus)

ontology.200.minusA <- xtable(ontology.results.200Minus[,1:6],
                            caption='Ontology analysis results with top 200 positive correlations (p less than .001)')

ontology.200.minusB <- xtable(data.frame(ontology.results.200Minus[,7]),
                            caption='Ontology analysis significantly enriched GO terms with top 200 positive correlations (p less than .001)')


# results_GO <- go_object[results$GOBPID]
# intersect(my_genes_plus$ENTREZID,unlist(results_GO[[1]]))


@





{\bfseries {Mutual rank:}} co-expression Pearson correlation coefficient RANK with gene A as target and gene B as co-expressed, and vice versa. The two ranks are then geometrically averaged. Smaller MR scores mean stronger co-expression.\\

<<echo=FALSE, include=FALSE, results=tex>>=
print(xtable(coexpress.URL[1,],caption=c('The next co-expression analysis used the database at this URL to find the top 500 genes coexpressed with COMT. That list was then checked against the top 200 genes (+ and - separately) from the comt-prefrontal data to find agreement between the two lists.')))


### read the COMT coexpression data file 
hold.Matchpos <- matrix(c(rep(NA,cut.Part)),ncol=1)
hold.Matchneg <- matrix(c(rep(NA,cut.Part)),ncol=1)
hold.Chrompos <- matrix(c(rep(NA,cut.Part)),ncol=1)
hold.Chromneg <- matrix(c(rep(NA,cut.Part)),ncol=1)

wbhsa <- loadWorkbook('comt_coex_list_500_hsa.xlsx')
# wbhsa2 <- loadWorkbook('comt_coex_list_500_hsa2.xlsx')
# wbhsa3 <- loadWorkbook('comt_coex_list_500_hsa3.xlsx')

coexpress.Data <- data.frame(read.xlsx(wbhsa,         # now tell R to read that workbook and which sheet
                                  sheet = "coex500"))


coexpress.Data$Entrez.Gene.ID <- as.character(coexpress.Data$Entrez.Gene.ID)

for (ma in 1:num.Sel) {

  if (isTRUE(which(coexpress.Data$Entrez.Gene.ID == as.character(top.Pos$ENTREZID[ma])) != 0)) {
    hold.Matchpos[ma] <- coexpress.Data$Gene[which(coexpress.Data$Entrez.Gene.ID == as.character(top.Pos$ENTREZID[ma]))]
  } else {
    
  }
     
  
  if (isTRUE(which(coexpress.Data$Entrez.Gene.ID == as.character(top.Neg$ENTREZID[ma])) != 0)) {
    hold.Matchneg[ma] <- coexpress.Data$Gene[which(coexpress.Data$Entrez.Gene.ID == as.character(top.Neg$ENTREZID[ma]))]
  } else {
    
  } 
}


pos.Matches <- na.omit(hold.Matchpos)

neg.Matches <- na.omit(hold.Matchneg)

if (length(pos.Matches) > 0) {
my.symbols <- pos.Matches
my.regions <- getBM(c("hgnc_symbol", "chromosome_name", "start_position", "end_position", "band"),
                    filters = c("hgnc_symbol", "chromosome_name"),
                    values = list(hgnc_symbol=my.symbols, chromosome_name=normal.chroms),
                    mart = ensembl)
my.regions$chromosome_name

posmatch.DF <- data.frame(geneSymbol=pos.Matches,chromosome=my.regions$chromosome_name)


} else {posmatch.DF <- data.frame(geneSymbol=NA,chromosome=NA)
}

xtable(posmatch.DF,caption=c(paste('Genes matching the top ',cut.Part,' positively COMT - correlated genes in Prefrontal',sep='')))


if (length(neg.Matches) > 0) {
my.symbols <- neg.Matches
my.regions <- getBM(c("hgnc_symbol", "chromosome_name", "start_position", "end_position", "band"),
                    filters = c("hgnc_symbol", "chromosome_name"),
                    values = list(hgnc_symbol=my.symbols, chromosome_name=normal.chroms),
                    mart = ensembl)
my.regions$chromosome_name

negmatch.DF <- data.frame(geneSymbol=neg.Matches,chromosome=my.regions$chromosome_name)


} else {negmatch.DF <- data.frame(geneSymbol=NA,chromosome=NA)
}

xtable(negmatch.DF,caption=paste('Genes matching the top ',cut.Part,' negatively COMT - correlated genes in Prefrontal',sep=''))

@

% Genes from \Sexpr{print(coexpress.URL[1,])} that overlap with the 10 most highly positively correlated genes with COMT in Prefrontal Cortex:\\
% \Sexpr{pos.Matches[1:length(pos.Matches)]}\\
% 
% (Note: this database most likely only shows positively correlated coexpression genes.)\\
% Genes from \Sexpr{print(coexpress.URL[1,])} that overlap with the 10 most highly negatively correlated genes with COMT in Prefrontal Cortex:\\
% \Sexpr{neg.Matches[1:length(neg.Matches)]}\\


<< results=tex>>=
# use the web interface at http://amp.pharm.mssm.edu/Enrichr/enrich to do various kinds of ontology on the top (+) and bottom (-) of the <area-abbrev>.Data.onegene correlation-ranked data.


# first, verify that prefront.Data.onegene is ordered by Sample.r (this only verifies that the
# max(r) and min(r) are at the top and bottom of the ranked data)
check.Order <- as.vector(c(rep(NA,8)))

for (vi in seq(1,7,2))   {

 if(max(area.onegene.List[[vi]]$Sample.r) != area.onegene.List[[vi]]$Sample.r[1])  {
      
      check.Order[vi] <- FALSE
      
 }  else if (max(area.onegene.List[[vi]]$Sample.r) == area.onegene.List[[vi]]$Sample.r[1]) {
      
      check.Order[vi] <- TRUE
 }  else {
      
 }

# negative
# Check ordering at bottom of data

  if(min(area.onegene.List[[vi]]$Sample.r) != area.onegene.List[[vi]]$Sample.r[length(area.onegene.List[[vi]]$Sample.r)])  {
      
      check.Order[vi + 1] <- FALSE
      
 }  else if (min(area.onegene.List[[vi]]$Sample.r) == area.onegene.List[[vi]]$Sample.r[length(area.onegene.List[[vi]]$Sample.r)]) {
      
      check.Order[vi + 1] <- TRUE
 }  else {
      
 }
     
} # end combined brain area and sign loop

check.Order

num.Ont <- c(50)

symbols.top.bottom.50 <- data.frame(pfpos=rep(0,num.Ont),
                                    pfneg=rep(0,num.Ont),
                                    cbpos=rep(0,num.Ont),
                                    cbneg=rep(0,num.Ont),
                                    tmpos=rep(0,num.Ont),
                                    tmneg=rep(0,num.Ont),
                                    popos=rep(0,num.Ont),
                                    poneg=rep(0,num.Ont))

# my.mod <-function(x,m)
#   {
#     return(m - (x %% m))
#   }

for (v in seq(1,7,2))   {
     for (w in 1:2)   {
          
          lims.Ont <- matrix(c(1,
                             num.Ont,
                             length(area.onegene.List[[(v+(w-1))]]$Sample.r),
                             (length(area.onegene.List[[(v+(w-1))]]$Sample.r) - num.Ont + 1)),
                             ncol=2,byrow=TRUE)
     
symbols.top.bottom.50[1:num.Ont,(v+(w-1))] <- noquote(area.onegene.List[[(v+(w-1))]]$Symbol[lims.Ont[w,1]:lims.Ont[w,2]])

     } # end sign loop
} # end brain area loop

@

<< >>=
######### ******** Enrichr ontology ********* #############

dbs.Poss <- listEnrichrDbs()

dbs.up <- c('GTEx_Tissue_Sample_Gene_Expression_Profiles_up')
dbs.down <- c('GTEx_Tissue_Sample_Gene_Expression_Profiles_down')

#enriched <- enrichr(as.character(symbols.top.bottom.50$pfneg), dbs)
enriched <- enrichr(as.character(pf.specific.up$pf.a[1:50]), dbs.down)

enriched[['GTEx_Tissue_Sample_Gene_Expression_Profiles_down']][1:40,]





@


\end{document}


 
